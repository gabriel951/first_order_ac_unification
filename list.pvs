% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: list.pvs
% Description: functions related to solving diophantine equations
%%%%%%%%%%%%%%%%%%%%%%%

list_theory[T: TYPE]: THEORY
BEGIN

x, y, z: VAR T
pair_lst: VAR [list[T], list[T]]

lst_pair1, lst_pair2: VAR list[[T, T]]

lst, lst1, lst2: VAR list[T]
lst_of_lsts, matrix: VAR list[list[T]]

n, n3, inc, elem_seen_so_far, cur_greater: VAR nat
coef, coef1, coef2, lst_nat: VAR list[nat]

% append_pair((l1, l2)) = append(l1, l2)
append_pair(pair_lst): list[T] =
    LET lst1 = pair_lst`1,
    	lst2 = pair_lst`2
	IN append(lst1, lst2)

% for every y in lst2, obtain the pair (x, y)
cartesian_product_aux(x, lst2): RECURSIVE list[[T, T]] =
    IF null?(lst2) THEN null
    ELSE LET y = car(lst2) IN
    	     cons((x, y), cartesian_product_aux(x, cdr(lst2)))
    ENDIF
MEASURE lst2 BY << 

% cartesian product of two lists
cartesian_product(lst1, lst2): RECURSIVE list[[T, T]] =
    IF null?(lst1) THEN null
    ELSE LET x = car(lst1)
    	 IN  append(cartesian_product_aux(x, lst2), cartesian_product(cdr(lst1), lst2))
    ENDIF 
MEASURE lst1 BY <<  

% receives a list of lists of elements of type T. Outputs a list containing all these elements of type T
% For example, if it receives [[1], [2,3], [4]] it outputs [1, 2, 3, 4]
flatten(lst_of_lsts): RECURSIVE list[T] =
    IF null?(lst_of_lsts) THEN null
    ELSE LET lst = car(lst_of_lsts)
    IN append(lst, flatten(cdr(lst_of_lsts)))
    ENDIF
MEASURE lst_of_lsts BY <<

% returns a list [0, 1, ..., n]
nat_upto(n): RECURSIVE list[nat] =
    IF n = 0 THEN cons(0, null)
    ELSE append(nat_upto(n-1), cons(n, null))
    ENDIF
MEASURE n

% increments by "inc" the number in position "n" of the list of natural numbers "lst_nat"
% we start counting at 1
increment(lst_nat, n, inc): RECURSIVE list[nat] =
    IF null?(lst_nat) OR n = 0 THEN lst_nat
    ELSE LET x = car(lst_nat) IN
         IF n = 1 THEN cons(x + inc, cdr(lst_nat))
	 ELSE cons(x, increment(cdr(lst_nat), n - 1, inc))
	 ENDIF
    ENDIF
MEASURE lst_nat BY << 

% the first call to this function should be pos?(x, lst, 0)
% returns a bool to indicate if x is in lst and a natural number, to indicate the position
% elem_seen_so_far indicates how many elements so far we have seen in the list
% we start counting the position at 1
pos?(x, lst, elem_seen_so_far): RECURSIVE [bool, nat] =
    IF null?(lst) THEN (FALSE, 0)
    ELSE LET y = car(lst) IN
    	 IF x = y THEN (TRUE, elem_seen_so_far + 1)
	 ELSE pos?(x, cdr(lst), elem_seen_so_far + 1)
	 ENDIF
    ENDIF
MEASURE lst BY << 

% the first call to this function should be count_elem(null, null, lst2)
% lst2, is a list of elements [l1, ..., ln] possibly with repetitions
% lst1, when the function finish, contains all elements initially in lst2, without repetitions
% coef contain the number of repetitions of the elements in lst2
count_elem(lst1, coef, lst2): RECURSIVE [list[T], list[nat]] =
    IF null?(lst2) THEN (lst1, coef) 
    ELSE LET
    	 x = car(lst2),
    	 (in_lst, n) = pos?(x, lst2, 0)
	 IN IF in_lst THEN LET
	     	new_coef = increment(coef, n, 1)
	     	IN count_elem(lst1, new_coef, cdr(lst2))
	    ELSE LET
	     	new_lst1 = append(lst1, cons(x, null)),
	     	new_coef = append(coef, cons(1, null))
	     	IN count_elem(new_lst1, new_coef, cdr(lst2))
	    ENDIF
    ENDIF
MEASURE lst2 BY << 

% lst - list of elements, coef - list of the multiplicities of each element in lst
% get multiplicity of element x in lst
get_multiplicity(x, lst, coef): RECURSIVE nat =
    IF null?(lst) OR null?(coef) THEN 0
    ELSE IF x = car(lst) THEN car(coef)
    	 ELSE get_multiplicity(x, cdr(lst), cdr(coef))
	 ENDIF
    ENDIF
MEASURE lst BY << 

% lst1 - list of elements, coef1 - list of the multiplicities of each element in lst1
% lst2 - list of elements, coef2 - list of the multiplicities of each element in lst2
% this function returns the elements that appear more times in lst1 than in lst2,
% and how many times they appear more in lst1 than in lst2
select_args(lst1, coef1, lst2, coef2): RECURSIVE [list[T], list[nat]] =
    IF null?(lst1) OR null?(coef1) THEN (null, null)
    ELSE LET
    	 x = car(lst1),
	 n1 = car(coef1), 
	 n2 = get_multiplicity(x, lst2, coef2) IN
	 IF n1 > n2 THEN LET
	    lst3 = cons(x, select_args(cdr(lst1), cdr(coef1), lst2, coef2)`1),
	    coef3 = cons(n1 - n2, select_args(cdr(lst1), cdr(coef1), lst2, coef2)`2)
	    IN (lst3, coef3) 
	 ELSE select_args(cdr(lst1), cdr(coef1), lst2, coef2)
	 ENDIF
    ENDIF
MEASURE lst1 BY << 

% receives a matrix = [l1, ..., ln] and an element x
% put element x as the first column of the matrix = [cons(x, l1), ..., cons(x, ln)]
put_in_first_col(matrix, x): RECURSIVE list[list[T]] =
    IF null?(matrix) THEN null
    ELSE LET lst = car(matrix) IN
	     cons(cons(x, lst), put_in_first_col(cdr(matrix), x))
    ENDIF
MEASURE matrix BY <<

% returns a list [x, ..., x] of length n
get_repeat_lst(x, n): RECURSIVE list[T] =
    IF n = 0 THEN null
    ELSE cons(x, get_repeat_lst(x, n-1))
    ENDIF
MEASURE n

% outside call to this function should be select_greater(lst_nat, 0)
% selects the greater element in lst_nat
select_greater(lst_nat, cur_greater): RECURSIVE nat =
    IF null?(lst_nat) THEN 0
    ELSE LET n = car(lst_nat) IN
     	 IF n > cur_greater THEN select_greater(cdr(lst_nat), n)
	 ELSE select_greater(cdr(lst_nat), cur_greater)
	 ENDIF 
    ENDIF
MEASURE lst_nat BY << 

%%%%%%%%%%%%%%%%%%%%% Theorems
%% general properties
member_append: LEMMA
    member(x, append(lst1, lst2)) = (member(x, lst1) OR member(x, lst2)) 

member_append2: LEMMA
    member((x, y), append(lst_pair1, lst_pair2)) = (member((x,y), lst_pair1) OR member((x,y), lst_pair2))

% cartesian product
cart_prod_aux_mem: LEMMA
    member(y, lst) = member((x, y), cartesian_product_aux(x, lst))

cart_prod_aux_mem2: LEMMA
    member((x, y), cartesian_product_aux(z, lst)) => x = z
    
cart_prod_mem: LEMMA
    (member(x, lst1) AND member(y, lst2)) = member((x, y), cartesian_product(lst1, lst2))
    
END list_theory
