% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: list.pvs
% Description: 
%%%%%%%%%%%%%%%%%%%%%%%

list_theory[T: TYPE]: THEORY
BEGIN

x, y, z: VAR T
pair_lst: VAR [list[T], list[T]]

lst_pair, lst_pair1, lst_pair2: VAR list[[T, T]]

lst, lst1, lst2, new_lst1, new_lst2: VAR list[T]
lst_of_lsts, lst_of_lsts1, lst_of_lsts2: VAR list[list[T]]

num: VAR number
n, i, j, min, max, inc, elem_seen_so_far, cur_greater: VAR nat
coef, coef1, coef2, lst_nat, lst_nat1, lst_nat2: VAR list[nat]

% append_pair((l1, l2)) = append(l1, l2)
append_pair(pair_lst): list[T] =
    LET lst1 = pair_lst`1,
    	lst2 = pair_lst`2
	IN append(lst1, lst2)

% for every y in lst2, obtain the pair (x, y)
cartesian_product_aux(x, lst2): RECURSIVE list[[T, T]] =
    IF null?(lst2) THEN null
    ELSE LET y = car(lst2) IN
    	     cons((x, y), cartesian_product_aux(x, cdr(lst2)))
    ENDIF
MEASURE lst2 BY << 

% cartesian product of two lists
cartesian_product(lst1, lst2): RECURSIVE list[[T, T]] =
    IF null?(lst1) THEN null
    ELSE LET x = car(lst1)
    	 IN  append(cartesian_product_aux(x, lst2), cartesian_product(cdr(lst1), lst2))
    ENDIF 
MEASURE lst1 BY <<  

% receives a list of lists of elements of type T. Outputs a list containing all these elements of type T
% For example, if it receives [[1], [2,3], [4]] it outputs [1, 2, 3, 4]
flatten(lst_of_lsts): RECURSIVE list[T] =
    IF null?(lst_of_lsts) THEN null
    ELSE LET lst = car(lst_of_lsts)
    IN append(lst, flatten(cdr(lst_of_lsts)))
    ENDIF
MEASURE lst_of_lsts BY <<

% let lst_i = nth(lst_of_lsts, i) and x = nth(lst_i, j).
% returns 0 when i or j are not valid indexes
% find the index "n" such that x = nth(flatten(lst_of_lsts), n)
ind_flatten(lst_of_lsts, i, j): RECURSIVE nat =
    IF i >= length(lst_of_lsts) THEN 0
    ELSE LET lst = car(lst_of_lsts) IN
       IF i = 0 THEN
          IF j >= length(lst) THEN 0
          ELSE j 
	  ENDIF
       ELSE length(lst) + ind_flatten(cdr(lst_of_lsts), i-1, j) 
       ENDIF
    ENDIF
MEASURE lst_of_lsts BY <<
	 

% returns a list [min, min+1, ..., max]
% if max < min, return null
%from_min2max(min, max): RECURSIVE list[nat] =
%    IF min > max THEN null
%    ELSIF min = max THEN cons(max, null)
%    ELSE  append(from_min2max(min, max-1), cons(max, null))
%    ENDIF
%MEASURE max

from_min2max(min, max): RECURSIVE list[nat] =
    IF min > max THEN null
    ELSIF min = max THEN cons(min, null) 
    ELSE cons(min, from_min2max(min + 1, max)) 
    ENDIF
MEASURE max(0, max-min) 

% increments by "inc" the number in position "n" of the list of natural numbers "lst_nat"
% we start counting at 1
increment(lst_nat, n, inc): RECURSIVE list[nat] =
    IF null?(lst_nat) OR n = 0 THEN lst_nat
    ELSE LET x = car(lst_nat) IN
         IF n = 1 THEN cons(x + inc, cdr(lst_nat))
	 ELSE cons(x, increment(cdr(lst_nat), n - 1, inc))
	 ENDIF
    ENDIF
MEASURE lst_nat BY << 

% the first call to this function should be pos?(x, lst, 0)
% returns a bool to indicate if x is in lst and a natural number, to indicate the position
% elem_seen_so_far indicates how many elements so far we have seen in the list
% we start counting the position at 1
pos?(x, lst, elem_seen_so_far): RECURSIVE [bool, nat] =
    IF null?(lst) THEN (FALSE, 0)
    ELSE LET y = car(lst) IN
    	 IF x = y THEN (TRUE, elem_seen_so_far + 1)
	 ELSE pos?(x, cdr(lst), elem_seen_so_far + 1)
	 ENDIF
    ENDIF
MEASURE lst BY << 

% the first call to this function should be count_elem(null, null, lst2)
% lst2, is a list of elements [l1, ..., ln] possibly with repetitions
% lst1, when the function finish, contains all elements initially in lst2, without repetitions
% coef contain the number of repetitions of the elements in lst2
count_elem(lst1, coef, lst2): RECURSIVE [list[T], list[nat]] =
    IF null?(lst2) THEN (lst1, coef) 
    ELSE LET
    	 x = car(lst2),
    	 (in_lst, n) = pos?(x, lst2, 0)
	 IN IF in_lst THEN LET
	     	new_coef = increment(coef, n, 1)
	     	IN count_elem(lst1, new_coef, cdr(lst2))
	    ELSE LET
	     	new_lst1 = append(lst1, cons(x, null)),
	     	new_coef = append(coef, cons(1, null))
	     	IN count_elem(new_lst1, new_coef, cdr(lst2))
	    ENDIF
    ENDIF
MEASURE lst2 BY << 

% lst - list of elements, coef - list of the multiplicities of each element in lst
% get multiplicity of element x in lst
get_multiplicity(x, lst, coef): RECURSIVE nat =
    IF null?(lst) OR null?(coef) THEN 0
    ELSE IF x = car(lst) THEN car(coef)
    	 ELSE get_multiplicity(x, cdr(lst), cdr(coef))
	 ENDIF
    ENDIF
MEASURE lst BY << 

% lst1 - list of elements, coef1 - list of the multiplicities of each element in lst1
% lst2 - list of elements, coef2 - list of the multiplicities of each element in lst2
% this function returns the elements that appear more times in lst1 than in lst2,
% and how many times they appear more in lst1 than in lst2
select_args(lst1, coef1, lst2, coef2): RECURSIVE [list[T], list[nat]] =
    IF null?(lst1) OR null?(coef1) THEN (null, null)
    ELSE LET
    	 x = car(lst1),
	 n1 = car(coef1), 
	 n2 = get_multiplicity(x, lst2, coef2) IN
	 IF n1 > n2 THEN LET
	    lst3 = cons(x, select_args(cdr(lst1), cdr(coef1), lst2, coef2)`1),
	    coef3 = cons(n1 - n2, select_args(cdr(lst1), cdr(coef1), lst2, coef2)`2)
	    IN (lst3, coef3) 
	 ELSE select_args(cdr(lst1), cdr(coef1), lst2, coef2)
	 ENDIF
    ENDIF
MEASURE lst1 BY << 

% receives a lst of lists = [l1, ..., ln] and an element x
% put element x as the first element of each lst li.
% the resul is [cons(x, l1), ..., cons(x, ln)]
put_in_head(lst_of_lsts, x): RECURSIVE list[list[T]] =
    IF null?(lst_of_lsts) THEN null
    ELSE LET lst = car(lst_of_lsts) IN
	     cons(cons(x, lst), put_in_head(cdr(lst_of_lsts), x))
    ENDIF
MEASURE lst_of_lsts BY <<

% returns a list [x, ..., x] of length n
get_repeat_lst(x, n): RECURSIVE list[T] =
    IF n = 0 THEN null
    ELSE cons(x, get_repeat_lst(x, n-1))
    ENDIF
MEASURE n

% outside call to this function should be select_greater(lst_nat, 0)
% selects the greatest element in lst_nat
select_greater(lst_nat, cur_greater): RECURSIVE nat =
    IF null?(lst_nat) THEN 0
    ELSE LET n = car(lst_nat) IN
     	 IF n > cur_greater THEN select_greater(cdr(lst_nat), n)
	 ELSE select_greater(cdr(lst_nat), cur_greater)
	 ENDIF 
    ENDIF
MEASURE lst_nat BY << 


% tests if all lists in lst_of_lsts have length n
all_lsts_length?(lst_of_lsts, n): RECURSIVE bool =
    IF null?(lst_of_lsts) THEN TRUE
    ELSE IF length(car(lst_of_lsts)) = n THEN all_lsts_length?(cdr(lst_of_lsts), n)
    	 ELSE FALSE
	 ENDIF
    ENDIF
MEASURE lst_of_lsts BY << 

% returns TRUE if lst_of_lsts is a matrix. Returns FALSE otherwise
matrix?(lst_of_lsts): bool =
    IF null?(lst_of_lsts) THEN TRUE
    ELSE LET lst = car(lst_of_lsts) IN
    	     all_lsts_length?(lst_of_lsts, length(lst))
    ENDIF

% returns TRUE if lst_of_lsts is not a matrix. Returns FALSE otherwise
nonmatrix?(lst_of_lsts): bool = NOT matrix?(lst_of_lsts)

% receives a list lst = [x1, ..., xn]
% returns a list [lst_1, ..., lst_m] such that every lst_i is a sublist of lst
get_all_sublists(lst): RECURSIVE list[list[T]] =
    IF null?(lst) THEN null
    ELSE LET x = car(lst),
	     % get all lists without the element x
	     lst_of_lsts1 = get_all_sublists(cdr(lst)), 
	     % get all lists with the element x
	     lst_of_lsts2 = put_in_head(lst_of_lsts1, x)
	     IN append(lst_of_lsts1, lst_of_lsts2)
    ENDIF
MEASURE lst BY <<

% count how many times the element x appears on lst
count(x, lst): RECURSIVE nat =
    IF null?(lst) THEN 0
    ELSE LET y = car(lst) IN
    	 IF x = y THEN 1 + count(x, cdr(lst))
	 ELSE count(x, cdr(lst))
	 ENDIF
    ENDIF
MEASURE lst BY <<

% let lst_of_lsts = [l1, ..., ln].
% get the ith element (we start counting at 1) in l1 "x1_i", ..., get the ith element in ln "xn_i"
% returns [x1_i, ..., xn_i]
% if a list lj has no ith element, put x instead
get_col_i(lst_of_lsts, i, x): RECURSIVE list[T] =
    IF null?(lst_of_lsts) THEN null
    ELSE LET lst = car(lst_of_lsts) IN
    	 IF i <= length(lst) AND i > 0 THEN LET y = nth(lst, i-1) IN
	    cons(y, get_col_i(cdr(lst_of_lsts), i, x))
	 ELSE cons(x, get_col_i(cdr(lst_of_lsts), i, x))
	 ENDIF
    ENDIF
MEASURE lst_of_lsts BY << 

% let lst1 = [x1, ..., xn] and lst2 = [y1, ..., yn]
% pareate returns [(x1, y1), ..., (xn, yn)]
pareate(lst1, lst2): RECURSIVE list[[T, T]] =
    IF null?(lst1) OR null?(lst2) THEN null
    ELSE LET x = car(lst1), y = car(lst2) IN cons((x, y), pareate(cdr(lst1), cdr(lst2)))
    ENDIF
MEASURE lst1 BY <<

% receives lst = [x1, ..., xn, xn+1, ..., xj] and an index n
% returns lst1 = [x1, ..., xn]
get_lst_until_n(lst, n): RECURSIVE list[T] =
    IF n = 0 OR null?(lst) THEN null
    ELSE LET x = car(lst) IN
    	     cons(x, get_lst_until_n(cdr(lst), n-1))
    ENDIF
MEASURE n 

% receives lst = [x1, ..., xn, xn+1, ..., xj] and an index n
% returns lst2 = [xn+1, ..., xj]
get_lst_after_n(lst, n): RECURSIVE list[T] =
    IF n = 0 OR null?(lst) THEN lst
    ELSE get_lst_after_n(cdr(lst), n-1)
    ENDIF
MEASURE n 

% split lst = [x1, ..., xn, xn+1, ..., xj] into two lists:
% lst1 = [x1, ..., xn] and lst2 = [xn+1, ..., xj]
split(lst, n): [list[T], list[T]] =
    (get_lst_until_n(lst, n), get_lst_after_n(lst, n))  

% receives a list of the form [[x1, y1], ..., [xn, yn]]
% returns [y1, ..., yn]
snd_proj(lst_pair): RECURSIVE list[T] = 
    IF null?(lst_pair) THEN null
    ELSE LET y = car(lst_pair)`2 IN
         cons(y, snd_proj(cdr(lst_pair)))
    ENDIF
MEASURE lst_pair BY << 

% receives a list[x1, ..., xn] and a list of multiplicities[a1, ..., an]
% returns a list with a1 occurrences of x1, ..., an occurrences of xn
get_lst_mult(lst, coef): RECURSIVE list[T] =
    IF null?(lst) OR null?(coef) THEN null 
    ELSE LET x = car(lst), n = car(coef), new_lst = get_repeat_lst(x, n) IN
    	     append(new_lst, get_lst_mult(cdr(lst), cdr(coef))) 
    ENDIF
MEASURE lst BY << 

% remove the ith element from lst.
% counting starts at 0
remove(lst, i): RECURSIVE list[T] =
    IF null?(lst) THEN null 
    ELSIF i = 0 THEN cdr(lst) 
    ELSE LET x = car(lst) IN cons(x, remove(cdr(lst), i-1))
    ENDIF
MEASURE lst BY << 

% receives lst_of_lsts = [lst_0, ..., lst_i, ..., lst_n]
% removes the jth element of lst_i, obtaining lst'_i
% returns lst_of_lsts = [lst_0, ..., lst'_i, ..., lst_n]
% counting start at 0 
remove(lst_of_lsts, i, j): RECURSIVE list[list[T]] =
    IF null?(lst_of_lsts) THEN null 
    ELSE LET lst = car(lst_of_lsts) IN
         IF i = 0 THEN
	     IF length(lst) <= 1 THEN cdr(lst_of_lsts)
	     ELSE cons(remove(lst, j), cdr(lst_of_lsts))
	     ENDIF
	 ELSE cons(lst, remove(cdr(lst_of_lsts), i-1, j))
	 ENDIF
    ENDIF
MEASURE lst_of_lsts BY << 


%%%%%%%%%%%%%%%%%%%%% Theorems
%% general properties
member_append: LEMMA
    member(x, append(lst1, lst2)) = (member(x, lst1) OR member(x, lst2)) 

member_append2: LEMMA
    member((x, y), append(lst_pair1, lst_pair2)) = (member((x,y), lst_pair1) OR member((x,y), lst_pair2))

null_append: LEMMA
    null?(append(lst1, lst2)) = (null?(lst1) AND null?(lst2))

null_append_nat: LEMMA
    null?(append(lst_nat1, lst_nat2)) = (null?(lst_nat1) AND null?(lst_nat2))

cdr_append: LEMMA
    NOT null?(lst1) IMPLIES cdr(append(lst1, lst2)) = append(cdr(lst1), lst2)

nth_append: LEMMA
    i < length(lst1) + length(lst2) IMPLIES
    nth(append(lst1, lst2), i) =
    IF i < length(lst1) THEN nth(lst1, i)
    ELSE nth(lst2, i - length(lst1))
    ENDIF

equal_lst_nth: LEMMA 
    length(lst1) = length(lst2) AND (FORALL (n: below[length(lst1)]): nth(lst1, n) = nth(lst2, n))
    IMPLIES lst1 = lst2

% a property about nth and member
member_nth: LEMMA
    i < length(lst) IMPLIES member(nth(lst, i), lst)

member_nth2: LEMMA
    member(x, lst) = EXISTS (n:below[length(lst)]): x = nth(lst, n)

% cartesian product
cart_prod_aux_mem: LEMMA
    member(y, lst) = member((x, y), cartesian_product_aux(x, lst))

cart_prod_aux_mem2: LEMMA
    member((x, y), cartesian_product_aux(z, lst)) => x = z
    
cart_prod_mem: LEMMA
    (member(x, lst1) AND member(y, lst2)) = member((x, y), cartesian_product(lst1, lst2))
    
% flatten
null_flatten_nth: LEMMA
    i < length(lst_of_lsts) AND null?(flatten(lst_of_lsts)) IMPLIES
    null?(nth(lst_of_lsts, i))

len0_ind_flatten: LEMMA
    length(flatten(lst_of_lsts)) = 0 IMPLIES ind_flatten(lst_of_lsts, i, j) = 0

ind_flatten_len: LEMMA
    i < length(lst_of_lsts) AND j < length(nth(lst_of_lsts, i)) IMPLIES
    ind_flatten(lst_of_lsts, i, j) < length(flatten(lst_of_lsts))

nth_flatten: LEMMA 
    i < length(lst_of_lsts) AND j < length(nth(lst_of_lsts, i)) IMPLIES
    nth(nth(lst_of_lsts, i), j) = nth(flatten(lst_of_lsts), ind_flatten(lst_of_lsts, i, j))


% from_min2max:
from_min2max_len: LEMMA
    length(from_min2max(i, n)) = max(0, n-i+1)

from_min2max_len1: LEMMA
    length(from_min2max(1, n)) = n

from_min2max_car: LEMMA
    NOT null?(from_min2max(i, j)) IMPLIES car(from_min2max(i, j)) = i

nth_from_min2max: LEMMA
    n < length(from_min2max(i, j)) IMPLIES
    nth(from_min2max(i, j), n) = i + n

nth_from_min2max2: LEMMA
    n < length(from_min2max(1, j)) IMPLIES
    nth(from_min2max(1, j), n) = n + 1
    
% select_args 
select_args_pos: LEMMA
    member(n, select_args(lst1, coef1, lst2, coef2)`2) IMPLIES n > 0 
    
select_args_pos2: LEMMA
    member(num, select_args(lst1, coef1, lst2, coef2)`2) IMPLIES
    (num > 0 AND number_field_pred(num) AND real_pred(num))

select_args_len: LEMMA
    LET (lst3, coef3) = select_args(lst1, coef1, lst2, coef2) IN
    length(lst3) = length(coef3) 

% get_repeat_lst
get_repeat_lst_len: LEMMA
    length(get_repeat_lst(x, n)) = n

% pareate
pareate_append: LEMMA
    (length(lst1) = length(new_lst1) AND length(lst2) = length(new_lst2)) IMPLIES
    pareate(append(lst1, lst2), append(new_lst1, new_lst2)) =
    append(pareate(lst1, new_lst1), pareate(lst2, new_lst2))

% get_lst_until_n, get_lst_after_n
len_get_lst_until_n: LEMMA
    length(get_lst_until_n(lst, n)) = min(length(lst), n) 

nth_get_lst_until_n: LEMMA
    LET lst1 = get_lst_until_n(lst, n) IN
    i < length(lst1) IMPLIES nth(lst1, i) = nth(lst, i)

get_lst_until_n_append: LEMMA
    get_lst_until_n(append(lst1, lst2), length(lst1)) = lst1

len_get_lst_after_n: LEMMA
    length(get_lst_after_n(lst, n)) = max(length(lst) - n, 0)

nth_get_lst_after_n: LEMMA
    LET lst1 = get_lst_until_n(lst, n),
    	lst2 = get_lst_after_n(lst, n) IN
    i >= length(lst1) AND i < length(lst1) + length(lst2) IMPLIES
    nth(lst2, i - length(lst1)) = nth(lst, i) 

get_lst_after_n_append: LEMMA
    get_lst_after_n(append(lst1, lst2), length(lst1)) = lst2

% split
split_cor: LEMMA
    LET (lst1, lst2) = split(lst, n) IN
    append(lst1, lst2) = lst

split_append: LEMMA
    split(append(lst1, lst2), length(lst1)) = (lst1, lst2)

% snd_proj:
snd_proj_pareate: LEMMA
    length(lst1) = length(lst2) IMPLIES 
    snd_proj(pareate(lst1, lst2)) = lst2

% remove
remove_len: LEMMA
    i < length(lst) IMPLIES
    length(remove(lst, i)) = length(lst) - 1

gt_nth_remove: LEMMA
    i < length(lst) AND i > n IMPLIES
    nth(remove(lst, i), n) = nth(lst, n) 

gt_nth_remove2: LEMMA
    i < length(lst) AND i > n IMPLIES
    nth(remove(lst, n), i-1) = nth(lst, i) 

gt_remove_remove: LEMMA
    i < length(lst) AND i > n IMPLIES
    remove(remove(lst, n), i-1) = remove(remove(lst, i), n)

remove_append: LEMMA
    remove(append(lst1, lst2), i) =
    IF i < length(lst1) THEN append(remove(lst1, i), lst2)
    ELSE append(lst1, remove(lst2, i - length(lst1)))
    ENDIF

flatten_remove: LEMMA
    i < length(lst_of_lsts) AND j < length(nth(lst_of_lsts, i)) IMPLIES
    remove(flatten(lst_of_lsts), ind_flatten(lst_of_lsts, i, j)) =
    flatten(remove(lst_of_lsts, i, j))

END list_theory
