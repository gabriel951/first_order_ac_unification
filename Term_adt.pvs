%%% ADT file generated from terms

Term_adt[Constant: TYPE+, Variable: TYPE+, F_symbol: TYPE+,
         Ac_f_symbol: TYPE+]: THEORY
 BEGIN
  ASSUMING
   Constant_TCC1: ASSUMPTION EXISTS (x: Constant): TRUE;

   Variable_TCC1: ASSUMPTION EXISTS (x: Variable): TRUE;

   F_symbol_TCC1: ASSUMPTION EXISTS (x: F_symbol): TRUE;

   Ac_f_symbol_TCC1: ASSUMPTION EXISTS (x: Ac_f_symbol): TRUE;
  ENDASSUMING

  Term: TYPE

  const?, var?, unit?, pair?, app?, ac_app?: [Term -> boolean]

  a: [(const?) -> Constant]

  V: [(var?) -> Variable]

  term1: [(pair?) -> Term]

  term2: [(pair?) -> Term]

  f_sym: [(app?) -> F_symbol]

  arg: [(app?) -> Term]

  ac_f_sym: [(ac_app?) -> Ac_f_symbol]

  ac_arg: [(ac_app?) -> Term]

  const: [Constant -> (const?)]

  variable: [Variable -> (var?)]

  unit: (unit?)

  pair: [[Term, Term] -> (pair?)]

  app: [[F_symbol, Term] -> (app?)]

  ac_app: [[Ac_f_symbol, Term] -> (ac_app?)]

  Term_ord: [Term -> upto(5)]

  Term_ord_defaxiom: AXIOM
         (FORALL (a: Constant): Term_ord(const(a)) = 0)
     AND (FORALL (V: Variable): Term_ord(variable(V)) = 1)
     AND Term_ord(unit) = 2
     AND (FORALL (term1: Term, term2: Term):
            Term_ord(pair(term1, term2)) = 3)
     AND (FORALL (f_sym: F_symbol, arg: Term):
            Term_ord(app(f_sym, arg)) = 4)
     AND (FORALL (ac_f_sym: Ac_f_symbol, ac_arg: Term):
            Term_ord(ac_app(ac_f_sym, ac_arg)) = 5);

  ord(x: Term): [Term -> upto(5)] =
      CASES x
        OF const(const1_var): 0,
           variable(variable1_var): 1,
           unit: 2,
           pair(pair1_var, pair2_var): 3,
           app(app1_var, app2_var): 4,
           ac_app(ac_app1_var, ac_app2_var): 5
        ENDCASES

  Term_const_extensionality: AXIOM
    FORALL (const?_var: (const?), const?_var2: (const?)):
      a(const?_var) = a(const?_var2) IMPLIES const?_var = const?_var2;

  Term_const_eta: AXIOM
    FORALL (const?_var: (const?)): const(a(const?_var)) = const?_var;

  Term_variable_extensionality: AXIOM
    FORALL (var?_var: (var?), var?_var2: (var?)):
      V(var?_var) = V(var?_var2) IMPLIES var?_var = var?_var2;

  Term_variable_eta: AXIOM
    FORALL (var?_var: (var?)): variable(V(var?_var)) = var?_var;

  Term_unit_extensionality: AXIOM
    FORALL (unit?_var: (unit?), unit?_var2: (unit?)):
      unit?_var = unit?_var2;

  Term_pair_extensionality: AXIOM
    FORALL (pair?_var: (pair?), pair?_var2: (pair?)):
      term1(pair?_var) = term1(pair?_var2) AND
       term2(pair?_var) = term2(pair?_var2)
       IMPLIES pair?_var = pair?_var2;

  Term_pair_eta: AXIOM
    FORALL (pair?_var: (pair?)):
      pair(term1(pair?_var), term2(pair?_var)) = pair?_var;

  Term_app_extensionality: AXIOM
    FORALL (app?_var: (app?), app?_var2: (app?)):
      f_sym(app?_var) = f_sym(app?_var2) AND arg(app?_var) = arg(app?_var2)
       IMPLIES app?_var = app?_var2;

  Term_app_eta: AXIOM
    FORALL (app?_var: (app?)):
      app(f_sym(app?_var), arg(app?_var)) = app?_var;

  Term_ac_app_extensionality: AXIOM
    FORALL (ac_app?_var: (ac_app?), ac_app?_var2: (ac_app?)):
      ac_f_sym(ac_app?_var) = ac_f_sym(ac_app?_var2) AND
       ac_arg(ac_app?_var) = ac_arg(ac_app?_var2)
       IMPLIES ac_app?_var = ac_app?_var2;

  Term_ac_app_eta: AXIOM
    FORALL (ac_app?_var: (ac_app?)):
      ac_app(ac_f_sym(ac_app?_var), ac_arg(ac_app?_var)) = ac_app?_var;

  Term_a_const: AXIOM
    FORALL (const1_var: Constant): a(const(const1_var)) = const1_var;

  Term_V_variable: AXIOM
    FORALL (variable1_var: Variable):
      V(variable(variable1_var)) = variable1_var;

  Term_term1_pair: AXIOM
    FORALL (pair1_var: Term, pair2_var: Term):
      term1(pair(pair1_var, pair2_var)) = pair1_var;

  Term_term2_pair: AXIOM
    FORALL (pair1_var: Term, pair2_var: Term):
      term2(pair(pair1_var, pair2_var)) = pair2_var;

  Term_f_sym_app: AXIOM
    FORALL (app1_var: F_symbol, app2_var: Term):
      f_sym(app(app1_var, app2_var)) = app1_var;

  Term_arg_app: AXIOM
    FORALL (app1_var: F_symbol, app2_var: Term):
      arg(app(app1_var, app2_var)) = app2_var;

  Term_ac_f_sym_ac_app: AXIOM
    FORALL (ac_app1_var: Ac_f_symbol, ac_app2_var: Term):
      ac_f_sym(ac_app(ac_app1_var, ac_app2_var)) = ac_app1_var;

  Term_ac_arg_ac_app: AXIOM
    FORALL (ac_app1_var: Ac_f_symbol, ac_app2_var: Term):
      ac_arg(ac_app(ac_app1_var, ac_app2_var)) = ac_app2_var;

  Term_inclusive: AXIOM
    FORALL (Term_var: Term):
          const?(Term_var) OR var?(Term_var) OR unit?(Term_var)
       OR pair?(Term_var) OR app?(Term_var) OR ac_app?(Term_var);

  Term_induction: AXIOM
    FORALL (p: [Term -> boolean]):
      (     FORALL (const1_var: Constant): p(const(const1_var))
        AND FORALL (variable1_var: Variable): p(variable(variable1_var))
        AND p(unit)
        AND FORALL (pair1_var: Term, pair2_var: Term):
              p(pair1_var) AND p(pair2_var) IMPLIES
               p(pair(pair1_var, pair2_var))
        AND FORALL (app1_var: F_symbol, app2_var: Term):
              p(app2_var) IMPLIES p(app(app1_var, app2_var))
        AND FORALL (ac_app1_var: Ac_f_symbol, ac_app2_var: Term):
              p(ac_app2_var) IMPLIES p(ac_app(ac_app1_var, ac_app2_var)))
       IMPLIES (FORALL (Term_var: Term): p(Term_var));

  every(p1: PRED[Constant], p2: PRED[Variable], p3: PRED[F_symbol],
        p4: PRED[Ac_f_symbol])
       (a1: Term):
        boolean =
      CASES a1
        OF const(const1_var): p1(const1_var),
           variable(variable1_var): p2(variable1_var),
           unit: TRUE,
           pair(pair1_var, pair2_var):
             every(p1, p2, p3, p4)(pair1_var) AND
              every(p1, p2, p3, p4)(pair2_var),
           app(app1_var, app2_var):
             p3(app1_var) AND every(p1, p2, p3, p4)(app2_var),
           ac_app(ac_app1_var, ac_app2_var):
             p4(ac_app1_var) AND every(p1, p2, p3, p4)(ac_app2_var)
        ENDCASES;

  every(p1: PRED[Constant], p2: PRED[Variable], p3: PRED[F_symbol],
        p4: PRED[Ac_f_symbol], a1: Term):
        boolean =
      CASES a1
        OF const(const1_var): p1(const1_var),
           variable(variable1_var): p2(variable1_var),
           unit: TRUE,
           pair(pair1_var, pair2_var):
             every(p1, p2, p3, p4, pair1_var) AND
              every(p1, p2, p3, p4, pair2_var),
           app(app1_var, app2_var):
             p3(app1_var) AND every(p1, p2, p3, p4, app2_var),
           ac_app(ac_app1_var, ac_app2_var):
             p4(ac_app1_var) AND every(p1, p2, p3, p4, ac_app2_var)
        ENDCASES;

  some(p1: PRED[Constant], p2: PRED[Variable], p3: PRED[F_symbol],
       p4: PRED[Ac_f_symbol])
      (a1: Term):
        boolean =
      CASES a1
        OF const(const1_var): p1(const1_var),
           variable(variable1_var): p2(variable1_var),
           unit: FALSE,
           pair(pair1_var, pair2_var):
             some(p1, p2, p3, p4)(pair1_var) OR
              some(p1, p2, p3, p4)(pair2_var),
           app(app1_var, app2_var):
             p3(app1_var) OR some(p1, p2, p3, p4)(app2_var),
           ac_app(ac_app1_var, ac_app2_var):
             p4(ac_app1_var) OR some(p1, p2, p3, p4)(ac_app2_var)
        ENDCASES;

  some(p1: PRED[Constant], p2: PRED[Variable], p3: PRED[F_symbol],
       p4: PRED[Ac_f_symbol], a1: Term):
        boolean =
      CASES a1
        OF const(const1_var): p1(const1_var),
           variable(variable1_var): p2(variable1_var),
           unit: FALSE,
           pair(pair1_var, pair2_var):
             some(p1, p2, p3, p4, pair1_var) OR
              some(p1, p2, p3, p4, pair2_var),
           app(app1_var, app2_var):
             p3(app1_var) OR some(p1, p2, p3, p4, app2_var),
           ac_app(ac_app1_var, ac_app2_var):
             p4(ac_app1_var) OR some(p1, p2, p3, p4, ac_app2_var)
        ENDCASES;

  subterm(x: Term, y: Term):  boolean =
      x = y OR
       CASES y
         OF const(const1_var): FALSE,
            variable(variable1_var): FALSE,
            unit: FALSE,
            pair(pair1_var, pair2_var):
              subterm(x, pair1_var) OR subterm(x, pair2_var),
            app(app1_var, app2_var): subterm(x, app2_var),
            ac_app(ac_app1_var, ac_app2_var): subterm(x, ac_app2_var)
         ENDCASES;

  <<:  (strict_well_founded?[Term]) =
      LAMBDA (x, y: Term):
        CASES y
          OF const(const1_var): FALSE,
             variable(variable1_var): FALSE,
             unit: FALSE,
             pair(pair1_var, pair2_var):
               (x = pair1_var OR x << pair1_var) OR
                x = pair2_var OR x << pair2_var,
             app(app1_var, app2_var): x = app2_var OR x << app2_var,
             ac_app(ac_app1_var, ac_app2_var):
               x = ac_app2_var OR x << ac_app2_var
          ENDCASES;

  Term_well_founded: AXIOM strict_well_founded?[Term](<<);

  reduce_nat(const?_fun: [Constant -> nat], var?_fun: [Variable -> nat],
             unit?_fun: nat, pair?_fun: [[nat, nat] -> nat],
             app?_fun: [[F_symbol, nat] -> nat],
             ac_app?_fun: [[Ac_f_symbol, nat] -> nat]):
        [Term -> nat] =
      LAMBDA (Term_adtvar: Term):
        LET red: [Term -> nat] =
              reduce_nat(const?_fun, var?_fun, unit?_fun, pair?_fun,
                         app?_fun, ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var),
               variable(variable1_var): var?_fun(variable1_var),
               unit: unit?_fun,
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var)),
               app(app1_var, app2_var): app?_fun(app1_var, red(app2_var)),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var))
            ENDCASES;

  REDUCE_nat(const?_fun: [[Constant, Term] -> nat],
             var?_fun: [[Variable, Term] -> nat], unit?_fun: [Term -> nat],
             pair?_fun: [[nat, nat, Term] -> nat],
             app?_fun: [[F_symbol, nat, Term] -> nat],
             ac_app?_fun: [[Ac_f_symbol, nat, Term] -> nat]):
        [Term -> nat] =
      LAMBDA (Term_adtvar: Term):
        LET red: [Term -> nat] =
              REDUCE_nat(const?_fun, var?_fun, unit?_fun, pair?_fun,
                         app?_fun, ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var, Term_adtvar),
               variable(variable1_var):
                 var?_fun(variable1_var, Term_adtvar),
               unit: unit?_fun(Term_adtvar),
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var), Term_adtvar),
               app(app1_var, app2_var):
                 app?_fun(app1_var, red(app2_var), Term_adtvar),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var), Term_adtvar)
            ENDCASES;

  reduce_ordinal(const?_fun: [Constant -> ordinal],
                 var?_fun: [Variable -> ordinal], unit?_fun: ordinal,
                 pair?_fun: [[ordinal, ordinal] -> ordinal],
                 app?_fun: [[F_symbol, ordinal] -> ordinal],
                 ac_app?_fun: [[Ac_f_symbol, ordinal] -> ordinal]):
        [Term -> ordinal] =
      LAMBDA (Term_adtvar: Term):
        LET red: [Term -> ordinal] =
              reduce_ordinal(const?_fun, var?_fun, unit?_fun, pair?_fun,
                             app?_fun, ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var),
               variable(variable1_var): var?_fun(variable1_var),
               unit: unit?_fun,
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var)),
               app(app1_var, app2_var): app?_fun(app1_var, red(app2_var)),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var))
            ENDCASES;

  REDUCE_ordinal(const?_fun: [[Constant, Term] -> ordinal],
                 var?_fun: [[Variable, Term] -> ordinal],
                 unit?_fun: [Term -> ordinal],
                 pair?_fun: [[ordinal, ordinal, Term] -> ordinal],
                 app?_fun: [[F_symbol, ordinal, Term] -> ordinal],
                 ac_app?_fun: [[Ac_f_symbol, ordinal, Term] -> ordinal]):
        [Term -> ordinal] =
      LAMBDA (Term_adtvar: Term):
        LET red: [Term -> ordinal] =
              REDUCE_ordinal(const?_fun, var?_fun, unit?_fun, pair?_fun,
                             app?_fun, ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var, Term_adtvar),
               variable(variable1_var):
                 var?_fun(variable1_var, Term_adtvar),
               unit: unit?_fun(Term_adtvar),
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var), Term_adtvar),
               app(app1_var, app2_var):
                 app?_fun(app1_var, red(app2_var), Term_adtvar),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var), Term_adtvar)
            ENDCASES;
 END Term_adt

Term_adt_map[Constant: TYPE+, Variable: TYPE+, F_symbol: TYPE+,
             Ac_f_symbol: TYPE+, Constant1: TYPE+, Variable1: TYPE+,
             F_symbol1: TYPE+, Ac_f_symbol1: TYPE+]: THEORY
 BEGIN
  ASSUMING
   Constant_TCC1: ASSUMPTION EXISTS (x: Constant): TRUE;

   Variable_TCC1: ASSUMPTION EXISTS (x: Variable): TRUE;

   F_symbol_TCC1: ASSUMPTION EXISTS (x: F_symbol): TRUE;

   Ac_f_symbol_TCC1: ASSUMPTION EXISTS (x: Ac_f_symbol): TRUE;

   Constant1_TCC1: ASSUMPTION EXISTS (x: Constant1): TRUE;

   Variable1_TCC1: ASSUMPTION EXISTS (x: Variable1): TRUE;

   F_symbol1_TCC1: ASSUMPTION EXISTS (x: F_symbol1): TRUE;

   Ac_f_symbol1_TCC1: ASSUMPTION EXISTS (x: Ac_f_symbol1): TRUE;
  ENDASSUMING

  IMPORTING Term_adt

  map(f1: [Constant -> Constant1], f2: [Variable -> Variable1],
      f3: [F_symbol -> F_symbol1], f4: [Ac_f_symbol -> Ac_f_symbol1])
     (a1: Term[Constant, Variable, F_symbol, Ac_f_symbol]):
        Term[Constant1, Variable1, F_symbol1, Ac_f_symbol1] =
      CASES a1
        OF const(const1_var): const(f1(const1_var)),
           variable(variable1_var): variable(f2(variable1_var)),
           unit: unit,
           pair(pair1_var, pair2_var):
             pair(map(f1, f2, f3, f4)(pair1_var),
                  map(f1, f2, f3, f4)(pair2_var)),
           app(app1_var, app2_var):
             app(f3(app1_var), map(f1, f2, f3, f4)(app2_var)),
           ac_app(ac_app1_var, ac_app2_var):
             ac_app(f4(ac_app1_var), map(f1, f2, f3, f4)(ac_app2_var))
        ENDCASES;

  map(f1: [Constant -> Constant1], f2: [Variable -> Variable1],
      f3: [F_symbol -> F_symbol1], f4: [Ac_f_symbol -> Ac_f_symbol1],
      a1: Term[Constant, Variable, F_symbol, Ac_f_symbol]):
        Term[Constant1, Variable1, F_symbol1, Ac_f_symbol1] =
      CASES a1
        OF const(const1_var): const(f1(const1_var)),
           variable(variable1_var): variable(f2(variable1_var)),
           unit: unit,
           pair(pair1_var, pair2_var):
             pair(map(f1, f2, f3, f4, pair1_var),
                  map(f1, f2, f3, f4, pair2_var)),
           app(app1_var, app2_var):
             app(f3(app1_var), map(f1, f2, f3, f4, app2_var)),
           ac_app(ac_app1_var, ac_app2_var):
             ac_app(f4(ac_app1_var), map(f1, f2, f3, f4, ac_app2_var))
        ENDCASES;

  every(R1: [[Constant, Constant1] -> boolean],
        R2: [[Variable, Variable1] -> boolean],
        R3: [[F_symbol, F_symbol1] -> boolean],
        R4: [[Ac_f_symbol, Ac_f_symbol1] -> boolean])
       (x: Term[Constant, Variable, F_symbol, Ac_f_symbol],
        y: Term[Constant1, Variable1, F_symbol1, Ac_f_symbol1]):
        boolean =
          const?(x) AND const?(y) AND R1(a(x), a(y))
       OR var?(x) AND var?(y) AND R2(V(x), V(y)) OR unit?(x) AND unit?(y)
       OR pair?(x) AND
           pair?(y) AND
            every(R1, R2, R3, R4)(term1(x), term1(y)) AND
             every(R1, R2, R3, R4)(term2(x), term2(y))
       OR app?(x) AND
           app?(y) AND
            R3(f_sym(x), f_sym(y)) AND every(R1, R2, R3, R4)(arg(x), arg(y))
       OR ac_app?(x) AND
           ac_app?(y) AND
            R4(ac_f_sym(x), ac_f_sym(y)) AND
             every(R1, R2, R3, R4)(ac_arg(x), ac_arg(y));
 END Term_adt_map

Term_adt_reduce[Constant: TYPE+, Variable: TYPE+, F_symbol: TYPE+,
                Ac_f_symbol: TYPE+, range: TYPE]: THEORY
 BEGIN
  ASSUMING
   Constant_TCC1: ASSUMPTION EXISTS (x: Constant): TRUE;

   Variable_TCC1: ASSUMPTION EXISTS (x: Variable): TRUE;

   F_symbol_TCC1: ASSUMPTION EXISTS (x: F_symbol): TRUE;

   Ac_f_symbol_TCC1: ASSUMPTION EXISTS (x: Ac_f_symbol): TRUE;
  ENDASSUMING

  IMPORTING Term_adt[Constant, Variable, F_symbol, Ac_f_symbol]

  reduce(const?_fun: [Constant -> range], var?_fun: [Variable -> range],
         unit?_fun: range, pair?_fun: [[range, range] -> range],
         app?_fun: [[F_symbol, range] -> range],
         ac_app?_fun: [[Ac_f_symbol, range] -> range]):
        [Term[Constant, Variable, F_symbol, Ac_f_symbol] -> range] =
      LAMBDA (Term_adtvar:
                Term[Constant, Variable, F_symbol, Ac_f_symbol]):
        LET red: [Term[Constant, Variable, F_symbol, Ac_f_symbol] -> range]
              =
              reduce(const?_fun, var?_fun, unit?_fun, pair?_fun, app?_fun,
                     ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var),
               variable(variable1_var): var?_fun(variable1_var),
               unit: unit?_fun,
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var)),
               app(app1_var, app2_var): app?_fun(app1_var, red(app2_var)),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var))
            ENDCASES;

  REDUCE(const?_fun:
           [[Constant, Term[Constant, Variable, F_symbol, Ac_f_symbol]] ->
              range],
         var?_fun:
           [[Variable, Term[Constant, Variable, F_symbol, Ac_f_symbol]] ->
              range],
         unit?_fun:
           [Term[Constant, Variable, F_symbol, Ac_f_symbol] -> range],
         pair?_fun:
           [[range, range,
             Term[Constant, Variable, F_symbol, Ac_f_symbol]] ->
              range],
         app?_fun:
           [[F_symbol, range,
             Term[Constant, Variable, F_symbol, Ac_f_symbol]] ->
              range],
         ac_app?_fun:
           [[Ac_f_symbol, range,
             Term[Constant, Variable, F_symbol, Ac_f_symbol]] ->
              range]):
        [Term[Constant, Variable, F_symbol, Ac_f_symbol] -> range] =
      LAMBDA (Term_adtvar:
                Term[Constant, Variable, F_symbol, Ac_f_symbol]):
        LET red: [Term[Constant, Variable, F_symbol, Ac_f_symbol] -> range]
              =
              REDUCE(const?_fun, var?_fun, unit?_fun, pair?_fun, app?_fun,
                     ac_app?_fun)
          IN
          CASES Term_adtvar
            OF const(const1_var): const?_fun(const1_var, Term_adtvar),
               variable(variable1_var):
                 var?_fun(variable1_var, Term_adtvar),
               unit: unit?_fun(Term_adtvar),
               pair(pair1_var, pair2_var):
                 pair?_fun(red(pair1_var), red(pair2_var), Term_adtvar),
               app(app1_var, app2_var):
                 app?_fun(app1_var, red(app2_var), Term_adtvar),
               ac_app(ac_app1_var, ac_app2_var):
                 ac_app?_fun(ac_app1_var, red(ac_app2_var), Term_adtvar)
            ENDCASES;
 END Term_adt_reduce