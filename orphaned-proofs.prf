("aux_unification" aux_unification dio_matrix2ac_mem_var 0 (dio_matrix2ac_mem_var-1 nil 3846335765 ("" (skeep) (("" (assert) (("" (flatten) (("" (expand "dio_matrix2ac_sol") (("" (use "member_rhs_pareate") (("" (assert) (("" (hide -2) (("" (rewrite "map_member4") (("" (skolem -1 "args1") (("" (flatten) (("" (replace -2 -3) (("" (lemma "get_ac_from_args_gt1_get_args_mem") (("" (inst -1 "args1" "f" "s") (("" (assert) (("" (lemma "no_null_get_pre_new_args") (("" (inst?) (("" (assert) (("" (rewrite "get_repeat_lst_len") (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification get_pre_new_args_var_subset_cor 0 (get_pre_new_args_var_subset_cor-1 nil 3846769919 ("" (postpone) nil nil) nil shostak))("aux_unification" aux_unification construct_sub_mem_img 0 (construct_sub_mem_img-1 nil 3846777310 ("" (measure-induct "length(dio_matrix)" "dio_matrix") (("" (skolem 1 "dio") (("" (prop) (("" (skeep) (("" (expand "construct_sub" 1) (("" (split) (("1" (prop) (("1" (expand "well_formed?" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "new_var" "get_new_var(vars2avoid)") (("2" (name-replace "new_vars2avoid" "cons(new_var, vars2avoid)") (("2" (name-replace "args_t" "construct_sub_aux(args, get_col_i(coef_matrix, 1))") (("2" (name-replace "t1" "get_ac_from_args_gt1(f)(args_t)") (("2" (expand "well_formed?" 2) (("2" (skeep) (("2" (prop) (("1" (hide -2) (("1" (lemma "elim_col1_matrix[nat]") (("1" (inst -1 "coef_matrix" "length(dio)") (("1" (expand "no_zero_col?" -5) (("1" (flatten) (("1" (assert) (("1" (expand "length" -1 1) (("1" (assert) (("1" (assert) (("1" (name-replace "delta_tail" "construct_sub(cdr(dio), elim_col1(coef_matrix), args, new_vars2avoid, f)") (("1" (expand "subs" -2) (("1" (expand "subs" -2) (("1" (lemma "subs_pair2") (("1" (inst -1 "cons((new_var, t1), null)" "subs(delta_tail)(variable(X))") (("1" (assert) (("1" (expand "subs" -1 1) (("1" (expand "subs" -1 2) (("1" (prop) (("1" (hide -3) (("1" (expand "delta_tail") (("1" (reveal -5) (("1" (inst -1 "cdr(dio)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (expand "well_formed?" -1) (("1" (inst -1 "X") (("1" (prop) (("1" (hide -1) (("1" (expand "subs" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "elim_col1_len[nat]") (("2" (inst?) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification dio_matrix2ac_mem_not_pair 0 (dio_matrix2ac_mem_not_pair-1 nil 3846777090 ("" (skeep) (("" (assert) (("" (flatten) (("" (expand "dio_matrix2ac_sol" -1) (("" (use "member_rhs_pareate") (("" (assert) (("" (hide -2) (("" (rewrite "map_member4") (("" (skolem -1 "args1") (("" (flatten) (("" (expand "get_ac_from_args_gt1" -2) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (use "get_pre_new_args_all_var?2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (map_member4 formula-decl nil map_theory nil) (get_pre_new_args_all_var?2 formula-decl nil aux_unification nil) (/= const-decl "boolean" notequal nil) (is_ac_sym? const-decl "bool" term_properties nil) (get_ac_from_args const-decl "term" term_properties nil) (get_term_from_args def-decl "term" term_properties nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (args type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (string type-eq-decl nil strings nil) (get_ac_from_args_gt1 const-decl "term" aux_unification nil) (dio_matrix type-eq-decl nil diophantine nil) (get_pre_new_args def-decl "[list[args], list[variable]]" aux_unification nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (length def-decl "nat" list_props nil) (member_rhs_pareate formula-decl nil unification nil)) shostak))("list" list_theory count_elem_mem_nth_aux_TCC1 0 (count_elem_mem_nth_aux_TCC1-1 nil 3847734966 ("" (subtype-tcc) nil nil) nil nil (count_elem_mem_nth_aux subtype "list_theory.j" "below[length[nat](new_coef)]")))("list" list_theory count_elem_mem_nth_aux_TCC2 0 (count_elem_mem_nth_aux_TCC2-1 nil 3847734966 ("" (subtype-tcc) nil nil) nil nil (count_elem_mem_nth_aux subtype "list_theory.j" "below[length[nat](coef)]")))("list" list_theory count_elem_mem_nth_aux_TCC3 0 (count_elem_mem_nth_aux_TCC3-1 nil 3847734966 ("" (subtype-tcc) nil nil) nil nil (count_elem_mem_nth_aux subtype "list_theory.i" "below[length[nat](new_coef)]")))("list" list_theory count_elem_mem_nth_aux 0 (count_elem_mem_nth_aux-1 nil 3847734980 ("" (measure-induct "length(lst2)" "lst2") (("1" (skolem 1 "lst2") (("1" (prop) (("1" (hide -1) (("1" (skeep) (("1" (case "member(x, lst)") (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (inst 1 "j") (("1" (prop) (("1" (typepred "j") (("1" (propax) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (typepred "equal?") (("2" (expand "equivalence?" -1) (("2" (flatten) (("2" (expand "reflexive?" -1) (("2" (inst -1 "x") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "count_elem" 1) (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (prop) (("1" (hide 3) (("1" (reveal -1) (("1" (name-replace "n" "pos?(car(lst2), lst, equal?)`2") (("1" (inst -1 "cdr(lst2)") (("1" (prop) (("1" (inst?) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("list" list_theory count_elem2_cor 0 (count_elem2_cor-1 nil 3847739799 ("" (measure-induct "length(lst)" "lst") (("" (skolem 1 "lst") (("" (prop) (("" (skeep) (("" (lemma "equal_lst_nth") (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("list" list_theory count_elem_mem_nth_TCC1 0 (count_elem_mem_nth_TCC1-1 nil 3847734966 ("" (subtype-tcc) nil nil) nil nil (count_elem_mem_nth subtype "list_theory.i" "below[length[nat](new_coef)]")))("list" list_theory count_elem_nth_lt_TCC1 0 (count_elem_nth_lt_TCC1-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_lt subtype "list_theory.n" "below[length[T](new_lst)]")))("list" list_theory count_elem_nth_lt_TCC2 0 (count_elem_nth_lt_TCC2-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_lt subtype "list_theory.n" "below[length[nat](new_coef)]")))("list" list_theory count_elem_nth_lt_TCC3 0 (count_elem_nth_lt_TCC3-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_lt subtype "list_theory.n" "below[length[nat](coef)]")))("list" list_theory count_elem_nth_lt 0 (count_elem_nth_lt-1 nil 3847782788 ("" (measure-induct "length(lst2)" "lst2") (("1" (skolem 1 "lst2") (("1" (prop) (("1" (skeep) (("1" (name-replace "new_lst" "count_elem(lst, coef, lst2, equal?)`1") (("1" (name-replace "new_coef" "count_elem(lst, coef, lst2, equal?)`2") (("1" (name-replace "x" "nth(new_lst, n)") (("1" (reveal -2 -3) (("1" (expand "count_elem" -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (grind) (("1" (expand "x" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (name-replace "i" "pos?(car(lst2), lst, equal?)`2") (("1" (reveal -1) (("1" (expand "count_elem" -4) (("1" (assert) (("1" (replace -1) (("1" (inst -5 "cdr(lst2)") (("1" (assert) (("1" (split -5) (("1" (inst?) (("1" (replace -4) (("1" (replace -5) (("1" (reveal -4) (("1" (assert) (("1" (inst -2 "n") (("1" (replace -1) (("1" (assert) (("1" (split -2) (("1" (flatten) (("1" (assert) (("1" (use "increment_nth") (("1" (assert) (("1" (split) (("1" (flatten) (("1" (replace -2) (("1" (expand "count" 2) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (lemma "pos?_cor") (("1" (inst -1 "equal?" "lst" "car(lst2)") (("1" (assert) (("1" (replace -7) (("1" (replace -2) (("1" (replace -4) (("1" (typepred "equal?") (("1" (expand "equivalence?" -1) (("1" (flatten) (("1" (expand "symmetric?" -2) (("1" (inst -2 "car(lst2)" "nth(lst, n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "count" 3) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (lemma "pos?_cor") (("2" (inst -1 "equal?" "lst" "car(lst2)") (("2" (assert) (("2" (replace -7) (("2" (typepred "equal?") (("2" (expand "equivalence?" -1) (("2" (flatten) (("2" (expand "transitive?" -3) (("2" (inst -3 "x" "car(lst2)" "nth(lst, i)") (("2" (assert) (("2" (expand "dif_elem?" -16) (("2" (inst -16 "i" "n") (("2" (assert) (("2" (replace -7 -3) (("2" (expand "symmetric?" -2) (("2" (inst -2 "nth(lst, n)" "nth(lst, i)") (("2" (assert) (("2" (use "pos?_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "increment_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "cdr(lst2)") (("2" (split -3) (("1" (inst?) (("1" (replace -2) (("1" (expand "count_elem" -3 1) (("1" (assert) (("1" (replace -3) (("1" (inst -1 "n") (("1" (split -1) (("1" (flatten) (("1" (rewrite "nth_append" -1) (("1" (expand "x" 3 1) (("1" (assert) (("1" (lemma "nth_append") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("list" list_theory count_elem_nth_gt_remove_TCC1 0 (count_elem_nth_gt_remove_TCC1-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_gt_remove subtype "list_theory.n" "below[length[T](new_lst1)]")))("list" list_theory count_elem_nth_gt_remove_TCC2 0 (count_elem_nth_gt_remove_TCC2-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_gt_remove subtype "list_theory.n" "below[length[nat](new_coef)]")))("list" list_theory count_elem_nth_gt_remove_TCC3 0 (count_elem_nth_gt_remove_TCC3-1 nil 3847782567 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_gt_remove subtype "list_theory.n" "below[length[nat](new_coef1)]")))("list" more_list_theory_props count_elem_append 0 (count_elem_append-1 nil 3847876028 ("" (measure-induct "length(lst2)" "lst2") (("" (skolem 1 "lst2") (("" (prop) (("" (skeep) (("" (expand "count_elem" 2 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (expand "count_elem" 1 2) (("1" (assert) (("1" (expand "count_elem" 1) (("1" (rewrite "append_null") (("1" (rewrite "append_null") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (hide 1) (("1" (rewrite "pos?_mem2") (("1" (skolem -1 "y") (("1" (inst 2 "y" "car(lst2)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "member" 2 1) (("1" (typepred "equal?") (("1" (expand "equivalence?" -1) (("1" (flatten) (("1" (expand "symmetric?" -2) (("1" (inst -2 "car(lst2)" "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (expand "count_elem" 1 2) (("1" (lift-if) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "append" 2 4) (("2" (expand "append" 2 4) (("2" (inst -1 "cdr(lst2)") (("2" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("list" list_theory remove_lst_elem_count_elem 0 (remove_lst_elem_count_elem-2 nil 3847887467 ("" (measure-induct "length(lst2)" "lst2") (("" (skolem 1 "lst2") (("" (prop) (("" (skeep) (("" (expand "count_elem" 1 1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "remove" 1) (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (inst -3 "cdr(lst2)") (("1" (split -3) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (rewrite "pos?_mem2") (("2" (assert) (("2" (skeep) (("2" (inst 1 "y") (("2" (assert) (("2" (typepred "equal?") (("2" (expand "equivalence?" -1) (("2" (flatten) (("2" (expand "symmetric?" -2) (("2" (inst -2 "car(lst2)" "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "cdr(lst2)") (("2" (prop) (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "length_append") (("1" (assert) (("1" (expand "length" 2 1) (("1" (expand "length" 2 2) (("1" (expand "remove" 2 2) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (rewrite "pos?_mem2") (("1" (inst 2 "x") (("1" (assert) (("1" (rewrite "remove_lst_elem_append") (("1" (typepred "equal?") (("1" (expand "equivalence?" -1) (("1" (flatten) (("1" (expand "symmetric?" -2) (("1" (inst -2 "x" "car(lst2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (remove_lst_elem_count_elem-1 nil 3847887298 ("" (measure-induct "length(lst)" "lst") (("" (skolem 1 "lst") (("" (prop) (("" (skeep) (("" (expand "count_elem" 1 1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "remove" 1) (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (inst -3 "cdr(lst2)") (("1" (split -3) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("list" more_list_theory_props count_elem_nth_gt_TCC1 0 (count_elem_nth_gt_TCC1-1 nil 3847887268 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_gt subtype "(number_fields.-)(more_list_theory_props.n, list_props[more_list_theory_props.T].length(more_list_theory_props.lst))" "below[length[T](remove[T](lst2, lst, equal?))]")))("list" more_list_theory_props count_elem_nth_gt_TCC2 0 (count_elem_nth_gt_TCC2-1 nil 3847887268 ("" (subtype-tcc) nil nil) nil nil (count_elem_nth_gt subtype "more_list_theory_props.n" "below[length[nat](new_coef)]")))("list" list_theory remove_elem_count 0 (remove_elem_count-1 nil 3847975990 ("" (measure-induct "length(lst)" "lst") (("" (skolem 1 "lst") (("" (prop) (("" (skeep) (("" (expand "remove" 2 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (expand "count" 1 2) (("2" (lift-if) (("2" (prop) (("1" (skolem -2 "x1") (("1" (prop) (("1" (rewrite "pos?_mem2") (("1" (inst 4 "x1") (("1" (assert) (("1" (typepred "equal?") (("1" (hide -5 1) (("1" (expand "equivalence?" -1) (("1" (flatten) (("1" (expand "symmetric?" -2) (("1" (inst -2 "x1" "car(lst)") (("1" (assert) (("1" (expand "transitive?" -3) (("1" (inst -3 "x" "car(lst)" "x1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "cdr(lst)") (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "count" 2 1) (("3" (lift-if) (("3" (prop) (("1" (expand "count" 1 2) (("1" (assert) (("1" (inst -2 "cdr(lst)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "count" 2 2) (("2" (lift-if) (("2" (assert) (("2" (inst -1 "cdr(lst)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pos?_mem2 formula-decl nil list_theory nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil nil (= const-decl "[T, T -> boolean]" equalities nil) (pos? def-decl "[bool, nat]" list_theory nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (equiv type-eq-decl nil list_theory nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil list_theory nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("list" list_theory count_elem2_num_dif 0 (count_elem2_num_dif-1 nil 3847978381 ("" (measure-induct "length(lst)" "lst") (("" (skolem 1 "lst") (("" (prop) (("" (skeep) (("" (expand "count_elem2" 1) (("" (lift-if) (("" (assert) (("" (prop) (("1" (grind) nil nil) ("2" (expand "length" 2 1) (("2" (expand "num_dif" 2 1) (("2" (lift-if) (("2" (assert) (("2" (inst -1 "remove(lst, car(lst), equal?)") (("2" (prop) (("1" (grind) nil nil) ("2" (hide 3) (("2" (expand "remove" 1) (("2" (lift-if) (("2" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("list" more_list_theory_props count_elem2_cor1 0 (count_elem2_cor1-1 nil 3847983873 ("" (skeep) (("" (use "count_elem2_cor") (("" (grind) nil nil)) nil)) nil) ((count_elem2_cor formula-decl nil more_list_theory_props nil) (list type-decl nil list_adt nil) (equiv type-eq-decl nil more_list_theory_props nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil more_list_theory_props nil)) shostak))("list" more_list_theory_props count_elem2_mem2 0 (count_elem2_mem2-1 nil 3848174167 ("" (skeep) (("" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil) nil shostak))("equality" equality no_common_args?_TCC1 0 (no_common_args?_TCC1-1 nil 3844432073 ("" (subtype-tcc) nil nil) nil nil (no_common_args? subtype "equality.equal?" "equiv[term[constant, variable, f_symbol, ac_symbol]]")))("equality" equality perm_args_ac_not_pair 0 (perm_args_ac_not_pair-1 nil 3846166846 ("" (skeep) (("" (case "is_ac_sym?(t, f)") (("1" (case "is_ac_sym?(s, f)") (("1" (lemma "perm_args_ac") (("1" (inst -1 "s" "f" "t") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -4) (("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "s") (("2" (assert) (("2" (replace -1) (("2" (lemma "perm?_len") (("2" (inst?) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (case "is_ac_sym?(s, f)") (("1" (lemma "get_args_not_pair_ac") (("1" (inst -1 "f" "t") (("1" (assert) (("1" (lemma "perm?_len") (("1" (inst?) (("1" (assert) (("1" (replace -2 -1) (("1" (rewrite "get_args_len") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "t") (("2" (assert) (("2" (hide -3) (("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "s") (("2" (assert) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "perm?" -1) (("2" (skeep) (("2" (typepred "i" "j") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_ac_sym? const-decl "bool" term_properties nil) (string type-eq-decl nil strings nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (get_args_not_pair_ac formula-decl nil term_properties nil) (perm?_len formula-decl nil equality nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (from_min2max def-decl "list[nat]" list_theory nil) (select def-decl "term" term_properties nil) (perm? def-decl "bool" equality nil) (get_args_len formula-decl nil term_properties nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (args type-eq-decl nil term_properties nil) (list type-decl nil list_adt nil) (perm_args_ac formula-decl nil equality nil) (num_arg def-decl "nat" term_properties nil) (are_ac? const-decl "bool" term_properties nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (delete def-decl "term" term_properties nil) (nth def-decl "T" list_props nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("equality" equality no_pair_ac_count_elem 0 (no_pair_ac_count_elem-1 nil 3849014000 ("" (skeep) (("" (iff) (("" (prop) (("1" (expand "no_pair_ac?" -1) (("1" (expand "no_pair_ac?" 1) (("1" (skeep) (("1" (use "count_elem2_mem2") (("1" (assert) (("1" (skolem -1 "t1") (("1" (prop) (("1" (inst -4 "t1") (("1" (grind) nil nil)) nil) ("2" (inst -4 "t1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "no_pair_ac?" 1) (("2" (skeep) (("2" (expand "no_pair_ac?" -1) (("2" (inst -1 "t") (("2" (assert) (("2" (split -1) (("1" (propax) nil nil) ("2" (use "count_elem2_mem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((count_elem2_mem formula-decl nil more_list_theory_props nil) (no_pair_ac? const-decl "bool" term_properties nil) (equal?_equiv formula-decl nil equality nil) (is_ac_sym? const-decl "bool" term_properties nil) (num_arg def-decl "nat" term_properties nil) (select def-decl "term" term_properties nil) (delete def-decl "term" term_properties nil) (equivalence? const-decl "bool" relations nil) (equal? def-decl "bool" equality nil) (equiv type-eq-decl nil more_list_theory_props nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (args type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" term_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (count_elem2_mem2 formula-decl nil more_list_theory_props nil)) shostak))("aux_unification" aux_unification dio_matrix2ac_mem_len 0 (dio_matrix2ac_mem_len-1 nil 3849022680 ("" (skeep) (("" (assert) (("" (expand "dio_matrix2ac_sol" 1) (("" (use "pareate_len2[term]") (("" (assert) (("" (hide 2) (("" (rewrite "map_length") (("" (rewrite "get_pre_new_args_len") (("" (rewrite "get_repeat_lst_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pareate_len2 formula-decl nil list_theory nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (length def-decl "nat" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (get_pre_new_args def-decl "[list[args], list[variable]]" aux_unification nil) (dio_matrix type-eq-decl nil diophantine nil) (get_ac_from_args_gt1 const-decl "term" aux_unification nil) (string type-eq-decl nil strings nil) (map adt-def-decl "list[T1]" list_adt_map nil) (args type-eq-decl nil term_properties nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (get_pre_new_args_len formula-decl nil aux_unification nil) (get_repeat_lst_len formula-decl nil list_theory nil) (map_length formula-decl nil more_map_props nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil)) shostak))("equality" equality count_vec_count_coef 0 (count_vec_count_coef-1 nil 3849282563 ("" (measure-induct "length(args1)" "args1") (("1" (skolem 1 "args1") (("1" (prop) (("1" (skeep) (("1" (expand "count_coef" 1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "count_vec" 2) (("2" (assert) (("2" (decompose-equality 2) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) nil shostak))("aux_unification" aux_unification get_pre_new_args_nth_TCC1 0 (get_pre_new_args_nth_TCC1-1 nil 3849370298 ("" (subtype-tcc) nil nil) nil nil (get_pre_new_args_nth subtype "aux_unification.i" "below[length[args](get_pre_new_args(lst_args, dio_matrix, vars2avoid)`1)]")))("aux_unification" aux_unification construct_sub_aux_count_TCC1 0 (construct_sub_aux_count_TCC1-1 nil 3849544389 ("" (subtype-tcc) nil nil) nil nil (construct_sub_aux_count subtype "aux_unification.i" "below[length[nat](col)]")))("aux_unification" aux_unification construct_sub_aux_count 0 (construct_sub_aux_count-1 nil 3849544491 ("" (skeep) (("" (expand "count" 2) (("" (use "get_ac_from_args_gt1_get_args2") (("" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (postpone) nil nil)) nil)) nil) ("2" (use "construct_sub_aux_not_null") (("2" (assert) nil nil)) nil) ("3" (expand "no_pair_ac?" 1) (("3" (skeep) (("3" (use "construct_sub_aux_mem") (("3" (assert) (("3" (expand "no_pair_ac?" -5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification countruct_sub_aux_count_TCC1 0 (countruct_sub_aux_count_TCC1-1 nil 3849544804 ("" (subtype-tcc) nil nil) nil nil (countruct_sub_aux_count subtype "aux_unification.i" "below[length[nat](col)]")))("aux_unification" aux_unification countruct_sub_aux_count 0 (countruct_sub_aux_count-1 nil 3849544876 ("" (measure-induct "length(args)" "args") (("1" (skolem 1 "args") (("1" (prop) (("1" (skeep) (("1" (expand "construct_sub_aux" 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "count_append" 3) (("2" (use "get_repeat_lst_count[term]") (("2" (assert) (("2" (hide -2) (("2" (prop) (("1" (replace -2) (("1" (expand "dif_elem?" -5) (("1" (inst -5 "i" "0") (("1" (assert) (("1" (expand "nth" -5 2) (("1" (replace -5) (("1" (expand "nth" 3) (("1" (rewrite "count0_eq" :dir rl) (("1" (skolem -3 "ti") (("1" (prop) (("1" (hide -2 -1) (("1" (use "construct_sub_aux_mem") (("1" (assert) (("1" (rewrite "member_nth2") (("1" (skolem -1 "n") (("1" (reveal -4) (("1" (inst -1 "0" "n+1") (("1" (expand "nth" -1) (("1" (assert) (("1" (typepred "n") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (expand "nth" 4 1) (("2" (lift-if) (("2" (prop) (("1" (replace -1) (("1" (expand "nth" 2) (("1" (use "equal?_ref") nil nil)) nil)) nil) ("2" (hide 3) (("2" (expand "nth" 2 2) (("2" (lift-if) (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "cdr(args)") (("2" (prop) (("1" (inst -1 "cdr(col)" "i-1") (("1" (assert) (("1" (hide 3) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "length" -2) (("1" (assert) (("1" (hide -1 -2) (("1" (expand "dif_elem?" 1) (("1" (skolem 1 ("n1" "n2")) (("1" (expand "dif_elem?" -1) (("1" (inst -1 "n1 + 1" "n2+1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (use "equal?_equiv") nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (use "equal?_equiv") nil nil)) nil)) nil)) nil) ((equal?_equiv formula-decl nil equality nil) (get_repeat_lst_count formula-decl nil list_theory nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (equal?_ref formula-decl nil equality nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (member_nth2 formula-decl nil list_theory nil) (construct_sub_aux_mem formula-decl nil aux_unification nil) (count0_eq formula-decl nil list_theory nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (count_append formula-decl nil list_theory nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (construct_sub_aux def-decl "args" aux_unification nil) (nth def-decl "T" list_props nil) nil (equiv type-eq-decl nil list_theory nil) nil (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (equivalence? const-decl "bool" relations nil) nil (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (args type-eq-decl nil term_properties nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("equality" equality remove_common_get_args 0 (remove_common_get_args-1 nil 3849797545 ("" (skeep) (("" (assert) (("" (name-replace "t1" "remove_common(t, s, f)`1") (("" (name-replace "s1" "remove_common(t, s, f)`2") (("" (lemma "remove_common_no_common") (("" (inst -1 "get_args(f)(t1)" "get_args(f)(s1)") (("" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (expand "t1" 2) (("1" (expand "remove_common" 2 1) (("1" (use "get_args_get_ac_from_args2") (("1" (assert) (("1" (hide 3) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution equal_subs_remove_common 0 (equal_subs_remove_common-1 nil 3849804094 ("" (skeep) (("" (assert) (("" (prop) (("" (name-replace "t1" "remove_common(t, s, f)`1") (("" (name-replace "s1" "remove_common(t, s, f)`2") (("" (lemma "perm_args_ac") (("" (inst -1 "subs(delta)(s1)" "f" "subs(delta)(t1)") (("" (assert) (("" (hide 2) (("" (prop) (("1" (lemma "ac_perm_args2") (("1" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("1" (assert) (("1" (hide -2) (("1" (use "args_subs_ac") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "subs_map") (("1" (use "args_subs_ac") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "subs_map") (("1" (use "args_subs_ac") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "subs_map") (("1" (expand "t1" 1) (("1" (expand "remove_common" 1) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("unification" unification remove_common_well_formed 0 (remove_common_well_formed-1 nil 3849879867 ("" (skeep) (("" (assert) (("" (prop) (("" (expand "well_formed?" 2) (("" (skolem 2 "t2") (("" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification solve_ac_unify_complete_no_com 0 (solve_ac_unify_complete_no_com-5 nil 3849966590 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                                                          member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                                                           is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (postpone) nil nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (solve_ac_unify_complete_no_com-4 nil 3849966416 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                                             member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                                              is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (postpone) nil nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -3 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (solve_ac_unify_complete_no_com-3 nil 3849965962 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                                member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                                 is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (postpone) nil nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -3 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (solve_ac_unify_complete_no_com-2 nil 3849965225 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                   member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                    is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (expand "args_delta_t" 1) (("1" (rewrite "well_formed_args" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "subs(delta)(t)") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "well_formed_subs") (("2" (assert) (("2" (reveal -35) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -1 "t") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -3 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (solve_ac_unify_complete_no_com-1 nil 3849964868 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                      member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                       is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "well_formed_append") (("4" (assert) (("4" (lemma "construct_sub_well_formed") (("4" (inst?) (("4" (assert) (("4" (hide 2 3) (("4" (prop) (("1" (expand "args_delta_t" 1) (("1" (use "well_formed_count_elem2") (("1" (assert) (("1" (hide 2) (("1" (use "well_formed_get_args") (("1" (assert) (("1" (hide 2) (("1" (use "well_formed_subs") (("1" (assert) (("1" (reveal -29) (("1" (hide-all-but (-1 1)) (("1" (expand "well_formed?" 1) (("1" (expand "well_formed?" -1) (("1" (prop) (("1" (inst -2 "t") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 "t_1") (("2" (assert) (("2" (expand "subterms" 2) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (expand "subterms" 2) (("2" (expand ("member" "union") 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -6 -16) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (assert) (("2" (expand "l" -8) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (expand "args_delta_t" 1) (("1" (rewrite "well_formed_args" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "subs(delta)(t)") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "well_formed_subs") (("2" (assert) (("2" (reveal -35) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -1 "t") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (hide -2) (("1" (lemma "well_formed_get_args") (("1" (inst -1 "f" "t") (("1" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -2 "t") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (lemma "well_formed_get_args") (("2" (inst -1 "f" "s") (("2" (prop) (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -3 "s") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ac_perm_args2 formula-decl nil equality nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (equivalence? const-decl "bool" relations nil) (equiv type-eq-decl nil list_theory nil) (count_elem2 def-decl "[list[T], list[nat]]" list_theory nil) (args type-eq-decl nil term_properties nil) (count_elem_tcc_solver formula-decl nil list_theory nil) (append def-decl "list[T]" list_props nil) (subs def-decl "args" substitution nil) (count_vec def-decl "list[nat]" equality nil) (dio_matrix type-eq-decl nil diophantine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (is_solution? const-decl "bool" diophantine nil) (count_eq formula-decl nil list_theory nil) (empty_col_get_repeat_lst formula-decl nil aux_unification nil) (dot_product_get_repeat_lst02 formula-decl nil diophantine nil) (nth_append formula-decl nil list_theory nil) (perm?_ref formula-decl nil equality nil) (get_args_mem_select1 formula-decl nil term_properties nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (count_mem formula-decl nil list_theory nil) (select def-decl "term" term_properties nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (unifies? def-decl "bool" unification nil) (well_formed_append formula-decl nil substitution nil) (construct_sub_well_formed formula-decl nil aux_unification nil) (well_formed_count_elem2 formula-decl nil equality nil) (well_formed_subs formula-decl nil substitution nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (well_formed? const-decl "bool" unification nil) (well_formed_get_args formula-decl nil term_properties nil) (construct_submatrix_coef_len formula-decl nil diophantine nil) (construct_submatrix_no_zero_col formula-decl nil diophantine nil) (construct_sub_vars_img formula-decl nil aux_unification nil) (vars_count_elem2 formula-decl nil equality nil) (vars_subs_t formula-decl nil substitution nil) (vars const-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (vars_get_args formula-decl nil term_properties nil) (subset? const-decl "bool" sets nil) (supset_dom_correct2 formula-decl nil substitution nil) (member const-decl "bool" sets nil) (dio_matrix2ac_new_vars formula-decl nil aux_unification nil) (select_greater_lt formula-decl nil list_theory nil) (from_min2max_mem2 formula-decl nil list_theory nil) (difference const-decl "set" sets nil) (mem_list2set formula-decl nil list_theory nil) (from_min2max def-decl "list[nat]" list_theory nil) (select_greater def-decl "nat" list_theory nil) (construct_sub_mem_dom formula-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (elim_com_arg_no_common_arg formula-decl nil aux_unification nil) (empty_col? const-decl "bool" aux_unification nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (matrix? const-decl "bool" list_theory nil) (matrix_row_len formula-decl nil list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nice_submatrix? const-decl "bool" aux_unification nil) (length_append formula-decl nil list_props nil) (count_elem2_same_len formula-decl nil more_list_theory_props nil) (equiv type-eq-decl nil more_list_theory_props nil) (count_elem2_cor formula-decl nil more_list_theory_props nil) (get_args_len formula-decl nil term_properties nil) (num_arg_ge1 formula-decl nil term_properties nil) (count_elem_len formula-decl nil list_theory nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (count_elem_len_gt0 formula-decl nil list_theory nil) (construct_submatrix_matrix2 formula-decl nil diophantine nil) (dio_solver_matrix formula-decl nil diophantine nil) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (dio_matrix2ac_is_var_sum formula-decl nil aux_unification nil) (sec_proj_mem formula-decl nil list_theory2 nil) (rhs const-decl "args" unification nil) (unifies?_equiv formula-decl nil unification nil) (dio_matrix2ac_mem_lhs_nth formula-decl nil aux_unification nil) (equal?_sym formula-decl nil equality nil) (term_ac_app_eta formula-decl nil term_adt nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (subs_ac formula-decl nil substitution nil) (subs_ac3 formula-decl nil substitution nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (dio_matrix2ac_len formula-decl nil aux_unification nil) (member_nth formula-decl nil list_theory nil) (dio_matrix2ac_mem_rhs formula-decl nil aux_unification nil) (get_col_i def-decl "list[T]" list_theory nil) (const2_sum formula-decl nil aux_unification nil) (member_nth2 formula-decl nil list_theory nil) (count_elem2_mem formula-decl nil more_list_theory_props nil) (get_args_mem_not_ac formula-decl nil term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member_append formula-decl nil list_theory nil) (is_ac_sym? const-decl "bool" term_properties nil) (if_non_var_const2_cor2 formula-decl nil aux_unification nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (construct_submatrix_get_sublists formula-decl nil diophantine nil) (extract_submatrices_mem formula-decl nil aux_unification nil) (map_member4 formula-decl nil map_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (subs_append2 formula-decl nil substitution nil) (perm_args_ac_well_formed formula-decl nil equality nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (subs_len formula-decl nil substitution nil) (construct_submatrix_linear_comb formula-decl nil diophantine nil) (matrix? def-decl "bool" list_theory nil) (count_subs_subset formula-decl nil substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (var_lst def-decl "list[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) (dio_matrix2ac_count_coef formula-decl nil aux_unification nil) (construct_sub_count_nth formula-decl nil aux_unification nil) (dot_product_sym formula-decl nil list_theory nil) (count_elem2_dif_elem formula-decl nil more_list_theory_props nil) (get_args_no_pair_ac formula-decl nil term_properties nil) (no_pair_ac_count_elem2 formula-decl nil equality nil) (int_minus_int_is_int application-judgement "int" integers nil) (count_coef1 formula-decl nil list_theory nil) (subset_lst? const-decl "bool" list_theory nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (var_lst_mem formula-decl nil term_properties nil) (dio_matrix2ac_mem_rhs_get_args formula-decl nil aux_unification nil) (dif_elem_from_min2max formula-decl nil more_list_theory_props nil) (var_lst_dif_elem formula-decl nil equality nil) (NOT const-decl "[bool -> bool]" booleans nil) (construct_submatrix_matrix formula-decl nil diophantine nil) (matrix_nth formula-decl nil list_theory nil) (get_linear_comb_nth formula-decl nil diophantine nil) (subs_map formula-decl nil substitution nil) (count_vec_nth formula-decl nil equality nil) (count_eq3 formula-decl nil equality nil) (count_elem2_mem2 formula-decl nil more_list_theory_props nil) (equal?_trans formula-decl nil equality nil) (member_ac const-decl "bool" equality nil) (equal?_ref formula-decl nil equality nil) (member_ac_count_elem2 formula-decl nil equality nil) (mem_get_args_subs4 formula-decl nil substitution nil) (first_proj_mem formula-decl nil list_theory2 nil) (lhs const-decl "args" unification nil) (dio_matrix2ac_mem_lhs formula-decl nil aux_unification nil) (construct_sub_mem_get_args_dio_matrix2ac_sol formula-decl nil aux_unification nil) (count0_eq formula-decl nil list_theory nil) (perm?_equiv_same_count? formula-decl nil equality nil) (dio_matrix2ac_mem_rhs_well_formed formula-decl nil aux_unification nil) (well_formed_unif_prb formula-decl nil unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (well_formed_args formula-decl nil term_properties nil) (subs_no_effect_t formula-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (dio_matrix2ac_mem_var_rhs formula-decl nil aux_unification nil) (empty? const-decl "bool" sets nil) (vars_args formula-decl nil term_properties nil) (construct_sub_mem_dom_cor formula-decl nil aux_unification nil) (construct_sub def-decl "sub" aux_unification nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (const1? const-decl "bool" aux_unification nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (ac_sol type-eq-decl nil aux_unification nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (construct_submatrix def-decl "[dio_matrix, dio_matrix]" diophantine nil) (map_length formula-decl nil more_map_props nil) (length def-decl "nat" list_props nil) (count_vec_append formula-decl nil equality nil) (count_subs_count_elem formula-decl nil substitution nil) (equal?_equiv formula-decl nil equality nil) (split_append formula-decl nil list_theory nil) (count_vec_len formula-decl nil equality nil) (subs_append formula-decl nil substitution nil) (dio_solver def-decl "dio_matrix" diophantine nil) (dio_solver_coef_matrix formula-decl nil diophantine nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (calculate_upper_bound const-decl "nat" diophantine nil) (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (f_symbol type-eq-decl nil term_properties nil) (number nonempty-type-decl nil numbers nil) (ac_symbol type-eq-decl nil term_properties nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (unifies? const-decl "bool" unification nil)) nil))("aux_unification" aux_unification solve_ac_unify_complete_no_com1 0 (solve_ac_unify_complete_no_com1-1 nil 3849966757 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                                                                       member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                                                                        is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "well_formed_append") (("4" (assert) (("4" (lemma "construct_sub_well_formed") (("4" (inst?) (("4" (assert) (("4" (hide 2 3) (("4" (prop) (("1" (expand "args_delta_t" 1) (("1" (use "well_formed_count_elem2") (("1" (assert) (("1" (hide 2) (("1" (use "alm_well_formed_get_args") (("1" (assert) (("1" (prop) (("1" (use "alm_well_formed_subs") (("1" (assert) (("1" (reveal -29) (("1" (expand "alm_well_formed?" -1) (("1" (inst -1 "t") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -12) (("2" (hide-all-but (-1 1)) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (use "term_ac_app_eta") (("2" (use "subs_ac") (("2" (replace -4 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -6 -16) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (assert) (("2" (expand "l" -8) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (expand "args_delta_t" 1) (("1" (use "well_formed_count_elem2") (("1" (assert) (("1" (hide 2) (("1" (use "alm_well_formed_get_args") (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (use "alm_well_formed_subs") (("1" (assert) (("1" (reveal -35) (("1" (expand "alm_well_formed?" -1) (("1" (inst -1 "t") (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -18) (("2" (hide-all-but (-1 1)) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (use "term_ac_app_eta") (("2" (replace -3 :dir rl) (("2" (use "subs_ac") (("2" (replace -2 1 :dir rl) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (case "well_formed?(args_t)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (hide 2 3) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (reveal -35) (("2" (expand "alm_well_formed?" -1) (("2" (inst -1 "t") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "well_formed?(args_s)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "s") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (case "well_formed?(args_t)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "t") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "well_formed?(args_s)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "s") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ac_perm_args2 formula-decl nil equality nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) nil (equivalence? const-decl "bool" relations nil) (equiv type-eq-decl nil list_theory nil) (count_elem2 def-decl "[list[T], list[nat]]" list_theory nil) (args type-eq-decl nil term_properties nil) nil nil (count_elem_tcc_solver formula-decl nil list_theory nil) (append def-decl "list[T]" list_props nil) (subs def-decl "args" substitution nil) (count_vec def-decl "list[nat]" equality nil) nil (dio_matrix type-eq-decl nil diophantine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (is_solution? const-decl "bool" diophantine nil) (count_eq formula-decl nil list_theory nil) (empty_col_get_repeat_lst formula-decl nil aux_unification nil) (dot_product_get_repeat_lst02 formula-decl nil diophantine nil) nil (nth_append formula-decl nil list_theory nil) (perm?_ref formula-decl nil equality nil) (get_args_mem_select1 formula-decl nil term_properties nil) nil (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (count_mem formula-decl nil list_theory nil) (select def-decl "term" term_properties nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (unifies? def-decl "bool" unification nil) (well_formed_append formula-decl nil substitution nil) (construct_sub_well_formed formula-decl nil aux_unification nil) (well_formed_count_elem2 formula-decl nil equality nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (alm_well_formed_subs formula-decl nil substitution nil) nil (alm_well_formed? const-decl "bool" unification nil) (alm_well_formed_get_args formula-decl nil term_properties nil) nil nil (construct_submatrix_coef_len formula-decl nil diophantine nil) (construct_submatrix_no_zero_col formula-decl nil diophantine nil) (construct_sub_vars_img formula-decl nil aux_unification nil) (vars_count_elem2 formula-decl nil equality nil) (vars_subs_t formula-decl nil substitution nil) (vars const-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (vars_get_args formula-decl nil term_properties nil) nil (subset? const-decl "bool" sets nil) (supset_dom_correct2 formula-decl nil substitution nil) (member const-decl "bool" sets nil) nil (dio_matrix2ac_new_vars formula-decl nil aux_unification nil) nil (select_greater_lt formula-decl nil list_theory nil) (from_min2max_mem2 formula-decl nil list_theory nil) (difference const-decl "set" sets nil) (mem_list2set formula-decl nil list_theory nil) (from_min2max def-decl "list[nat]" list_theory nil) (select_greater def-decl "nat" list_theory nil) (construct_sub_mem_dom formula-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (elim_com_arg_no_common_arg formula-decl nil aux_unification nil) (empty_col? const-decl "bool" aux_unification nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (matrix? const-decl "bool" list_theory nil) (matrix_row_len formula-decl nil list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nice_submatrix? const-decl "bool" aux_unification nil) (length_append formula-decl nil list_props nil) nil (count_elem2_same_len formula-decl nil more_list_theory_props nil) nil (equiv type-eq-decl nil more_list_theory_props nil) (count_elem2_cor formula-decl nil more_list_theory_props nil) (get_args_len formula-decl nil term_properties nil) (num_arg_ge1 formula-decl nil term_properties nil) (count_elem_len formula-decl nil list_theory nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (count_elem_len_gt0 formula-decl nil list_theory nil) nil nil (construct_submatrix_matrix2 formula-decl nil diophantine nil) nil (dio_solver_matrix formula-decl nil diophantine nil) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (dio_matrix2ac_is_var_sum formula-decl nil aux_unification nil) nil (sec_proj_mem formula-decl nil list_theory2 nil) (rhs const-decl "args" unification nil) (unifies?_equiv formula-decl nil unification nil) (dio_matrix2ac_mem_lhs_nth formula-decl nil aux_unification nil) (equal?_sym formula-decl nil equality nil) (term_ac_app_eta formula-decl nil term_adt nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (subs_ac formula-decl nil substitution nil) (subs_ac3 formula-decl nil substitution nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (dio_matrix2ac_len formula-decl nil aux_unification nil) (member_nth formula-decl nil list_theory nil) nil (dio_matrix2ac_mem_rhs formula-decl nil aux_unification nil) (get_col_i def-decl "list[T]" list_theory nil) (const2_sum formula-decl nil aux_unification nil) nil nil (member_nth2 formula-decl nil list_theory nil) nil (count_elem2_mem formula-decl nil more_list_theory_props nil) (get_args_mem_not_ac formula-decl nil term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) nil nil (member_append formula-decl nil list_theory nil) (is_ac_sym? const-decl "bool" term_properties nil) (if_non_var_const2_cor2 formula-decl nil aux_unification nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil (construct_submatrix_get_sublists formula-decl nil diophantine nil) (extract_submatrices_mem formula-decl nil aux_unification nil) (map_member4 formula-decl nil map_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (subs_append2 formula-decl nil substitution nil) (perm_args_ac_well_formed formula-decl nil equality nil) nil nil nil (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (subs_len formula-decl nil substitution nil) nil (construct_submatrix_linear_comb formula-decl nil diophantine nil) (matrix? def-decl "bool" list_theory nil) (count_subs_subset formula-decl nil substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (var_lst def-decl "list[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) (dio_matrix2ac_count_coef formula-decl nil aux_unification nil) nil (construct_sub_count_nth formula-decl nil aux_unification nil) nil (dot_product_sym formula-decl nil list_theory nil) (count_elem2_dif_elem formula-decl nil more_list_theory_props nil) (get_args_no_pair_ac formula-decl nil term_properties nil) (no_pair_ac_count_elem2 formula-decl nil equality nil) nil (int_minus_int_is_int application-judgement "int" integers nil) (count_coef1 formula-decl nil list_theory nil) (subset_lst? const-decl "bool" list_theory nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (var_lst_mem formula-decl nil term_properties nil) (dio_matrix2ac_mem_rhs_get_args formula-decl nil aux_unification nil) (dif_elem_from_min2max formula-decl nil more_list_theory_props nil) (var_lst_dif_elem formula-decl nil equality nil) (NOT const-decl "[bool -> bool]" booleans nil) nil (construct_submatrix_matrix formula-decl nil diophantine nil) (matrix_nth formula-decl nil list_theory nil) (get_linear_comb_nth formula-decl nil diophantine nil) (subs_map formula-decl nil substitution nil) (count_vec_nth formula-decl nil equality nil) (count_eq3 formula-decl nil equality nil) (count_elem2_mem2 formula-decl nil more_list_theory_props nil) (equal?_trans formula-decl nil equality nil) (member_ac const-decl "bool" equality nil) (equal?_ref formula-decl nil equality nil) (member_ac_count_elem2 formula-decl nil equality nil) (mem_get_args_subs4 formula-decl nil substitution nil) (first_proj_mem formula-decl nil list_theory2 nil) nil (lhs const-decl "args" unification nil) (dio_matrix2ac_mem_lhs formula-decl nil aux_unification nil) (construct_sub_mem_get_args_dio_matrix2ac_sol formula-decl nil aux_unification nil) (count0_eq formula-decl nil list_theory nil) nil (perm?_equiv_same_count? formula-decl nil equality nil) (well_formed_subs formula-decl nil substitution nil) (dio_matrix2ac_mem_rhs_well_formed formula-decl nil aux_unification nil) nil (well_formed_args formula-decl nil term_properties nil) (subs_no_effect_t formula-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (dio_matrix2ac_mem_var_rhs formula-decl nil aux_unification nil) (empty? const-decl "bool" sets nil) (vars_args formula-decl nil term_properties nil) nil (construct_sub_mem_dom_cor formula-decl nil aux_unification nil) (construct_sub def-decl "sub" aux_unification nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (const1? const-decl "bool" aux_unification nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (ac_sol type-eq-decl nil aux_unification nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (construct_submatrix def-decl "[dio_matrix, dio_matrix]" diophantine nil) (map_length formula-decl nil more_map_props nil) (length def-decl "nat" list_props nil) (count_vec_append formula-decl nil equality nil) (count_subs_count_elem formula-decl nil substitution nil) (equal?_equiv formula-decl nil equality nil) (split_append formula-decl nil list_theory nil) (count_vec_len formula-decl nil equality nil) (subs_append formula-decl nil substitution nil) (dio_solver def-decl "dio_matrix" diophantine nil) (dio_solver_coef_matrix formula-decl nil diophantine nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (calculate_upper_bound const-decl "nat" diophantine nil) nil (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (f_symbol type-eq-decl nil term_properties nil) (number nonempty-type-decl nil numbers nil) (ac_symbol type-eq-decl nil term_properties nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (unifies? const-decl "bool" unification nil)) nil))("apply_ac_step" apply_ac_step apply_ac_sigma_null 0 (apply_ac_sigma_null-1 nil 3850057684 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 ("unseen_unif_prb")) (("" (prop) (("" (skeep) (("" (hide -1) (("" (prop) (("1" (expand "apply_ac_step" -1 1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (inst 1 "(seen_unif_prb, null, vars2avoid)") (("1" (assert) (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (skolem -1 "ac_sol1") (("1" (flatten) (("1" (inst 2 "ac_sol1") (("1" (assert) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (flatten) (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input") (("2" (prop) (("2" (hide -3) (("2" (expand "input_lst") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (hide -1 -2 -3 -4 -5) (("2" (reveal -18) (("2" (inst -1 "input`1") (("2" (prop) (("1" (hide -2) (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`4") (("1" (assert) (("1" (skeep) (("1" (inst 3 "(ac_sol1`1, append(ac_sol1`2, delta), ac_sol1`3)") (("1" (assert) (("1" (reveal -6) (("1" (replace -1) (("1" (rewrite "append_assoc") (("1" (assert) (("1" (hide -1) (("1" (expand "apply_ac_step" 3) (("1" (reveal -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (replace -9 3) (("1" (hide -9) (("1" (replace -8) (("1" (hide -8) (("1" (replace -7) (("1" (hide -7) (("1" (replace -6) (("1" (hide -6) (("1" (replace -5) (("1" (hide -5) (("1" (replace -4) (("1" (hide -4) (("1" (replace -3) (("1" (hide -3) (("1" (replace -2) (("1" (hide -2) (("1" (lift-if) (("1" (assert) (("1" (split 3) (("1" (flatten) (("1" (assert) (("1" (reveal 2) (("1" (expand ("t" "s") -1) (("1" (expand "unif_pair" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (assert) (("2" (name-replace "input_lst2" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (hide 4) (("2" (reveal -1) (("2" (reveal -3) (("2" (hide -3) (("2" (lemma "input_apply_ac_step_sigma_null") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input2") (("2" (replace -3) (("2" (inst 1 "input2") (("2" (flatten) (("2" (assert) (("2" (reveal -22) (("2" (hide -7 -8 -14) (("2" (hide -2) (("2" (inst -1 "input2`1") (("2" (prop) (("1" (inst -1 "(ac_sol1`1, append(ac_sol1`2, delta), ac_sol1`3)" "input2`2" "input2`3" "input2`4") (("1" (assert) (("1" (hide 2) (("1" (inst 1 "ac_sol1") (("1" (assert) (("1" (reveal -11) (("1" (replace -1 -4) (("1" (case "delta = input2`3") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (grind) (("2" (lemma "equal_append_implies_equal[basic_sub]") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 :dir rl) (("2" (reveal -8) (("2" (replace -1 1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "apply_ac_step" -1 1) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (prop) (("1" (assert) (("1" (decompose-equality 1) (("1" (replace -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (assert) (("1" (prop) (("1" (expand "apply_ac_step" 2) (("1" (inst -1 "ac_sol" "_" "_" "_") (("1" (inst?) (("1" (assert) (("1" (inst 1 "ac_sol1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst" -1) (("2" (hide -3) (("2" (hide -3) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (hide -1 -2 -3 -4 -5) (("2" (reveal -19) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol1" "input`2" "input`3" "input`4") (("1" (assert) (("1" (skolem -1 "ac_sol2") (("1" (flatten) (("1" (hide -7 -8 -9) (("1" (expand "apply_ac_step" 3) (("1" (reveal -15 -16 -17 -18 -19 -20 -21 -22) (("1" (replace -8) (("1" (hide -8) (("1" (replace -7) (("1" (hide -7) (("1" (replace -6) (("1" (hide -6) (("1" (replace -5) (("1" (hide -5) (("1" (replace -4) (("1" (hide -4) (("1" (replace -3) (("1" (hide -3) (("1" (replace -2) (("1" (hide -2) (("1" (lift-if) (("1" (split 3) (("1" (flatten) (("1" (reveal 1) (("1" (expand ("t" "s" "unif_pair")) (("1" (expand "unif_pair") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (name-replace "input_lst2" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (hide 4) (("2" (expand "input_lst2") (("2" (inst 1 "(input`1, input`2, append(input`3, sigma), input`4)") (("2" (prop) (("1" (lemma "input_apply_ac_step_sigma_null") (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (inst 1 "input") nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -24) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol" "input`2" "append(input`3, sigma)" "input`4") (("1" (assert) (("1" (hide 2) (("1" (inst 1 "ac_sol2") (("1" (assert) (("1" (reveal -3) (("1" (replace -1) (("1" (replace -4) (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (append_assoc formula-decl nil list_props nil) (apply_sub_len formula-decl nil unification nil) (equal_append_implies_equal formula-decl nil list_theory nil) (input_apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) nil nil nil nil (mem_flatten_map2 formula-decl nil map_theory nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (union const-decl "set" sets nil) nil (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) nil nil nil nil nil (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("apply_ac_step" apply_ac_step apply_ac_sub 0 (apply_ac_sub-2 nil 3850059924 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (hide-all-but (-1 -5)) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (hide-all-but -2) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide 1 -2) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input1") (("2" (prop) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (reveal -12) (("2" (rewrite "append_null") (("2" (hide -1) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input1`2" "sigma" "input1`1" "input1`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (prop) (("2" (hide -2 -3 -4 -11 -10) (("2" (reveal -18) (("2" (inst -1 "input1`1") (("2" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (hide-all-but (1 -8)) (("1" (reveal -11) (("1" (replace -1) (("1" (hide -1) (("1" (case "member(variable(X), sec_proj(sigma))") (("1" (hide -2 1) (("1" (reveal -3 -20 -22 3 -8) (("1" (replace -3 :dir rl) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (prop) (("1" (hide 1) (("1" (hide -4 -6) (("1" (replace -5 :dir rl) (("1" (hide -5) (("1" (lemma "instantiate_step_sec_proj") (("1" (inst -1 "X" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (hide -3 -4 -6) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_mem_lhs") (("1" (inst?) (("1" (inst -1 "variable(X)") (("1" (assert) (("1" (hide -2 -3 -4) (("1" (reveal -35 -36 -37) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide 3) (("1" (prop) (("1" (replace -4) (("1" (replace -3) (("1" (lemma "vars_get_args") (("1" (inst -1 "ac_sym(t)" "t") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args") (("1" (inst 1 "variable(X)") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (replace -2) (("2" (lemma "vars_get_args") (("2" (inst -1 "ac_sym(t)" "s") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (rewrite "vars_args") (("2" (inst 2 "variable(X)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_rhs") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sec_proj_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (replace -2) (("2" (hide -2 -3 -4 -5) (("2" (hide -3) (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1s") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst -1 "sigma" "t1s") (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (hide -2 -3 -4) (("1" (reveal -12 -24 -26) (("1" (replace -2 :dir rl) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (prop) (("1" (replace -6 -1 :dir rl) (("1" (replace -3 -7) (("1" (hide -1 -2 -3 -4 -5 -6 1) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide -2) (("1" (rewrite "vars_unif_prb" -1) (("1" (skolem -1 "t2") (("1" (prop) (("1" (reveal -4) (("1" (lemma "solve_ac_vars_vars2avoid") (("1" (inst?) (("1" (inst -1 "X" "t2") (("1" (assert) (("1" (prop) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_no_pair") (("2" (inst?) (("2" (assert) (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "subterm_reflexive") (("2" (expand "no_pair?" -2) (("2" (inst -2 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -3) (("3" (reveal -40 -41 -42) (("3" (expand "vars" 2) (("3" (expand ("member" "union") 2) (("3" (prop) (("3" (replace -3) (("3" (expand "vars" 2) (("3" (expand ("member" "union") 2) (("3" (flatten) (("3" (lemma "vars_subterm") (("3" (replace -2) (("3" (replace -3) (("3" (expand "member" -5) (("3" (expand "subterms" -5) (("3" (expand "union" -5) (("3" (prop) (("1" (inst -2 "X" "t2" "t") (("1" (assert) nil nil)) nil) ("2" (inst -2 "X" "t2" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5) (("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1s") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -6) (("3" (hide-all-but (-7 1)) (("3" (expand "new_vars2avoid") (("3" (case "NOT null?(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (lemma "solve_ac_sec_proj_vars") (("1" (inst?) (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (rewrite "mem_lst2set") (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2 -19 -21) (("2" (expand "first_proj" -3) (("2" (assert) (("2" (replace -3 :dir rl) (("2" (expand "instantiate_step" -2) (("2" (replace -2 :dir rl) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (expand "all_ac_prb?" -1) (("2" (expand "t" 1) (("2" (expand "unif_pair" 1) (("2" (inst -1 "car(unseen_unif_prb)") (("2" (expand "ac_prb?" -1) (("2" (assert) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "all_ac_prb?" -1) (("2" (expand "t") (("2" (expand "unif_pair") (("2" (inst -1 "car(unseen_unif_prb)") (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) nil nil (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (append_null formula-decl nil list_props nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (sec_proj_append formula-decl nil list_theory2 nil) (instantiate_step_sec_proj formula-decl nil aux_unification nil) nil (args type-eq-decl nil term_properties nil) (vars_args formula-decl nil term_properties nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) nil (vars_get_args formula-decl nil term_properties nil) (solve_ac_mem_lhs formula-decl nil aux_unification nil) (finset2list_mem formula-decl nil list_theory nil) nil nil (solve_ac_vars_rhs formula-decl nil aux_unification nil) (member_lhs_rhs formula-decl nil unification nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (vars_subterm formula-decl nil term_properties nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (subterm_reflexive formula-decl nil term_properties nil) (no_pair? const-decl "bool" unification nil) (subterms_mem_unif_prb formula-decl nil unification nil) (solve_ac_vars_vars2avoid formula-decl nil aux_unification nil) nil (vars_unif_prb formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (mem_lst2set formula-decl nil list_theory nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) nil (apply_sub_len formula-decl nil unification nil) nil (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) nil nil (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars const-decl "finite_set[variable]" unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (union const-decl "set" sets nil) (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil)) nil) (apply_ac_sub-1 nil 3850059681 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (hide-all-but (-1 -5)) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_vars 0 (apply_ac_vars-3 nil 3850060522 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1) (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -5 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (hide-all-but -2) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide 1 -2) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input1") (("2" (prop) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (reveal -12) (("2" (rewrite "append_null") (("2" (hide -1) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input1`2" "sigma" "input1`1" "input1`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (prop) (("2" (hide -2 -3 -4 -11 -10) (("2" (reveal -18) (("2" (inst -1 "input1`1") (("2" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (hide-all-but (1 -8)) (("1" (reveal -10) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -12) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (replace -2 :dir rl) (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (flatten) (("2" (hide 1) (("2" (rewrite "vars_unif_prb") (("2" (skolem -5 "t1") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (replace -9 -5) (("2" (replace -10 -5) (("2" (hide -9 -10 -11 -12) (("2" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t1p") (("1" (prop) (("1" (replace -2) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (lemma "instantiate_step_vars_img") (("1" (replace -7 -2) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide -2) (("1" (reveal -25) (("1" (replace -1 -5 :dir rl) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (reveal -30 -31 -32) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand ("member" "union") 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "member(X, vars(img(sigma)))") (("1" (replace -5 -1) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (reveal -22) (("1" (replace -1 -5 :dir rl) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (prop) (("1" (reveal -27 -28 -29) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (lemma "instantiate_step1_mem") (("1" (replace -4 -2) (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (replace -6 :dir rl) (("1" (replace -2 -8) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (reveal -23) (("1" (replace -1 -6 :dir rl) (("1" (hide -1) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (expand "append" 4) (("1" (expand "vars" 4) (("1" (expand ("member" "union") 4) (("1" (prop) (("1" (reveal -28 -29 -30) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (inst 1 "t1p") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2 -7) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (rewrite "vars_unif_prb") (("2" (inst 3 "t1p") (("2" (prop) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -6) (("3" (expand "new_vars2avoid" 1) (("3" (lemma "solve_ac_sec_proj_vars") (("3" (inst?) (("3" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -13 -15) (("2" (replace -1 -5 :dir rl) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (replace -5 -1 :dir rl) (("2" (expand "first_proj" -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "t" 1) (("2" (expand "unif_pair" 1) (("2" (expand "all_ac_prb?" -2) (("2" (inst -2 "car(unseen_unif_prb)") (("2" (expand "member" -2) (("2" (assert) (("2" (expand "ac_prb?" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "t") (("2" (expand "unif_pair") (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(unseen_unif_prb)") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "ac_prb?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (vars def-decl "finite_set[variable]" unification nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (append_null formula-decl nil list_props nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (vars def-decl "finite_set[variable]" term_properties nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (lst_vars2avoid skolem-const-decl "list[nat]" apply_ac_step nil) (cur_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (finset2list_mem formula-decl nil list_theory nil) (solve_ac_vars formula-decl nil aux_unification nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (member def-decl "bool" unification nil) (new_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (mem_list2set formula-decl nil list_theory nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (input_lst skolem-const-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (unif_pair skolem-const-decl "unif_pair" apply_ac_step nil) (t skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" apply_ac_step nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars const-decl "finite_set[variable]" unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (union const-decl "set" sets nil) (member_unif_prb_append formula-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil) (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil)) nil) (apply_ac_vars-2 nil 3850060342 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1) (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -5 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (apply_ac_vars-1 nil 3850060092 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1) (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -5 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_sub_vars_img 0 (apply_ac_sub_vars_img-2 nil 3850061135 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (expand "sigma_0n") (("1" (propax) nil nil)) nil) ("2" (expand "vars" 2 1) (("2" (expand ("member" "union") 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (rewrite "append_null") (("2" (lemma "apply_ac_step_sigma_null") (("2" (hide -3 -4 -5 -6) (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (hide -4) (("2" (prop) (("2" (hide -6) (("2" (reveal -6) (("2" (replace -1) (("2" (name-replace "sigma_1n" "ac_sol1`2") (("2" (reveal -11 -13) (("2" (replace -1 -8 :dir rl) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (replace -5 -1 :dir rl) (("2" (hide -2 -3 -4 -5 1) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (reveal -28) (("2" (replace -1) (("2" (replace -2) (("2" (lemma "vars_img_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (hide -5) (("2" (expand "member" -1) (("2" (expand "union" -1) (("2" (prop) (("1" (reveal -32) (("1" (expand "sigma_1n" -2) (("1" (reveal -5) (("1" (inst -2 "input`1") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (reveal -19) (("1" (hide 1 -5 -6) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (replace -1 -2) (("1" (rewrite "apply_sub_mem") (("1" (skolem -2 "t1_p") (("1" (prop) (("1" (replace -3 -4) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide -5) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (hide -2 -3 -4 -5 -6) (("1" (reveal -21) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide -3 -2) (("1" (reveal -17) (("1" (lemma "solve_ac_vars_vars2avoid") (("1" (rewrite "vars_unif_prb") (("1" (skolem -3 "t2") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X" "t2") (("1" (assert) (("1" (prop) (("1" (hide -1 -2 -3) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "subterm_reflexive") (("2" (lemma "solve_ac_no_pair") (("2" (inst?) (("2" (assert) (("2" (expand "no_pair?" -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -5 1 2)) (("3" (reveal -44 -45 -46) (("3" (expand "vars" 2) (("3" (expand "member" 2) (("3" (expand "union" 2) (("3" (prop) (("3" (hide 3) (("3" (expand "member" 2) (("3" (expand "vars" 2) (("3" (replace -3) (("3" (replace -2) (("3" (replace -1) (("3" (expand "union" 2) (("3" (prop) (("3" (hide -1 -2 -3 -6) (("3" (lemma "vars_subterm") (("3" (expand "subterms" -2) (("3" (expand ("member" "union") -2) (("3" (prop) (("1" (inst -2 "X" "t2" "t") (("1" (assert) nil nil)) nil) ("2" (inst -2 "X" "t2" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1_p") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -22) (("2" (replace -1) (("2" (hide-all-but (-6 1)) (("2" (expand "new_vars2avoid") (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide 2) (("1" (lemma "mem_list2set[variable]") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -11) (("2" (expand "first_proj" -1) (("2" (lift-if) (("2" (assert) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -17) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -11) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (hide -4 -5 1) (("2" (reveal -8) (("2" (lemma "solve_ac_vars_vars2avoid") (("2" (inst?) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t1") (("2" (prop) (("2" (inst -1 "X" "t1") (("2" (assert) (("2" (prop) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "member" 1 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "subterm_reflexive") (("2" (lemma "solve_ac_no_pair") (("2" (inst?) (("2" (assert) (("2" (expand "no_pair?" -1) (("2" (inst -1 "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 1 2)) (("3" (reveal -37 -38 -39) (("3" (expand "vars" 2) (("3" (expand ("member" "union") 2) (("3" (prop) (("3" (replace -3) (("3" (hide 3) (("3" (hide -3) (("3" (expand "subterms" -3) (("3" (expand ("member" "union") -3) (("3" (expand "vars" 2) (("3" (expand ("member" "union") 2) (("3" (flatten) (("3" (replace -1) (("3" (replace -2) (("3" (lemma "vars_subterm") (("3" (prop) (("1" (inst -2 "X" "t1" "t") (("1" (assert) nil nil)) nil) ("2" (inst -2 "X" "t1" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (reveal -8 -9) (("2" (expand "all_ac_prb?" -3) (("2" (inst -3 "car(unseen_unif_prb)") (("2" (assert) (("2" (expand "member" -3) (("2" (expand "ac_prb?" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (reveal -8 -7) (("2" (expand "all_ac_prb?" -3) (("2" (inst -3 "car(unseen_unif_prb)") (("2" (expand "member" -3 1) (("2" (assert) (("2" (expand "ac_prb?" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) nil nil (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) nil (finite_emptyset name-judgement "finite_set" finite_sets nil) (empty? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (subs const-decl "term" substitution nil) nil (emptyset const-decl "set" sets nil) (union const-decl "set" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vars const-decl "finite_set[variable]" unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_union application-judgement "finite_set" finite_sets nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (vars_img_append formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) nil (apply_sub_len formula-decl nil unification nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) nil (vars_unif_prb formula-decl nil unification nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) nil (instantiate_step_vars_img formula-decl nil aux_unification nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (solve_ac_vars_vars2avoid formula-decl nil aux_unification nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (vars_subterm formula-decl nil term_properties nil) (subterms_mem_unif_prb formula-decl nil unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (no_pair? const-decl "bool" unification nil) (subterm_reflexive formula-decl nil term_properties nil) (finset2list_mem formula-decl nil list_theory nil) nil nil (instantiate_step_mem2 formula-decl nil aux_unification nil) (append_null formula-decl nil list_props nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (finset2list def-decl "list[T]" list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil) (apply_ac_sub_vars_img-1 nil 3850060923 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (prop) (("1" (expand "sigma_0n") (("1" (propax) nil nil)) nil) ("2" (expand "vars" 2 1) (("2" (expand ("member" "union") 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_sub_idempotent 0 (apply_ac_sub_idempotent-2 nil 3850071663 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "sigma_0n" 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (rewrite "append_null") (("2" (lemma "apply_ac_step_sigma_null") (("2" (hide -3 -4 -5 -6) (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (hide -4) (("2" (prop) (("2" (hide -6) (("2" (reveal -6) (("2" (replace -1) (("2" (name-replace "sigma_1n" "ac_sol1`2") (("2" (reveal -11 -13) (("2" (replace -1 -8 :dir rl) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (replace -5 -1 :dir rl) (("2" (hide -2 -3 -4 -5 1) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (reveal -28) (("2" (replace -1) (("2" (replace -2 3) (("2" (lemma "idempotent_append") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 4 -1 -2) (("1" (reveal -12 -4 -31) (("1" (inst -3 "input`1") (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (reveal -16) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -9) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "disjoint?" 1) (("3" (expand "empty?" 1) (("3" (skolem 1 "X") (("3" (expand "member" -1) (("3" (expand "intersection" -1) (("3" (prop) (("3" (lemma "apply_ac_step_sub_vars_img") (("3" (reveal -11) (("3" (reveal -3) (("3" (reveal -11) (("3" (hide -3) (("3" (inst -3 "X" "ac_sol1" "input`2" "input`1" "input`4") (("3" (assert) (("3" (prop) (("1" (hide-all-but (-1 -4)) (("1" (reveal -18) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (replace -1) (("1" (rewrite "apply_sub_mem") (("1" (skolem -2 "t1_p") (("1" (prop) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (reveal -13) (("1" (lemma "instantiate_step_idempotent3") (("1" (inst?) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (replace -3 :dir rl) (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (replace -1) (("2" (hide-all-but (-4 1)) (("2" (reveal -13) (("2" (lemma "instantiate_step_dom2") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (assert) (("2" (hide -2 -3) (("2" (expand "new_vars2avoid") (("2" (reveal -9) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(X)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -2) (("2" (expand "subset?" 1) (("2" (skolem 1 "X1") (("2" (prop) (("2" (use "mem_list2set[variable]") (("2" (assert) (("2" (hide 2) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (reveal -37 -38 -39) (("2" (expand "vars" 1) (("2" (expand ("member" "union")) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (reveal -5 -6) (("2" (hide -3 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal -5 -4) (("2" (hide -3 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (idempotent? const-decl "bool" substitution nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) nil (subs const-decl "term" substitution nil) nil (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (union const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (idempotent_append formula-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (apply_ac_step_sub_vars_img formula-decl nil apply_ac_step nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) nil (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (singleton const-decl "(singleton?)" sets nil) (subset? const-decl "bool" sets nil) nil nil (finset2list_mem formula-decl nil list_theory nil) (mem_list2set formula-decl nil list_theory nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (vars_unif_prb formula-decl nil unification nil) (apply_sub_mem formula-decl nil unification nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (apply_sub_len formula-decl nil unification nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (append_null formula-decl nil list_props nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (finset2list def-decl "list[T]" list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil) (apply_ac_sub_idempotent-1 nil 3850071451 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "sigma_0n" 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_sub_dom 0 (apply_ac_sub_dom-2 nil 3850071990 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "sigma_0n") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (rewrite "append_null") (("2" (lemma "apply_ac_step_sigma_null") (("2" (hide -3 -4 -5 -6) (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (hide -4) (("2" (prop) (("2" (hide -6) (("2" (reveal -6) (("2" (replace -1) (("2" (name-replace "sigma_1n" "ac_sol1`2") (("2" (reveal -11 -13) (("2" (replace -1 -8 :dir rl) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (replace -5 -1 :dir rl) (("2" (hide -2 -3 -4 -5 1) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (reveal -28) (("2" (replace -1) (("2" (replace -2) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (hide -5) (("2" (expand "member" -1) (("2" (expand "union" -1) (("2" (prop) (("1" (reveal -5 -32) (("1" (inst -2 "input`1") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "sigma_1n") (("1" (assert) (("1" (prop) (("1" (reveal -19) (("1" (replace -1 -2) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t_sigma") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -2 "t'") (("1" (prop) (("1" (replace -3) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (hide -2 -8 -9 -7) (("1" (reveal -18) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (reveal -13) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (lemma "solve_ac_vars_vars2avoid") (("1" (inst?) (("1" (inst -1 "X" "t1") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-10 1)) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "subterm_reflexive") (("2" (lemma "solve_ac_no_pair") (("2" (inst?) (("2" (assert) (("2" (expand "no_pair?" -1) (("2" (inst -1 "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (hide -2 -3 -4 -5 -6 -7 -8 -9 -10) (("3" (reveal -45 -46 -47) (("3" (lemma "vars_subterm") (("3" (expand "member" -5) (("3" (expand "subterms" -5) (("3" (expand "union" -5) (("3" (prop) (("1" (inst?) (("1" (inst -2 "X") (("1" (assert) (("1" (inst 3 "t") (("1" (assert) (("1" (expand "member" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst?) (("2" (inst -2 "X") (("2" (assert) (("2" (inst 3 "s") (("2" (assert) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 3 "t'") (("2" (expand "member" 3 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -22) (("2" (replace -1) (("2" (hide-all-but (-6 1)) (("2" (expand "new_vars2avoid") (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (reveal -11) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) (("1" (rewrite "mem_list2set" 1 :dir rl) (("1" (hide 2) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -2) (("2" (assert) (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -17) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_dom2") (("2" (inst?) (("2" (inst -1 "unif_prbC") (("2" (reveal -13) (("2" (assert) (("2" (assert) (("2" (reveal -6) (("2" (lemma "solve_ac_vars_vars2avoid") (("2" (inst?) (("2" (inst -1 "X" "variable(X)") (("2" (assert) (("2" (expand "vars" -1) (("2" (expand "member" -1 3) (("2" (expand "singleton" -1) (("2" (prop) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (expand ("member" "union")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "variable(X)") (("2" (assert) (("2" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 3)) (("3" (reveal -37 -38 -39) (("3" (rewrite "vars_unif_prb") (("3" (expand "member" -4) (("3" (expand "subterms" -4) (("3" (expand "union" -4) (("3" (lemma "vars_subterm") (("3" (prop) (("1" (inst 1 "t") (("1" (expand "member" 1 1) (("1" (assert) (("1" (inst -2 "X" "variable(X)" "t") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "s") (("2" (expand "member" 1 1) (("2" (assert) (("2" (inst -2 "X" "variable(X)" "s") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (expand "singleton" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (reveal -6 -7) (("2" (expand "all_ac_prb?" -3) (("2" (inst -3 "unif_pair") (("2" (expand "member" -3) (("2" (assert) (("2" (expand "ac_prb?" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (reveal -4 -5 -6) (("2" (expand "all_ac_prb?" -4) (("2" (inst -4 "unif_pair") (("2" (expand "member" -4) (("2" (assert) (("2" (expand "ac_prb?" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (vars def-decl "finite_set[variable]" unification nil) (dom const-decl "finite_set[variable]" substitution nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) (sigma_0n skolem-const-decl "sub" apply_ac_step nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (subs const-decl "term" substitution nil) (subs def-decl "term" substitution nil) (emptyset const-decl "set" sets nil) (union const-decl "set" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vars const-decl "finite_set[variable]" unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_union application-judgement "finite_set" finite_sets nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) (apply_sub_len formula-decl nil unification nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) (new_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (apply_sub def-decl "unif_prb" unification nil) (vars_unif_prb formula-decl nil unification nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (solve_ac_vars_vars2avoid formula-decl nil aux_unification nil) (lst_vars2avoid skolem-const-decl "list[nat]" apply_ac_step nil) (cur_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (finset2list_mem formula-decl nil list_theory nil) (subterm_reflexive formula-decl nil term_properties nil) (no_pair? const-decl "bool" unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (subterms_mem_unif_prb formula-decl nil unification nil) (vars_subterm formula-decl nil term_properties nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (member def-decl "bool" unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (sigma_1n skolem-const-decl "sub" apply_ac_step nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars def-decl "finite_set[variable]" term_properties nil) (singleton const-decl "(singleton?)" sets nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (append_null formula-decl nil list_props nil) (input_lst skolem-const-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (vars def-decl "finite_set[variable]" term_properties nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (every adt-def-decl "boolean" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil) (apply_ac_sub_dom-1 nil 3850071846 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (expand "sigma_0n") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_sub_decompose 0 (apply_ac_sub_decompose-2 nil 3850072409 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2 1) (("" (lift-if) (("" (split -2) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (inst 1 "null") (("1" (expand "append" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (inst -4 "cdr(unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (inst -4 "input`1") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prb1" "delta")) (("2" (flatten) (("2" (prop) (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`4") (("1" (assert) (("1" (skolem -1 "delta2") (("1" (replace -5) (("1" (inst 3 "append(delta2, delta)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vars def-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (append_assoc formula-decl nil list_props nil) (apply_sub_len formula-decl nil unification nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (vars def-decl "finite_set[variable]" term_properties nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (every adt-def-decl "boolean" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil) (apply_ac_sub_decompose-1 nil 3850072227 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2 1) (("" (lift-if) (("" (split -2) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (inst 1 "null") (("1" (expand "append" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (inst -4 "cdr(unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_vars2avoid 0 (apply_ac_vars2avoid-2 nil 3850072839 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (split -2) (("1" (replace -1) (("1" (assert) (("1" (expand "subset?" 1) (("1" (prop) (("1" (skeep) nil nil) ("2" (skeep) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (inst 2 "t1") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (split) (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 3 -2 -1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "vars" 3) (("2" (expand ("member" "union") 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (flatten) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma1")) (("2" (flatten) (("2" (hide -1 -2 -3 -4 -5) (("2" (reveal -1) (("2" (expand "ac_results_subs" -1) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (flatten) (("2" (hide 1) (("2" (expand "ac_results" -1) (("2" (hide -5) (("2" (reveal -18) (("2" (inst -1 "input`1") (("2" (split -1) (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`4") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" 2) (("1" (skeep) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (reveal -9) (("1" (replace -1) (("1" (hide -1) (("1" (expand "new_vars2avoid" 1) (("1" (lemma "solve_ac_sec_proj_vars") (("1" (inst?) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -4) (("2" (assert) (("2" (expand "member" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal -5 -6 -8) (("2" (replace -1 :hide? t) (("2" (replace -1 :hide? t) (("2" (replace -1 :hide? t) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (case "subset?(vars(img(sigma1)), new_vars2avoid)") (("1" (case "subset?(vars2avoid, new_vars2avoid)") (("1" (rewrite "vars_unif_prb") (("1" (skolem -3 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t1p") (("1" (prop) (("1" (replace -2 -5) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "subset?" -12) (("2" (inst -12 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (inst 4 "t1p") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (hide 1) (("1" (replace -9 :dir rl) (("1" (replace -2 -6) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "new_vars2avoid") (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t1p") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -5 -6 -8) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (reveal -24 -25 -26) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2 -5) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "subset?" -12) (("2" (inst -12 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (inst 4 "t1p") (("2" (prop) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -5) (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (replace -5 -1) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (assert) (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "w") (("2" (prop) (("2" (hide -2 -3 -4 2 3) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (reveal -23 -24 -25) (("2" (assert) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (reveal -7 -8) (("3" (replace -1 :hide? t) (("3" (replace -1 :hide? t) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (lemma "dom_append") (("3" (inst -1 "sigma1" "sigma") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (replace -5 -1) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "new_vars2avoid" 1) (("1" (lemma "solve_ac_first_proj_sec_proj_vars") (("1" (inst?) (("1" (assert) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(x)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (reveal -22 -23 -24) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -10) (("2" (inst -10 "x") (("2" (assert) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -4) (("2" (assert) (("2" (expand "member" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (subset? const-decl "bool" sets nil) nil (append def-decl "list[T]" list_props nil) (dom const-decl "finite_set[variable]" substitution nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) nil (dom_append formula-decl nil substitution nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (singleton const-decl "(singleton?)" sets nil) nil (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) nil (apply_sub def-decl "unif_prb" unification nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) nil nil nil nil (finset2list_mem formula-decl nil list_theory nil) (mem_list2set formula-decl nil list_theory nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) nil nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (subs const-decl "term" substitution nil) (vars const-decl "finite_set[variable]" unification nil) (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_union application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member_unif_prb_append formula-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil)) nil) (apply_ac_vars2avoid-1 nil 3850072525 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (split -2) (("1" (replace -1) (("1" (assert) (("1" (expand "subset?" 1) (("1" (prop) (("1" (skeep) nil nil) ("2" (skeep) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (inst 2 "t1") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (split) (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 3 -2 -1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "vars" 3) (("2" (expand ("member" "union") 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_disjoint_vars 0 (apply_ac_disjoint_vars-2 nil 3850073199 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (split -2) (("1" (replace -1) (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -6) (("1" (prop) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -5 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" (1 -4)) (("1" (expand "empty?") (("1" (skeep) (("1" (inst -5 "x") (("1" (expand ("member" "intersection") -1) (("1" (flatten) (("1" (expand ("member" "intersection") 2) (("1" (assert) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (flatten) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma1")) (("2" (flatten) (("2" (hide -1 -2 -3 -4 -5) (("2" (reveal -1) (("2" (expand "ac_results_subs" -1) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (flatten) (("2" (hide 1) (("2" (expand "ac_results" -1) (("2" (hide -5) (("2" (reveal -18) (("2" (inst -1 "input`1") (("2" (split -1) (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`4") (("1" (assert) (("1" (reveal -5 -6 -7 -8) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (hide -1 -2 -3 -4) (("1" (prop) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (lemma "dom_append") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -3) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (lemma "instantiate_step_idempotent3") (("1" (inst?) (("1" (assert) (("1" (replace -6 :dir rl) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (skolem -4 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t1p") (("1" (assert) (("1" (flatten) (("1" (replace -2 -6) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (replace -7) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (hide -10) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (replace -10 :dir rl) (("1" (replace -2) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -5) (("1" (expand "empty?" -5) (("1" (inst -5 "x") (("1" (expand ("member" "intersection") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -4) (("2" (expand "empty?" -4) (("2" (inst -4 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (rewrite "vars_unif_prb") (("1" (skolem -3 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t1p") (("1" (prop) (("1" (replace -2) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -13) (("2" (expand "empty?" -13) (("2" (inst -13 "x") (("2" (expand ("member" "intersection") 3) (("2" (rewrite "vars_unif_prb") (("2" (inst 3 "t1p") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (replace -9 :dir rl) (("1" (replace -2) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "disjoint?" -5) (("1" (expand "empty?" -5) (("1" (inst -5 "x") (("1" (expand ("member" "intersection") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (hide -10 -11 2) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -13) (("1" (expand "empty?" -13) (("1" (inst -13 "x") (("1" (expand ("member" "intersection") 3) (("1" (expand "append" 3) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (prop) (("1" (reveal -27 -28 -29) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -13) (("2" (inst -13 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (inst 1 "t1p") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2 -5) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -13) (("2" (expand "empty?" -13) (("2" (inst -13 "x") (("2" (expand ("member" "intersection") 3) (("2" (rewrite "vars_unif_prb") (("2" (inst 3 "t1p") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skolem 1 "y") (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (replace -5 -2) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (hide -3) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "y") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -10) (("1" (expand "empty?" -10) (("1" (inst -10 "y") (("1" (expand ("member" "intersection") 2) (("1" (expand "append" 2) (("1" (expand "member" 2) (("1" (expand "vars" 2 1) (("1" (expand "union" 2 1) (("1" (flatten) (("1" (reveal -27 -28 -29) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -10) (("2" (inst -10 "y") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -5) (("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (hide -2) (("1" (replace -4 -1) (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (assert) (("1" (expand "new_vars2avoid" 1) (("1" (lemma "solve_ac_first_proj_sec_proj_vars") (("1" (inst?) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(x)") (("1" (prop) (("1" (expand "vars" 1) (("1" (expand "singleton" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (hide -2 2) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (reveal -26 -27 -28) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -3) (("2" (assert) (("2" (expand "member" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (expand "t") (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "unif_pair") (("2" (expand "ac_prb?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide -2 -3 3) (("2" (expand "t") (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "unif_pair") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (disjoint? const-decl "bool" sets nil) nil (append def-decl "list[T]" list_props nil) (dom const-decl "finite_set[variable]" substitution nil) (subset? const-decl "bool" sets nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil nil (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (dom_append formula-decl nil substitution nil) nil (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (solve_ac_vars formula-decl nil aux_unification nil) nil nil (finset2list_mem formula-decl nil list_theory nil) (vars_subs_t formula-decl nil substitution nil) nil (instantiate_step_vars_img formula-decl nil aux_unification nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_mem formula-decl nil unification nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (apply_sub def-decl "unif_prb" unification nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (singleton const-decl "(singleton?)" sets nil) (mem_list2set formula-decl nil list_theory nil) nil nil (instantiate_step_mem2 formula-decl nil aux_unification nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) nil nil (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) (vars const-decl "finite_set[variable]" unification nil) (subs const-decl "term" substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (union const-decl "set" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member_unif_prb_append formula-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil)) nil) (apply_ac_disjoint_vars-1 nil 3850072980 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (split -2) (("1" (replace -1) (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -6) (("1" (prop) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -5 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" (1 -4)) (("1" (expand "empty?") (("1" (skeep) (("1" (inst -5 "x") (("1" (expand ("member" "intersection") -1) (("1" (flatten) (("1" (expand ("member" "intersection") 2) (("1" (assert) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_unifies_seen 0 (apply_ac_unifies_seen-3 nil 3850074529 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (hide -1) (("" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (inst -1 "delta") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-7 1 2)) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -2 "x") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "input") (("2" (flatten) (("2" (hide -3) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prb1" "sigma1")) (("2" (flatten) (("2" (reveal -13) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol" "delta" "input`2" "input`3" "input`4") (("1" (assert) (("1" (replace -4) (("1" (rewrite "unifies?_append") (("1" (prop) (("1" (hide -1) (("1" (hide -7 -3 -4 -5 -6) (("1" (lemma "apply_ac_step_sub_decompose") (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("1" (assert) (("1" (skolem -1 "sigma2") (("1" (reveal -4) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (skolem -7 "sigma3") (("1" (rewrite "unifies?_equiv" 3) (("1" (skolem 3 "unif_pair1") (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -2 "apply_sub(sigma1, unif_pair1)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" 3) (("1" (reveal -14) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "instantiate_step_mem2") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (flatten) (("1" (hide -1 -2 -3 1) (("1" (replace -7 -1) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (case "idempotent?(sigma1)") (("1" (hide -7 -8 -4 1 2) (("1" (case "subs(sigma)(subs(sigma1)(unif_pair1`1)) = subs(sigma1)(unif_pair1`1)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "idempotent_subs_subs_t") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "subs(sigma)(subs(sigma1)(unif_pair1`2)) = subs(sigma1)(unif_pair1`2)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "idempotent_subs_subs_t") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (replace -7) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (case "subs(sigma)(unif_pair1`1) = unif_pair1`1") (("1" (replace -1) (("1" (case "subs(sigma)(unif_pair1`2) = unif_pair1`2") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (hide -1 -2 -3) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (expand "disjoint?" -6) (("2" (expand "empty?" -6) (("2" (inst -6 "x") (("2" (expand ("member" "intersection") 2) (("2" (assert) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 2 "unif_pair1`2") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 2 -7 -8) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (expand "disjoint?" -3) (("2" (skeep) (("2" (expand "empty?" -4) (("2" (inst -4 "x") (("2" (expand ("member" "intersection") 2) (("2" (expand ("member" "intersection") -1) (("2" (flatten) (("2" (assert) (("2" (expand ("member" "union") 2) (("2" (flatten) (("2" (rewrite "vars_unif_prb") (("2" (inst 2 "unif_pair1`1") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 2 -7) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (flatten) (("2" (reveal -3) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -2) (("1" (expand "empty?" -2) (("1" (inst -2 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -7) (("2" (expand "empty?" -7) (("2" (inst -7 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "unif_pair1`2") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 1 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (flatten) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -7) (("2" (expand "empty?" -7) (("2" (inst -7 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "unif_pair1`1") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 1 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (hide -1 -2 -3 -4) (("2" (reveal -8) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4 -1 -2 -3 -4 -5) (("2" (lemma "instantiate_step_vars_img") (("2" (reveal -8) (("2" (inst -2 "unif_prbC") (("2" (assert) (("2" (replace -1 :dir rl) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -3) (("2" (flatten) (("2" (expand "subset?" -2) (("2" (inst -2 "x") (("2" (assert) (("2" (hide -4) (("2" (reveal -9 -28) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-1 -5 -9)) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (reveal -40 -41 -42) (("1" (expand "member" 2) (("1" (expand "vars" 2) (("1" (expand "union" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (hide-all-but (-7 1)) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "member" 2) (("2" (expand "union" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_sub_unif_pair") (("2" (inst?) (("2" (assert) (("2" (inst 1 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (replace -5) (("2" (hide-all-but (1 -11 -1)) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand "new_vars2avoid" 1) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (reveal -18) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (flatten) (("1" (hide 1) (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (lemma "solve_ac_first_proj_sec_proj_vars") (("1" (inst?) (("1" (reveal -24) (("1" (replace -1 -4 :dir rl) (("1" (inst -2 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(x)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (expand "subset?" 1) (("2" (skolem 1 "x1") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (reveal -32 -33 34) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) (("2" (flatten) (("2" (reveal -34) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_sec_proj_vars") (("2" (reveal -20) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (case "ac_results = null") (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (expand "instantiate_step" -7) (("1" (expand "member" -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -4) (("3" (replace -2) (("3" (hide -2 -3 -4 -5 -6) (("3" (hide 2 3 4) (("3" (reveal -11) (("3" (replace -1 :dir rl) (("3" (lemma "instantiate_step_mem2") (("3" (inst?) (("3" (assert) (("3" (skolem -1 "unif_prbC") (("3" (flatten) (("3" (hide -1 -2 -3 1) (("3" (case "idempotent?(sigma1)") (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -3) (("1" (flatten) (("1" (lemma "dom_append") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (hide -4) (("1" (expand "member" -4) (("1" (expand "union" -4) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (flatten) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -5) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1_p") (("1" (flatten) (("1" (hide 1) (("1" (reveal -7) (("1" (replace -1 :dir rl) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst -1 "x" "sigma1" "t1_p") (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst -1 "sigma1") (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1_p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1_p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (hide -11 -10 -8 -7 -4) (("1" (hide -4) (("1" (expand "member" -4) (("1" (expand "union" -4) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -9 -10) (("1" (lemma "instantiate_step1_mem") (("1" (replace -2) (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1_p") (("1" (replace -3 :dir rl) (("1" (flatten) (("1" (hide -1 1) (("1" (replace -1) (("1" (hide -4 -9) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (reveal -4) (("1" (inst -2 "x") (("1" (assert) (("1" (expand ("member" "union") -2) (("1" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -14 -30) (("2" (replace -2 :dir rl) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -14) (("1" (expand "empty?" -14) (("1" (inst -14 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (reveal -36 -37 -38) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -12) (("2" (inst -12 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (inst 1 "t1_p") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4 -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -8) (("2" (expand "empty?" -8) (("2" (inst -8 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -5) (("1" (expand "empty?" -5) (("1" (inst -5 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -10) (("2" (expand "empty?" -10) (("2" (inst -10 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb" 2) (("2" (inst 2 "t1p") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 -5 -6 -7 -9 -10) (("2" (reveal -12) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (replace -2 :dir rl) (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skolem 1 "x1") (("2" (expand ("member" "intersection") -3) (("2" (prop) (("2" (expand "subset?" -1) (("2" (inst -1 "x1") (("2" (assert) (("2" (reveal -12 -28) (("2" (replace -2 :dir rl) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x1") (("2" (assert) (("2" (prop) (("1" (hide -2 -3 -9 -5) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x1") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (reveal -36 -37 -38) (("1" (expand "member" 2) (("1" (expand "vars" 2) (("1" (expand "union" 2) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "member" 1) (("2" (expand "cur_vars2avoid" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (expand "subset?" -6) (("2" (inst -6 "x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -3) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (assert) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (unifies? def-decl "bool" unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (subset? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (disjoint? const-decl "bool" sets nil) (union const-decl "set" sets nil) (vars def-decl "finite_set[variable]" unification nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) (unifies?_equiv formula-decl nil unification nil) (apply_sub const-decl "unif_pair" unification nil) (apply_sub_unif_pair formula-decl nil unification nil) (unifies? const-decl "bool" unification nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (solve_ac_vars formula-decl nil aux_unification nil) (finset2list_mem formula-decl nil list_theory nil) (cur_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (lst_vars2avoid skolem-const-decl "list[nat]" apply_ac_step nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (idempotent? const-decl "bool" substitution nil) (vars_unif_prb formula-decl nil unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (subs_no_effect_t formula-decl nil substitution nil) (vars_subs_t formula-decl nil substitution nil) (idempotent_subs_subs_t formula-decl nil substitution nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (vars def-decl "finite_set[variable]" term_properties nil) (subs_append2 formula-decl nil substitution nil) (subs def-decl "term" substitution nil) (apply_ac_step_sub_decompose formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (mem_list2set formula-decl nil list_theory nil) (singleton const-decl "(singleton?)" sets nil) (vars def-decl "finite_set[variable]" term_properties nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (new_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (member def-decl "bool" unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (member_unif_prb_append formula-decl nil unification nil) (unifies?_append formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (input_lst skolem-const-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (subs const-decl "term" substitution nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (vars const-decl "finite_set[variable]" unification nil) (empty? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_union application-judgement "finite_set" finite_sets nil)) nil) (apply_ac_unifies_seen-2 nil 3850073736 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (hide -1) (("" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "delta") (("1" (prop) (("1" (hide-all-but (-7 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (expand "member" -1 1) (("2" (prop) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (apply_ac_unifies_seen-1 nil 3850073390 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (hide -1) (("" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "delta") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-7 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7 -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_sound 0 (apply_ac_sound-2 nil 3850076204 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (hide -1) (("" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "unifies?" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (inst -1 "delta") (("1" (assert) (("1" (prop) (("1" (expand "unifies?" 2) (("1" (prop) (("1" (expand "unifies?" 1) (("1" (reveal -4 -5 -6) (("1" (replace -3) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "subs_equal?") (("1" (inst -1 "s" "delta" "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1 2)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -2 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, sigma, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "input") (("2" (flatten) (("2" (expand "input_lst" -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst?) (("2" (assert) (("2" (skolem -1 ("unif_prb1" "sigma1")) (("2" (flatten) (("2" (hide -6) (("2" (reveal -13) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol" "delta" "input`2" "input`3" "input`4") (("1" (assert) (("1" (prop) (("1" (hide -3 -4 -5 -6) (("1" (expand "unifies?" 3) (("1" (prop) (("1" (expand "unifies?" 1) (("1" (reveal -15 -16 -17) (("1" (replace -3) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (reveal -11) (("1" (replace -1 :dir rl) (("1" (inst?) (("1" (assert) (("1" (skolem -2 "unif_prbC") (("1" (flatten) (("1" (hide 1 3) (("1" (hide -1 -3 -4 -5 -6 -7) (("1" (reveal -16) (("1" (hide -1 -2) (("1" (reveal -6 -7) (("1" (lemma "apply_ac_step_unifies_seen") (("1" (inst -1 "ac_sol" "delta" "_" "_" "_" "_") (("1" (inst -1 "input`2" "input`3" "input`1" "input`4") (("1" (assert) (("1" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (hide -1) (("1" (prop) (("1" (replace -3) (("1" (rewrite "unifies?_append") (("1" (prop) (("1" (hide-all-but (-1 1 2)) (("1" (lemma "instantiate_step_unifies") (("1" (reveal -15) (("1" (inst -2 "_" "delta" "unif_prbC") (("1" (reveal -9 -5) (("1" (reveal -22) (("1" (lemma "apply_ac_step_sub_decompose") (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("1" (assert) (("1" (skolem -1 "sigma2") (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2 -3) (("1" (reveal -19) (("1" (inst -4 "sigma") (("1" (prop) (("1" (reveal -34 -18) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_unify_sound") (("1" (inst?) (("1" (inst -1 "delta") (("1" (assert) (("1" (prop) (("1" (expand "unifies?" -1) (("1" (propax) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (reveal -12 -39 -40 -41) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(unseen_unif_prb)") (("2" (expand "member" -1 1) (("2" (expand "ac_prb?" -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -12 -39 -40 -41) (("3" (expand "is_ac_sym?" 1) (("3" (expand "all_ac_prb?" -1) (("3" (inst -1 "car(unseen_unif_prb)") (("3" (expand "member" -1 1) (("3" (expand "ac_prb?" -1) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -2 "sigma3") (("2" (inst 1 "append(sigma3, sigma2)") (("2" (replace -1 :dir rl) (("2" (rewrite "append_assoc") nil nil)) nil)) nil)) nil) ("3" (reveal 1) (("3" (propax) nil nil)) nil) ("4" (hide -2 -3 -4 2) (("4" (reveal -15 -16) (("4" (reveal -20 -36) (("4" (expand "disjoint?" 1) (("4" (expand "empty?" 1) (("4" (skeep) (("4" (expand ("member" "intersection") -5) (("4" (prop) (("4" (lemma "solve_ac_vars") (("4" (replace -3 :dir rl) (("4" (inst?) (("4" (inst -1 "x") (("4" (assert) (("4" (hide -2) (("4" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (reveal -43 -44 -45) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -2) (("2" (inst -2 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 2) (("2" (reveal -5 -15 -16) (("2" (replace -2) (("2" (replace -3) (("2" (hide -2 -3) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (hide -2) (("1" (hide -2 -3 -4) (("1" (reveal -15) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (assert) (("1" (hide -2) (("1" (reveal -16 -32) (("1" (expand "new_vars2avoid" 1) (("1" (lemma "solve_ac_first_proj_sec_proj_vars") (("1" (inst?) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "variable(x)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (hide -3 -4) (("2" (skolem 1 "x1") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 1) (("2" (expand "vars" 1) (("2" (expand "union" 1) (("2" (flatten) (("2" (reveal -39 -40 -41) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (hide -1) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_sec_proj_vars") (("2" (reveal -28) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -2) (("2" (assert) (("2" (reveal -7) (("2" (replace -3 :dir rl) (("2" (expand "instantiate_step" -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -11) (("3" (replace -1) (("3" (replace -2) (("3" (replace -3) (("3" (hide -4) (("3" (reveal -2) (("3" (hide 2 -10 -8 -2 -3 -4 -5 -6) (("3" (hide -3) (("3" (expand "disjoint?" 1) (("3" (expand "empty?" 1) (("3" (skeep) (("3" (expand "member" -2) (("3" (expand "intersection" -2) (("3" (prop) (("3" (lemma "dom_append") (("3" (inst?) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (hide -3) (("1" (expand "member" -3 1) (("1" (expand "union" -3) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -14) (("1" (replace -1 -2) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (reveal -16) (("1" (replace -1 :dir rl) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (lemma "instantiate_step_idempotent3") (("1" (inst?) (("1" (assert) (("1" (replace -3 :dir rl) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (reveal -16) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst?) (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (reveal -16) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -4 1) (("2" (expand "union" -4) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -13 -14) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (hide 1) (("1" (replace -4 :dir rl) (("1" (replace -2) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -5 -7 -11) (("2" (reveal -34) (("2" (reveal -18) (("2" (replace -2 :dir rl) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand ("member" "intersection") 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (reveal -40 -41 -42) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -10) (("2" (inst -10 "x") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (inst 1 "t1p") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst -1 "sigma1" "t1p") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -10) (("2" (expand "empty?" -10) (("2" (inst -10 "x") (("2" (expand "member" 2) (("2" (expand "intersection" 2) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -10) (("2" (expand "empty?" -10) (("2" (inst -10 "x") (("2" (expand ("member" "intersection") 2) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t1p") (("2" (assert) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 2) (("2" (reveal -12 -13) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (replace -3 :dir rl) (("2" (expand "subset?" -1) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") -4) (("2" (flatten) (("2" (assert) (("2" (hide -2 -3) (("2" (reveal -13 -29) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (reveal -35 -36 -37) (("1" (expand "member" 3) (("1" (expand "vars" 3) (("1" (expand "union" 3) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (lemma "apply_ac_step_sub_decompose") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (reveal -4) (("2" (skolem -2 "sigma2") (("2" (replace -1) (("2" (hide -1) (("2" (skolem -9 "sigma3") (("2" (replace -1) (("2" (replace -2) (("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair1") (("2" (prop) (("2" (rewrite "unifies?_equiv" -4) (("2" (inst -4 "apply_sub(sigma1, unif_pair1)") (("2" (assert) (("2" (prop) (("1" (expand "unifies?" -1) (("1" (expand "unifies?" 1) (("1" (expand "apply_sub" -1) (("1" (case "idempotent?(sigma1)") (("1" (replace -11) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (case "subs(sigma)(subs(sigma1)(unif_pair1`1)) = subs(sigma1)(unif_pair1`1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "subs(sigma)(subs(sigma1)(unif_pair1`2)) = subs(sigma1)(unif_pair1`2)") (("1" (replace -1) (("1" (hide -1) (("1" (case "subs(sigma1)(subs(sigma1)(unif_pair1`1)) = subs(sigma1)(unif_pair1`1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "subs(sigma1)(subs(sigma1)(unif_pair1`2)) = subs(sigma1)(unif_pair1`2)") (("1" (replace -1) (("1" (hide -1) (("1" (case "subs(sigma)(unif_pair1`1) = unif_pair1`1") (("1" (replace -1) (("1" (case "subs(sigma)(unif_pair1`2) = unif_pair1`2") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 -15)) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (reveal -7) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "disjoint?" -4) (("2" (expand "empty?" -4) (("2" (inst -4 "x") (("2" (expand ("member" "intersection") 2) (("2" (prop) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb" 2) (("2" (inst 2 "unif_pair1`2") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -14 -6)) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (expand "disjoint?" -4) (("2" (expand "empty?" -4) (("2" (inst -4 "x") (("2" (expand ("member" "intersection") 1) (("2" (prop) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb" 2) (("2" (inst 2 "unif_pair1`1") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (lemma "idempotent_subs_subs_t") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (lemma "idempotent_subs_subs_t") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -6 -14 -1)) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -6) (("2" (expand "empty?" -6) (("2" (inst -6 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (rewrite "vars_unif_prb" 2) (("2" (inst 2 "unif_pair1`2") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -6 -14 -1)) (("2" (lemma "subs_no_effect_t") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -6) (("2" (expand "empty?" -6) (("2" (inst -6 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (rewrite "vars_unif_prb" 2) (("2" (inst 2 "unif_pair1`1") (("2" (assert) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 2 "unif_pair1") (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -12 -13 1)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (reveal -1 -5) (("2" (lemma "instantiate_step_mem2") (("2" (reveal -22) (("2" (inst?) (("2" (replace -1 :dir rl) (("2" (inst?) (("2" (assert) (("2" (skolem -2 "unif_prbC") (("2" (flatten) (("2" (hide 1 -1) (("2" (hide -5) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (replace -4 :dir rl) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (lemma "solve_ac_vars") (("2" (reveal -29) (("2" (replace -1 :dir rl) (("2" (inst?) (("2" (assert) (("2" (inst -2 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (reveal -35 -36 -37) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -9) (("2" (inst -9 "x") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (hide -2 -3 -4 2 3) (("2" (reveal -15) (("2" (replace -1 :dir rl) (("2" (inst?) (("2" (assert) (("2" (skolem -2 "unif_prbC") (("2" (prop) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_unif_pair") (("2" (inst 1 "unif_pair1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (replace -5) (("2" (hide -2 -3 -4 -5) (("2" (reveal -10) (("2" (lemma "instantiate_step_mem2") (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (hide 1 3 4 -2 -3) (("2" (hide -3 -4 -5 -6 -7) (("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (hide -3) (("1" (reveal -10) (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (assert) (("1" (reveal -25) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (hide -5) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "new_vars2avoid") (("1" (lemma "solve_ac_first_proj_sec_proj_vars") (("1" (inst?) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (case "member(x, vars(unif_prbC))") (("1" (assert) (("1" (hide -1 -2 2) (("1" (expand "subset?" 1) (("1" (skolem 1 "x1") (("1" (prop) (("1" (rewrite "mem_list2set" 1 :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (reveal -35 -36 -37) (("1" (expand "member" 1) (("1" (expand "vars" 1) (("1" (expand "union" 1) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "variable(x)") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (expand "singleton" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "new_vars2avoid") (("2" (lemma "solve_ac_sec_proj_vars") (("2" (inst?) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" 1 :dir rl) (("1" (expand "lst_vars2avoid" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid" 1) (("1" (expand "member" 1) (("1" (expand "union" 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "first_proj" -1) (("2" (assert) (("2" (replace -1 :dir rl) (("2" (expand "instantiate_step" -6) (("2" (expand "member" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -4) (("3" (replace -2) (("3" (replace -3) (("3" (hide 2 4 -2 -3 -4 -5 -6 -7 -8 -9 -10) (("3" (reveal -15) (("3" (replace -1 :dir rl) (("3" (hide -1) (("3" (lemma "instantiate_step_mem2") (("3" (inst?) (("3" (assert) (("3" (skolem -1 "unif_prbC") (("3" (flatten) (("3" (hide 1 -2 -3) (("3" (expand "disjoint?" 1) (("3" (expand "empty?" 1) (("3" (skeep) (("3" (expand ("member" "intersection") -2) (("3" (prop) (("3" (case "disjoint?(dom(sigma), vars(img(sigma1)))") (("1" (lemma "dom_append") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "member" -5) (("1" (expand "union" -5) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -3) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) (("1" (reveal -6) (("1" (replace -1 :dir rl) (("1" (replace -3 :dir rl) (("1" (assert) (("1" (skolem -2 "t1p") (("1" (flatten) (("1" (hide 1) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (case "idempotent?(sigma1)") (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst -1 "sigma1") (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (reveal -5) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (reveal -5) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "x") (("2" (expand ("member" "intersection") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" -4) (("2" (expand "union" -4) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -4) (("1" (reveal -23) (("1" (replace -1 :dir rl) (("1" (hide -8) (("1" (hide -1) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) (("1" (assert) (("1" (skolem -1 "t1p") (("1" (flatten) (("1" (hide 1) (("1" (reveal -8) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -2) (("1" (lemma "vars_subs_t") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "disjoint?" -8) (("1" (expand "empty?" -8) (("1" (inst -8 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand "member" 2 1) (("1" (expand "intersection" 2 1) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (reveal -34 -35 -36) (("1" (expand "member" 3) (("1" (expand "vars" 3) (("1" (expand "union" 3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -10) (("2" (inst -10 "x") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb") (("3" (inst 1 "t1p") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -10) (("2" (expand "empty?" -10) (("2" (inst -10 "x") (("2" (expand ("member" "intersection") 2) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t1p") (("2" (prop) (("2" (replace -2) (("2" (lemma "vars_subs_t") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -10) (("2" (expand "empty?" -10) (("2" (inst -10 "x") (("2" (expand ("member" "intersection") 2) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t1p") (("2" (assert) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skolem 1 "x1") (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (reveal -5) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x1") (("2" (replace -2 :dir rl) (("2" (assert) (("2" (lemma "solve_ac_vars") (("2" (reveal -25) (("2" (replace -1 :dir rl) (("2" (inst?) (("2" (inst -2 "x1") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x1") (("1" (expand ("member" "intersection") 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (reveal -31 -32 -33) (("1" (expand "member" 3) (("1" (expand "vars" 3) (("1" (expand "union" 3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x1") (("2" (assert) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "unifies?" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (empty? const-decl "bool" sets nil) (subs const-decl "term" substitution nil) (vars const-decl "finite_set[variable]" unification nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (unifies? const-decl "bool" unification nil) (subs_equal? formula-decl nil substitution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (member_unif_prb_append formula-decl nil unification nil) (apply_sub_mem formula-decl nil unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (member def-decl "bool" unification nil) (vars_subs_t formula-decl nil substitution nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (new_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars def-decl "finite_set[variable]" term_properties nil) (singleton const-decl "(singleton?)" sets nil) (vars_unif_prb formula-decl nil unification nil) (mem_list2set formula-decl nil list_theory nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (dom_append formula-decl nil substitution nil) (instantiate_step_unifies formula-decl nil aux_unification nil) (solve_ac_unify_sound formula-decl nil aux_unification nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (append_assoc formula-decl nil list_props nil) (lst_vars2avoid skolem-const-decl "list[nat]" apply_ac_step nil) (cur_vars2avoid skolem-const-decl "finite_set[variable]" apply_ac_step nil) (finset2list_mem formula-decl nil list_theory nil) (solve_ac_vars formula-decl nil aux_unification nil) (apply_ac_step_sub_decompose formula-decl nil apply_ac_step nil) (unifies?_append formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (vars def-decl "finite_set[variable]" term_properties nil) (apply_ac_step_unifies_seen formula-decl nil apply_ac_step nil) (unifies?_equiv formula-decl nil unification nil) (apply_sub const-decl "unif_pair" unification nil) (idempotent? const-decl "bool" substitution nil) (subs def-decl "term" substitution nil) (subs_append2 formula-decl nil substitution nil) (member_unif_prb_equiv formula-decl nil unification nil) (subs_no_effect_t formula-decl nil substitution nil) (idempotent_subs_subs_t formula-decl nil substitution nil) (apply_sub_unif_pair formula-decl nil unification nil) (apply_sub_len formula-decl nil unification nil) (input_lst skolem-const-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (vars def-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (subset? const-decl "bool" sets nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (unifies? def-decl "bool" unification nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" term_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (apply_ac_sound-1 nil 3850075754 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (hide -1) (("" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "unifies?" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (postpone) nil nil) ("2" (flatten) (("2" (delete 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg apply_ac_vars_not_ac2 0 (apply_ac_vars_not_ac2-1 nil 3850077914 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (hide -2 -3) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1 1) (("1" (assert) (("1" (expand "subset?" 1) (("1" (skolem 1 "Y") (("1" (prop) (("1" (expand "image" 1) (("1" (expand "member" 1 1) (("1" (inst 1 "Y") (("1" (expand "mimic_var" 1) (("1" (propax) nil nil)) nil) ("2" (lemma "vars_not_ac_unif_prb_append") (("2" (inst -1 "Y" "unseen_unif_prb" "seen_unif_prb") (("2" (expand "member" -1 1) (("2" (replace -1) (("2" (hide -1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -3) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (assert) (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (reveal -2 -3) (("1" (prop) (("1" (expand "subset?") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -5 -4 -6) (("1" (expand ("member" "image")) (("1" (skeep) (("1" (inst 2 "x_1") (("1" (typepred "x_1") (("1" (expand "append" 1 1) (("1" (expand "vars_not_ac" 1) (("1" (expand "union" 1) (("1" (assert) (("1" (flatten) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_var_pair?" -1) (("2" (expand "no_var_pair?" 1) (("2" (skeep) (("2" (inst -2 "t") (("2" (expand "member" -2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input") (("2" (hide -2) (("2" (prop) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (flatten) (("2" (replace -2) (("2" (replace -3) (("2" (hide -2 -3 -4 -6) (("2" (reveal -19) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol1" "input`2" "input`4") (("1" (assert) (("1" (prop) (("1" (case "subset?(image(mimic_var(ac_sol1`2), vars_not_ac(append(input`1, input`2))),
                               image(mimic_var(append(ac_sol1`2, input`3)), vars_not_ac(append(unseen_unif_prb, seen_unif_prb))))") (("1" (expand "subset?" 3) (("1" (skeep) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "mimic_var_append") (("2" (inst? -1) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "image_composition[variable, variable, variable]") (("2" (inst? -1) (("2" (replace -1 1 :dir rl) (("2" (hide -1) (("2" (lemma "image_subset[variable, variable]") (("2" (inst? -1) (("2" (assert) (("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "Y") (("2" (prop) (("2" (lemma "vars_not_ac_unif_prb_mem2") (("2" (inst -1 "Y" "_") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t1") (("2" (hide -2) (("2" (flatten) (("2" (reveal -18) (("2" (replace -1 -5 :dir rl) (("2" (hide -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (hide -1 -2 -3 -4 -5) (("2" (hide -4) (("2" (case "no_var_pair?(append(input`1, input`2))") (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) (("1" (flatten) (("1" (case "idempotent?(input`3)") (("1" (reveal -4 -5) (("1" (hide -6) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "member_unif_prb_append") (("1" (inst? -1) (("1" (assert) (("1" (hide -3) (("1" (lemma "member_unif_prb_append") (("1" (inst? -1) (("1" (case "member(t1, apply_sub(delta, cdr(unseen_unif_prb))) OR member(t1, apply_sub(delta, seen_unif_prb))") (("1" (hide -2 -3) (("1" (case "EXISTS t: member(t, subterms(append(unseen_unif_prb, seen_unif_prb))) AND t1 = subs(input`3)(t)") (("1" (skolem -1 "t2") (("1" (hide -2) (("1" (prop) (("1" (reveal -12) (("1" (rewrite "append_null") (("1" (replace -1) (("1" (hide -1) (("1" (replace -2 -4) (("1" (lemma "vars_not_ac_var_subs2") (("1" (inst? -1) (("1" (inst -1 "Y") (("1" (assert) (("1" (expand "vars_not_ac_var" -1 1) (("1" (expand "member" -1 1) (("1" (prop) (("1" (skeep) (("1" (expand "member" 3) (("1" (expand "image" 3) (("1" (inst 3 "X") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "subterms_mem_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t2S") (("2" (prop) (("2" (lemma "vars_not_ac_var_subterms") (("2" (inst -1 "X" "t2" "t2S") (("2" (assert) (("2" (expand "vars_not_ac_var" -1) (("2" (expand "member" -1 1) (("2" (prop) (("2" (lemma "vars_not_ac_unif_prb_mem2") (("2" (inst? -1) (("2" (hide -7 -8 -10) (("2" (inst -1 "X") (("2" (expand "member" -1 1) (("2" (hide 2 3 4 5) (("2" (inst 1 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -12 -36) (("2" (lemma "instantiate_step_mem") (("2" (replace -3 :dir rl) (("2" (hide -3) (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (prop) (("2" (lemma "inst_step_vars_not_ac_var_sub_unif_prb") (("2" (hide -10 -11 -7) (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (replace -4 :dir rl) (("2" (assert) (("2" (skolem -1 "X") (("2" (prop) (("2" (expand "member" 3) (("2" (expand "image" 3) (("2" (inst 3 "X") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -44) (("2" (lemma "vars_not_ac_var_solve_ac") (("2" (replace -2 -5 :dir rl) (("2" (inst? -1) (("2" (inst -1 "X") (("2" (assert) (("2" (reveal -49 -50) (("2" (reveal -51) (("2" (expand "vars_not_ac_var" -4) (("2" (expand "union" -4) (("2" (expand "member" -4) (("2" (prop) (("1" (lemma "vars_not_ac_unif_prb_mem2") (("1" (hide 2 3 -14 -12 -10) (("1" (inst? -1) (("1" (expand "member" -1 1) (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (inst 1 "t") (("1" (expand "member" 1 2) (("1" (expand "vars_not_ac_var" -1) (("1" (expand "member" -1) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -9 -11 -12 -13) (("2" (expand "append" 1) (("2" (expand "vars_not_ac" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "vars_not_ac" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (assert) (("2" (prop) (("2" (expand "vars_not_ac_var" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (reveal -11) (("2" (rewrite "append_null") (("2" (replace -1) (("2" (hide -1) (("2" (prop) (("1" (lemma "apply_sub_mem") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "t2") (("1" (inst 1 "t2") (("1" (prop) (("1" (lemma "subterms_mem_unif_prb") (("1" (inst? -1) (("1" (assert) (("1" (inst 1 "t2") (("1" (prop) (("1" (lemma "subterm_reflexive") (("1" (inst? -1) (("1" (assert) (("1" (reveal -44) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t2") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_sub_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t2") (("2" (prop) (("2" (inst 1 "t2") (("2" (prop) (("2" (lemma "subterms_mem_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (hide 2) (("2" (inst 1 "t2") (("2" (rewrite "member_unif_prb_append") (("2" (lemma "subterm_reflexive") (("2" (inst? -1) (("2" (assert) (("2" (reveal -45) (("2" (expand "no_var_pair?" -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "member(t1, unif_prb1)") (("1" (hide -2 -3 1) (("1" (lemma "instantiate_step_mem") (("1" (reveal -8 -32) (("1" (replace -2 -1 :dir rl) (("1" (inst? -3) (("1" (assert) (("1" (skolem -3 "unif_prb2") (("1" (flatten) (("1" (lemma "instantiate_step1_mem") (("1" (inst? -1) (("1" (inst -1 "t1") (("1" (assert) (("1" (assert) (("1" (skolem -1 "t2") (("1" (replace -6 :dir rl) (("1" (flatten) (("1" (replace -2 -10) (("1" (lemma "vars_not_ac_var_subs2") (("1" (inst? -1) (("1" (reveal -15) (("1" (rewrite "append_null") (("1" (replace -1) (("1" (hide -1) (("1" (inst -1 "Y") (("1" (prop) (("1" (skeep) (("1" (expand "member" 4) (("1" (expand "image" 4) (("1" (inst 4 "X") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_var_solve_ac") (("2" (hide -7 -5 -13 -14 -11 -9) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst -1 "X" "unif_prb2") (("2" (assert) (("2" (flatten) (("2" (hide -1) (("2" (reveal -47) (("2" (inst? -3) (("2" (inst -3 "X" "unif_prb2") (("2" (assert) (("2" (split -3) (("1" (hide -3) (("1" (reveal -53 -54 -55) (("1" (expand "append" 1) (("1" (expand "vars_not_ac" 1) (("1" (expand "union" 1) (("1" (prop) (("1" (expand "vars_not_ac_var" -4) (("1" (expand "member" -4) (("1" (expand "union" -4) (("1" (expand "vars_not_ac_var" -4) (("1" (expand "vars_not_ac" 1 1) (("1" (expand "member" 1) (("1" (expand "union" 1) (("1" (prop) (("1" (expand "member" -1 1) (("1" (assert) nil nil)) nil) ("2" (expand "member" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst 2 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -11 -12 -9) (("2" (lemma "inst_step_vars_not_ac_var_sub_unif_prb") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (replace -9 :dir rl) (("2" (assert) (("2" (skeep) (("2" (expand "member" 4) (("2" (expand "image" 4) (("2" (inst 4 "X") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -45) (("2" (lemma "vars_not_ac_var_solve_ac") (("2" (inst? -1) (("2" (inst -1 "X" "unif_prb2") (("2" (assert) (("2" (reveal -50 -51 -52) (("2" (hide -5 -6 -7 -8 -9 -10 -11) (("2" (lemma "vars_not_ac_unif_prb_mem2") (("2" (expand "vars_not_ac_var" -5) (("2" (expand "union" -5) (("2" (expand "member" -5 1) (("2" (prop) (("1" (inst? -2) (("1" (inst -2 "X") (("1" (expand "member" -2 1) (("1" (hide 2) (("1" (inst 1 "t") (("1" (expand "vars_not_ac_var" -1) (("1" (expand "member" -1 1) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "append" 2) (("1" (expand "member" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -2) (("2" (inst -2 "X") (("2" (expand "member" -2 1) (("2" (inst 1 "s") (("2" (expand "vars_not_ac_var" -1) (("2" (expand "member" -1 1) (("2" (flatten) (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "vars_not_ac_var" 1) (("3" (expand "member" 1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (rewrite "append_null") (("2" (replace -1) (("2" (hide 4) (("2" (reveal -3 -27) (("2" (replace -2 :dir rl) (("2" (lemma "instantiate_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (prop) (("2" (lemma "instantiate_step_idempotent") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 2) (("2" (expand "no_var_pair?" 1) (("2" (skolem 1 "t2") (("2" (flatten) (("2" (rewrite "member_unif_prb_append") (("2" (split -1) (("1" (reveal -7) (("1" (replace -1 -2) (("1" (hide -1) (("1" (reveal -38) (("1" (lemma "apply_sub_no_var_pair") (("1" (inst -1 "delta" "unseen_unif_prb") (("1" (assert) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t2") (("1" (split -1) (("1" (propax) nil nil) ("2" (expand "apply_sub" 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (replace -1 -2) (("2" (rewrite "member_unif_prb_append") (("2" (hide -1) (("2" (split -1) (("1" (reveal -6 -30 -32) (("1" (case "no_var_pair?(unif_prb1)") (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t2") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -2 -1 :dir rl) (("2" (hide -2) (("2" (lemma "instantiate_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (flatten) (("2" (hide 2) (("2" (replace -5 -1 :dir rl) (("2" (lemma "instantiate_step_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -39) (("2" (lemma "apply_sub_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (expand "no_var_pair?" -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -9) (("2" (hide 4) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (replace -2) (("2" (hide -6 -7) (("2" (lemma "apply_sub_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (hide 2) (("2" (reveal -22) (("2" (expand "no_var_pair?" 1) (("2" (skeep) (("2" (expand "no_var_pair?" -1) (("2" (inst -1 "t!1") (("2" (expand "member" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "input_apply_ac_step_mem") (("3" (reveal -9) (("3" (replace -1 -4 :dir rl) (("3" (hide -1) (("3" (inst? -1) (("3" (assert) (("3" (skeep) (("3" (replace -3) (("3" (hide 4 -6 -7) (("3" (reveal -13) (("3" (replace -1 :dir rl) (("3" (lemma "instantiate_step_mem") (("3" (inst? -1) (("3" (assert) (("3" (skolem -1 "unif_prb2") (("3" (prop) (("3" (expand "no_var_pair?" 1) (("3" (skolem 1 "t1") (("3" (flatten) (("3" (lemma "member_unif_prb_append") (("3" (inst? -1) (("3" (assert) (("3" (split -1) (("1" (case "no_var_pair?(unif_prb1)") (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "instantiate_step_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (hide -7 -8 -9 -10 -11) (("2" (reveal -23) (("2" (replace -1 -3 :dir rl) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -24) (("2" (lemma "apply_sub_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (expand "no_var_pair?" -1) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (replace -2 1) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (apply_sub_len formula-decl nil unification nil) (vars_not_ac_unif_prb_mem2 formula-decl nil termination_alg nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (subs const-decl "term" substitution nil) (instantiate_step_idempotent formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (X skolem-const-decl "variable" termination_alg nil) (vars_not_ac_var_unif_prb formula-decl nil termination_alg nil) (X skolem-const-decl "variable" termination_alg nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_mem formula-decl nil unification nil) (subterm_reflexive formula-decl nil term_properties nil) (append_null formula-decl nil list_props nil) (vars_not_ac_var_subs2 formula-decl nil termination_alg nil) (vars_not_ac_var const-decl "finite_set[variable]" termination_alg nil) (X skolem-const-decl "variable" termination_alg nil) (mimic_var_cor formula-decl nil termination_alg nil) (vars_not_ac_var_subterms formula-decl nil termination_alg nil) (subterms_mem_unif_prb formula-decl nil unification nil) (instantiate_step_mem formula-decl nil aux_unification nil) (X skolem-const-decl "variable" termination_alg nil) (vars_not_ac_var_solve_ac formula-decl nil termination_alg nil) (vars_not_ac const-decl "finite_set[variable]" termination_alg nil) (vars_not_ac_var const-decl "finite_set[variable]" termination_alg nil) (inst_step_vars_not_ac_var_sub_unif_prb formula-decl nil termination_alg nil) (subs def-decl "term" substitution nil) (subterms def-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (member_unif_prb_append formula-decl nil unification nil) (idempotent? const-decl "bool" substitution nil) (apply_sub_no_var_pair formula-decl nil unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (instantiate_step_no_var_pair formula-decl nil aux_unification nil) (image_subset formula-decl nil function_image nil) (image_composition formula-decl nil function_props nil) (mimic_var_append formula-decl nil termination_alg nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (vars def-decl "finite_set[variable]" unification nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (x_1 skolem-const-decl "(vars_not_ac(append(cdr(unseen_unif_prb), seen_unif_prb)))" termination_alg nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (unseen_unif_prb skolem-const-decl "list[unif_pair]" termination_alg nil) (seen_unif_prb skolem-const-decl "unif_prb" termination_alg nil) (Y skolem-const-decl "variable" termination_alg nil) (union const-decl "set" sets nil) (vars_not_ac_unif_prb_append formula-decl nil termination_alg nil) (member const-decl "bool" sets nil) (append def-decl "list[T]" list_props nil) (mimic_var def-decl "variable" termination_alg nil) (image const-decl "set[R]" function_image nil) (vars_not_ac def-decl "finite_set[variable]" termination_alg nil) (subset? const-decl "bool" sets nil) (no_var_pair? const-decl "bool" unification nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" term_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("termination_alg" termination_alg apply_ac_vars_under2more 0 (apply_ac_vars_under2more-1 nil 3850079855 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (assert) (("1" (case "ac_sol`1 = seen_unif_prb") (("1" (replace -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "Y") (("1" (prop) (("1" (expand "vars_under2more" -6) (("1" (expand "member" -6) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "Y") (("1" (expand "mimic_var" 1) (("1" (propax) nil nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (skolem -6 ("t" "s")) (("2" (inst 1 "t" "s") (("2" (flatten) (("2" (assert) (("2" (prop) (("1" (lemma "subterms_append") (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_append") (("2" (prop) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -1) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -3 -2 -4 -5) (("1" (expand "subset?") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "image") (("1" (expand "member" 2) (("1" (expand "member" -1) (("1" (skeep) (("1" (inst 2 "x_1") (("1" (typepred "x_1") (("1" (expand "append" 1) (("1" (expand "vars_under2more" -1) (("1" (skeep) (("1" (expand "vars_under2more" 1) (("1" (inst 1 "t" "s") (("1" (assert) (("1" (expand "subterms" 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_var_pair?") (("2" (skeep) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" -5) (("2" (expand "member" -5 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (split) (("1" (prop) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst") (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 ("unif_prb1" "sigma")) (("2" (flatten) (("2" (rewrite "append_null") (("2" (hide -1 -2 -3 -4 -5 -6) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (flatten) (("2" (replace -2 3) (("2" (hide -2 -3 -4) (("2" (reveal -21) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst? -1) (("1" (case "no_var_pair?(append(input`1, input`2))") (("1" (assert) (("1" (case "subset?(image(mimic_var(ac_sol1`2), vars_under2more(append(input`1, input`2))),
                                                                       image(mimic_var(ac_sol`2), vars_under2more(append(unseen_unif_prb, seen_unif_prb))))") (("1" (expand "subset?" 3) (("1" (skeep) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -3) (("2" (replace -1) (("2" (hide 4) (("2" (hide -5 -6 -7 -2) (("2" (lemma "mimic_var_append") (("2" (inst? -1) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "image_composition[variable, variable, variable]") (("2" (inst? -1) (("2" (rewrite "image_composition" :dir rl) (("2" (rewrite "image_subset") (("2" (hide 2) (("2" (hide -1 -2 -3) (("2" (expand "subset?" 1) (("2" (skolem 1 "Y") (("2" (prop) (("2" (expand "vars_under2more" -1 1) (("2" (expand "member" -1 1) (("2" (skolem -1 ("t1" "s1")) (("2" (flatten) (("2" (reveal -15 -23) (("2" (lemma "instantiate_step_mem2") (("2" (replace -3 -2 :dir rl) (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (prop) (("2" (hide 1) (("2" (hide -1 -2 -3) (("2" (name-replace "unif_prb05" "append(cdr(unseen_unif_prb), append(unif_prbC, seen_unif_prb))") (("2" (reveal -3) (("2" (case "idempotent?(sigma)") (("1" (case "subset?(subterms(append(input`1, input`2)), subterms(apply_sub(sigma, unif_prb05)))") (("1" (case "EXISTS t: (member(t, subterms(unif_prb05)) AND same_func?(t, t1) AND (EXISTS X: subs(sigma)(X) = variable(Y) AND im_under?(X, t)))") (("1" (case "EXISTS s: (member(s, subterms(unif_prb05)) AND same_func?(s, s1) AND (EXISTS X: subs(sigma)(X) = variable(Y) AND im_under?(X, s)))") (("1" (hide -9 -10 -11 -12 -13) (("1" (skolem -1 "s2") (("1" (prop) (("1" (skolem -3 "X2") (("1" (skolem -4 "t2") (("1" (prop) (("1" (skolem -7 "X1") (("1" (case "subs(sigma)(Y) = variable(Y)") (("1" (name-replace "unif_prb" "append(unseen_unif_prb, seen_unif_prb)") (("1" (case "FORALL t1: dif_func?(t1, t) AND member(t1, subterms(unif_prb05)) IMPLIES member(t1, subterms(unif_prb))") (("1" (hide -1 -2) (("1" (reveal -30) (("1" (replace -1) (("1" (hide -1) (("1" (case "X1 = Y AND X2 = Y") (("1" (flatten) (("1" (hide -15 -16 -14) (("1" (case "same_func?(t2, t)") (("1" (case "dif_func?(s2, t)") (("1" (hide -2) (("1" (reveal -4) (("1" (inst -1 "s2") (("1" (assert) (("1" (case "member(t2, subterms(unif_prb))") (("1" (replace -4) (("1" (replace -5) (("1" (hide-all-but (-1 -2 1 -12)) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "Y") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "s2") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (reveal -7 -10 -20) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s1" "s2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym") (("2" (rewrite "dif_func_sym") (("2" (rewrite "dif_func_sym" -3) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s1" "t1" "t2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 1)) (("2" (expand "unif_prb") (("2" (expand "unif_prb05") (("2" (rewrite "subterms_append") (("2" (prop) (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "subterms" 1) (("1" (expand ("member" "union") 1) (("1" (prop) nil nil)) nil)) nil) ("2" (reveal -25 -53) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars_vars2avoid") (("2" (reveal -3 -11) (("2" (replace -1) (("2" (hide -1) (("2" (inst? -2) (("2" (inst -2 "Y" "t2") (("2" (use "im_under_var") (("2" (assert) (("2" (hide -1 -2) (("2" (prop) (("1" (hide-all-but 1) (("1" (reveal -11 -15) (("1" (replace -1) (("1" (hide -1) (("1" (reveal -8) (("1" (use "im_under_var") (("1" (assert) (("1" (hide -3) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -2 "s2S") (("1" (flatten) (("1" (expand "unif_prb") (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (lemma "vars_subterm") (("1" (inst -1 "Y" "s2" "s2S") (("1" (assert) (("1" (hide -2 -3) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "s2S") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (reveal -63 -64 -65) (("2" (expand "subterms" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "dif_func?(t2, s2)") (("1" (lemma "cond_dif_func") (("1" (inst -1 "s2" "t2" "t") (("1" (assert) (("1" (rewrite "dif_func_sym") nil nil)) nil)) nil)) nil) ("2" (reveal -8 -4 -18) (("2" (hide -4 2) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s1" "s2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym" 1) (("2" (hide -1) (("2" (lemma "cond_dif_func") (("2" (rewrite "dif_func_sym" 1) (("2" (inst -1 "s1" "t1" "t2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym" 1) (("2" (rewrite "dif_func_sym" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dif_func?(t2, t)") (("1" (hide-all-but (-1 -8)) (("1" (reveal -14) (("1" (inst -1 "t2") (("1" (assert) (("1" (hide -3) (("1" (case "member(s2, subterms(unif_prb))") (("1" (reveal -2 -3 -7 -10) (("1" (reveal 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (inst 1 "Y") (("1" (reveal -9 -2) (("1" (replace -1) (("1" (lemma "mimic_var_cor") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "s2") (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -10 -13 -23) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s1" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") (("2" (hide 2) (("2" (rewrite "dif_func_sym") (("2" (lemma "cond_dif_func") (("2" (inst? -1) (("2" (inst -1 "t1") (("2" (assert) (("2" (rewrite "same_func_sym") (("2" (rewrite "dif_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (reveal -6) (("2" (expand "unif_prb05") (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "subterms" 1) (("1" (expand ("member" "union") 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (reveal -5 -9 -25 -53) (("2" (replace -4 :dir rl) (("2" (hide -4) (("2" (lemma "solve_ac_vars_vars2avoid") (("2" (replace -2) (("2" (hide -2) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -3) (("2" (inst? -2) (("2" (inst -2 "Y" "s2") (("2" (assert) (("2" (prop) (("1" (hide -2 -3 2) (("1" (reveal -7 -10 -18) (("1" (hide -4) (("1" (replace -2) (("1" (hide -2) (("1" (use "im_under_var") (("1" (assert) (("1" (hide -3) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -2 "t2S") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst -1 "Y" "t2" "t2S") (("1" (prop) (("1" (hide -3 -2) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (prop) (("1" (expand "unif_prb") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (reveal -65 -64 -63) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (case "func?(t)") (("1" (reveal -8) (("1" (expand "same_func?") (("1" (flatten) (("1" (hide -2 -3) (("1" (expand "dif_func?") (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -56 -55 -34) (("2" (hide 2 3) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (assert) (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (replace -2) (("2" (expand "func?" 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "X1 = Y AND X2 /= Y") (("1" (flatten) (("1" (hide 2) (("1" (hide -10 -11 -12 -13 -14 -15) (("1" (reveal -15) (("1" (replace -1 -5) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X2" "Y" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (prop) (("1" (replace -4) (("1" (hide -4 -11) (("1" (hide -5 -9) (("1" (lemma "member_lhs_rhs") (("1" (inst -1 "variable(Y)" "unif_prbC") (("1" (assert) (("1" (prop) (("1" (hide -3) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (hide-all-but (-1 -2 2)) (("1" (reveal -26 -54) (("1" (replace -2 -1 :dir rl) (("1" (hide -2) (("1" (inst?) (("1" (assert) (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (skolem -4 "t3") (("1" (flatten) (("1" (hide -1 -2 -5) (("1" (case "dif_func?(t2, t3)") (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "Y") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 1 :dir rl) (("1" (reveal -24) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "t3") (("2" (reveal -10) (("2" (assert) (("2" (prop) (("1" (reveal -9 -22) (("1" (inst -2 "t2") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (reveal -4 -5 -6) (("1" (lemma "cond_dif_func") (("1" (inst -1 "t2" "t3" "t") (("1" (assert) (("1" (hide -4 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "unif_prb") (("2" (reveal -5 -6 -7 -65 -66 -67) (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2 3) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -6) (("2" (hide -6) (("2" (replace -5) (("2" (replace -4) (("2" (hide -4 -5) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "is_ac_sym?") (("2" (replace -1) (("2" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(t2, t3)") (("1" (hide 1) (("1" (case "same_func?(t3, t)") (("1" (case "dif_func?(s2, t)") (("1" (hide -2 -3) (("1" (reveal -24) (("1" (inst -1 "s2") (("1" (assert) (("1" (hide -4 -5) (("1" (reveal -12) (("1" (lemma "im_under_var") (("1" (inst?) (("1" (assert) (("1" (hide -2) (("1" (reveal -10) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "X2") (("1" (assert) (("1" (skolem -1 "s3") (("1" (flatten) (("1" (case "dif_func?(s2, s3)") (("1" (hide -3) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X2") (("1" (lemma "mimic_var_cor") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (reveal -16 -41) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "s2" "s3") (("2" (assert) (("2" (hide-all-but 1) (("2" (expand "unif_prb") (("2" (reveal -8 -77 -76 -75) (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (flatten) (("2" (replace -4) (("2" (hide 2 3) (("2" (expand "subterms" 1) (("2" (replace -2) (("2" (replace -3) (("2" (hide -2 -3) (("2" (hide -2) (("2" (expand "member" 1) (("2" (expand "union") (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (reveal -16) (("1" (expand "is_ac_sym?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (reveal -15) (("2" (expand "is_ac_sym?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t" "s3") (("2" (assert) (("2" (hide -1 2) (("2" (reveal -4 -15 -16) (("2" (expand "is_ac_sym?") (("2" (expand "same_func?" 1) (("2" (expand "func?" 1) (("2" (assert) (("2" (prop) (("1" (assert) (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "sym" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X2") (("2" (assert) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (hide -5) (("2" (expand "cur_vars2avoid" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (hide 2 4) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "s2S") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s2S") (("1" (assert) (("1" (lemma "vars_subterm") (("1" (inst -1 "X2" "s2" "s2S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4 1) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "s2S") (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "s2S") (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst -1 "X2" "s2" "s2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (reveal -17 -18 -28) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t1" "t") (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (lemma "cond_dif_func") (("1" (rewrite "same_func_sym" -2) (("1" (inst -1 "t1" "s1" "s2") (("1" (assert) (("1" (rewrite "dif_func_sym" -1) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3) (("2" (rewrite "same_func_sym" -1) (("2" (lemma "same_func_trans") (("2" (inst -1 "t2" "t1" "t3") (("2" (assert) (("2" (hide -2 -4) (("2" (lemma "same_func_trans") (("2" (inst -1 "t3" "t1" "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -5 -6 -7) (("2" (expand "is_ac_sym?") (("2" (prop) (("1" (expand "same_func?") (("1" (assert) (("1" (expand "func?" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "same_func?" 1) (("2" (assert) (("2" (replace -1) (("2" (expand "func?" 1) (("2" (expand "ord") (("2" (expand "sym") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 3) (("2" (reveal -12) (("2" (use "im_under_implies_func") (("2" (assert) (("2" (hide -2) (("2" (use "im_under_implies_func") (("2" (assert) (("2" (hide -3) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 2) (("2" (reveal -41 -61 -62 -63) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (replace -2) (("2" (replace -3) (("2" (expand "is_ac_sym?" 1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "is_ac_sym?" 1) (("2" (reveal -62 -63 -41) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_rhs_not_id") (("2" (inst -1 "Y" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (reveal 2) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (lemma "solve_ac_disjoint_lhs_rhs") (("2" (reveal -26 -54) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "variable(Y)") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (rewrite "mem_lst2set") (("1" (rewrite "mem_lst2set") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid") (("2" (hide -1 -2 -3) (("2" (reveal -61 -62 -63) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_lst2set") (("2" (hide 2) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "union" 1 1) (("2" (expand "member" 1 1) (("2" (prop) (("2" (hide 2) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "X1 /= Y AND X2 = Y") (("1" (hide 1 2) (("1" (flatten) (("1" (replace -1) (("1" (hide 1) (("1" (hide -1) (("1" (hide-all-but -7) (("1" (reveal -22 4) (("1" (replace -1) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X1" "Y" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (prop) (("1" (case "member(variable(Y), lhs(unif_prbC))") (("1" (hide -2 -3 -4 -5 1) (("1" (reveal -24 -52) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "Y" "unif_prbC") (("1" (assert) (("1" (case "same_func?(t, s)") (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (skolem -4 "t3") (("1" (flatten) (("1" (hide -5) (("1" (case "dif_func?(s2, t3)") (("1" (reveal -19) (("1" (reveal -8) (("1" (inst -2 "s2") (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (reveal 1) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "Y") (("1" (lemma "mimic_var_cor") (("1" (reveal -20) (("1" (inst?) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more") (("2" (inst 1 "s2" "t3") (("2" (assert) (("2" (reveal -10) (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -5 -8 -65 -66 -67) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -5) (("2" (expand "subterms" 1) (("2" (replace -3) (("2" (replace -4) (("2" (hide 2 3) (("2" (expand ("member" "union") 1) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "same_func?" -3) (("1" (expand "func?" -3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "same_func?" -3) (("2" (expand "func?" -3) (("2" (flatten) (("2" (prop) (("1" (hide 1 2) (("1" (expand "ord") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "ord") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (hide-all-but (-3 -6 1)) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "s" "t") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3) (("2" (case "same_func?(s2, t3)") (("1" (case "dif_func?(t2, t)") (("1" (hide-all-but -1) (("1" (reveal -25 -17) (("1" (inst -2 "t2") (("1" (assert) (("1" (hide -1) (("1" (reveal -10) (("1" (case "member(variable(X1), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (hide -3) (("1" (reveal -33 -61) (("1" (inst?) (("1" (inst -3 "X1" "unif_prbC") (("1" (assert) (("1" (skolem -3 "s3") (("1" (flatten) (("1" (hide -4) (("1" (reveal -20) (("1" (hide -2 -3 -5) (("1" (reveal 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X1") (("1" (reveal -14 -37) (("1" (replace -2 :dir rl) (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more") (("2" (inst 1 "t2" "s3") (("2" (assert) (("2" (prop) (("1" (hide -1 -2 -3) (("1" (reveal -4 -10) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -5 -9 -10 -69 -70 -71) (("2" (expand "unif_prb") (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "s3") (("2" (split 1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?" -3) (("1" (expand "is_ac_sym?" -4) (("1" (assert) (("1" (flatten) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 1) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (prop) (("2" (hide 1) (("2" (reveal -33 -61) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X1") (("2" (assert) (("2" (hide -1 -2 -3 -4) (("2" (reveal -25 -3) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -3) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "t2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t2" "t2S") (("2" (assert) (("2" (hide -2 -3) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand "unif_prb") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 2) (("2" (reveal -5 -6) (("2" (case "same_func?(s2, t)") (("1" (hide -2 -3 -4) (("1" (lemma "cond_dif_func") (("1" (inst -1 "t2" "s2" "t") (("1" (assert) (("1" (hide 2) (("1" (hide -1) (("1" (reveal -17 -20 -30) (("1" (lemma "cond_dif_func") (("1" (inst -1 "t2" "s1" "s2") (("1" (assert) (("1" (rewrite "same_func_sym") (("1" (hide 2 -1) (("1" (lemma "cond_dif_func") (("1" (rewrite "dif_func_sym") (("1" (inst -1 "s1" "t1" "t2") (("1" (assert) (("1" (rewrite "same_func_sym") (("1" (rewrite "dif_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (rewrite "same_func_sym" -2) (("2" (lemma "same_func_trans") (("2" (inst -1 "s" "s2" "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4) (("2" (reveal -5 -6 -14) (("2" (expand "dif_func?") (("2" (expand "same_func?") (("2" (flatten) (("2" (split -4) (("1" (replace -1) (("1" (prop) nil nil)) nil) ("2" (replace -1) (("2" (prop) (("1" (hide-all-but (-2 -3 1)) (("1" (expand "func?") (("1" (expand "ord") (("1" (smash) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 1)) (("2" (expand "ord") (("2" (expand "func?") (("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (expand "is_ac_sym?") (("2" (expand "same_func?") (("2" (assert) (("2" (flatten) (("2" (expand "sym") (("2" (expand "ord") (("2" (assert) (("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -40 -62 -61) (("2" (expand "is_ac_sym?") (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "member") (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -39 -59 -60 -61) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member") (("2" (assert) (("2" (expand "ac_prb?") (("2" (replace -3) (("2" (replace -2) (("2" (expand "same_func?" 1) (("2" (flatten) (("2" (expand "func?" 1) (("2" (assert) (("2" (expand "sym" 1) (("2" (expand "ord" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -2) (("2" (prop) (("2" (hide 1) (("2" (lemma "instantiate_step_rhs_not_id") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (reveal 1 8) (("2" (assert) (("2" (reveal -15) (("2" (replace -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "X1 /= Y AND X2 /= Y") (("1" (hide 1 2 3) (("1" (flatten) (("1" (hide 1 2 -9 -12 -13 -14) (("1" (hide -1 -2 -3 -4) (("1" (hide -2 2) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X1" "Y" "unif_prbC") (("1" (replace -6 -3) (("1" (assert) (("1" (assert) (("1" (reveal 2) (("1" (assert) (("1" (hide 1) (("1" (prop) (("1" (case "member(variable(Y), lhs(unif_prbC))") (("1" (hide-all-but -1) (("1" (reveal -24 -52) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "Y") (("1" (assert) (("1" (case "same_func?(t, s)") (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (hide -1 -2 -3) (("1" (skolem -1 "t'") (("1" (flatten) (("1" (case "same_func?(t', t)") (("1" (hide -3 -1) (("1" (case "dif_func?(t2, t)") (("1" (reveal -10 -12 -8) (("1" (hide -5 -7) (("1" (reveal -25) (("1" (inst -1 "t2") (("1" (assert) (("1" (hide -3) (("1" (lemma "im_under_var") (("1" (inst? -1) (("1" (assert) (("1" (hide -4) (("1" (case "member(variable(X1), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "t3") (("1" (flatten) (("1" (hide -2) (("1" (reveal -15 -37) (("1" (reveal 1) (("1" (hide -9) (("1" (replace -2 :dir rl) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X1") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "t3") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-8 1)) (("1" (reveal -7) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (reveal -15) (("2" (replace -2) (("2" (hide -2) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -8 -73 -74 -75) (("2" (expand "unif_prb") (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t3") (("2" (split 1) (("1" (rewrite "subterm_reflexive") (("1" (reveal -16) (("1" (prop) (("1" (expand "same_func?" -2) (("1" (assert) (("1" (flatten) (("1" (expand "func?" -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (reveal -15) (("2" (expand "is_ac_sym?" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append" 1) (("2" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil) ("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (prop) (("2" (hide 1) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X1") (("2" (assert) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (case "member(X1, vars(unif_prb))") (("1" (expand "unif_prb") (("1" (rewrite "vars_unif_prb" -1) (("1" (skolem -1 "t3") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t3") (("1" (prop) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4 -5) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -3 "t2S") (("2" (prop) (("2" (rewrite "vars_unif_prb" 1) (("2" (inst 1 "t2S") (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst? -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -1) (("2" (reveal -20 -35) (("2" (replace -2) (("2" (lemma "instantiate_step_var_member") (("2" (inst -1 "X2" "Y" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (reveal 5) (("2" (assert) (("2" (prop) (("2" (hide 1) (("2" (hide -2) (("2" (case "same_func?(t2, t)") (("1" (hide 1) (("1" (case "dif_func?(s2, t)") (("1" (hide -2) (("1" (hide -3 -4) (("1" (reveal -20 -27) (("1" (inst -2 "s2") (("1" (assert) (("1" (reveal -23) (("1" (use "im_under_var") (("1" (assert) (("1" (hide -2) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst?) (("1" (inst -1 "X2") (("1" (assert) (("1" (skolem -1 "s3") (("1" (flatten) (("1" (hide -2) (("1" (reveal -25 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X2") (("1" (reveal -3 -39) (("1" (replace -2) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "s2" "s3") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-7 1)) (("1" (reveal -6 -16) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -7 -74 -75 -76) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (flatten) (("2" (hide 2 3) (("2" (replace -4) (("2" (hide -4) (("2" (expand "subterms" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (replace -2) (("2" (replace -3) (("2" (flatten) (("2" (hide -2 -3) (("2" (reveal -15 -16) (("2" (expand "is_ac_sym?") (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") nil nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X2") (("2" (assert) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (hide -6) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide -3) (("2" (expand "member" 2 1) (("2" (prop) (("2" (hide 2) (("2" (expand "unif_prb") (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -3 "s2S") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (lemma "vars_subterm") (("2" (inst -1 "X2" "s2" "s2S") (("2" (assert) (("2" (inst 1 "s2S") (("2" (inst 2 "s2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(s2, t)") (("1" (hide-all-but (-1 -2)) (("1" (reveal -20 -22 -31) (("1" (lemma "same_func_trans") (("1" (inst -1 "t" "s2" "t2") (("1" (assert) (("1" (rewrite "same_func_sym" -1) (("1" (hide -5 -6) (("1" (case "same_func?(t1, s1)") (("1" (hide -2 -3 -4) (("1" (expand "same_func?") (("1" (expand "dif_func?") (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (rewrite "same_func_sym" -2) (("2" (rewrite "same_func_sym" -1) (("2" (lemma "same_func_trans") (("2" (inst -1 "t2" "t1" "s2") (("2" (assert) (("2" (hide -2 -3) (("2" (lemma "same_func_trans") (("2" (inst -1 "s2" "t1" "s1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (reveal -11 -23) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4) (("2" (reveal -10 -20) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (flatten) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4) (("2" (prop) (("1" (expand "same_func?") (("1" (expand "func?") (("1" (assert) (("1" (reveal -4) (("1" (expand "is_ac_sym?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -6) (("2" (replace -2) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -62 -63 -64 -42) (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "member") (("2" (assert) (("2" (hide -4) (("2" (expand "ac_prb?") (("2" (replace -2) (("2" (replace -3) (("2" (hide -2 -3) (("2" (expand "is_ac_sym?") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "is_ac_sym?" 1) (("2" (reveal -62 -63 -41) (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "member") (("2" (assert) (("2" (expand "ac_prb?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3) (("2" (reveal -60 -61 -62 -40) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (assert) (("2" (expand "member") (("2" (expand "same_func?") (("2" (expand "ac_prb?") (("2" (replace -3) (("2" (replace -2) (("2" (hide -2 -3 -4) (("2" (prop) (("1" (expand "func?") (("1" (assert) nil nil)) nil) ("2" (expand "ord") (("2" (assert) nil nil)) nil) ("3" (expand "sym") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -2) (("2" (assert) (("2" (hide 1 -4 -1 2) (("2" (hide -3) (("2" (hide -2) (("2" (lemma "instantiate_step_rhs_not_id") (("2" (reveal -15) (("2" (inst -2 "Y" "unif_prbC") (("2" (assert) (("2" (reveal 9) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2 3 4)) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -2 -3 -4 -5 -6 -7 -8 -9) (("2" (skolem 1 "t'") (("2" (prop) (("2" (expand "unif_prb05" -2) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "member" 1) (("1" (expand "subterms" 1) (("1" (expand "union" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2 -3 4 -5 -6 -7) (("2" (hide -3) (("2" (reveal -19 -47) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_func") (("2" (inst? -1) (("2" (inst -1 "t'") (("2" (assert) (("2" (prop) (("1" (hide -2 1 2 -3) (("1" (reveal -34 -54 -55 -56) (("1" (expand "all_ac_prb?" -1) (("1" (inst -1 "unif_pair") (("1" (expand "member" -1) (("1" (assert) (("1" (expand "ac_prb?" -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -2 -3 -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -3) (("2" (assert) nil nil)) nil) ("3" (hide -2 -3) (("3" (reveal -54 -55 -56) (("3" (hide -5) (("3" (expand "subterms" 1) (("3" (expand "union" 1) (("3" (expand "member" 1 1) (("3" (prop) (("3" (replace -3) (("3" (expand "subterms" 1) (("3" (expand ("member" "union") 1) (("3" (replace -1) (("3" (replace -2) (("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -3 -4) (("2" (hide 2) (("2" (hide-all-but (-1 -2 -11 -10)) (("2" (hide -2) (("2" (reveal -14 1) (("2" (expand "subset?" -3) (("2" (inst -3 "s1") (("2" (assert) (("2" (hide -1) (("2" (use "apply_sub_subterms") (("2" (assert) (("2" (hide -3) (("2" (prop) (("1" (skolem -1 "s1S") (("1" (prop) (("1" (lemma "im_under_var") (("1" (inst? -1) (("1" (assert) (("1" (hide -4) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t2") (("1" (inst -1 "Y" "sigma" "s1S") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "dom" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst? -1) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "Y") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (prop) (("1" (expand "dom" 1) (("1" (expand "member" 1) (("1" (flatten) nil nil)) nil)) nil) ("2" (rewrite "subterm_fin_set") (("2" (skolem -1 "s1S") (("2" (prop) (("2" (rewrite "vars_finset") (("2" (inst?) (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst -1 "Y" "s1" "s1S") (("2" (assert) (("2" (use "im_under_var") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "subset?" -1) (("2" (inst -1 "s1") (("2" (assert) (("2" (hide -8 -10 -11) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "s1'") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "s3") (("2" (prop) (("2" (replace -3 -1) (("2" (lemma "func_subterms_subs") (("2" (inst? -1) (("2" (assert) (("2" (case "member(s1, subterms(img(sigma)))") (("1" (assert) (("1" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step_sub_im_under") (("1" (inst? -1) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (skolem -1 ("X" "s4")) (("1" (prop) (("1" (inst 1 "s4") (("1" (prop) (("1" (replace -11 1 :dir rl) (("1" (rewrite "subterms_append") (("1" (rewrite "subterms_append") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "same_func_sym") nil nil)) nil) ("3" (inst 1 "X") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -18 -46) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (replace -3 :dir rl) (("2" (hide -3) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -10) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skolem -1 "s4") (("1" (flatten) (("1" (replace -2 -13 :dir rl) (("1" (lemma "im_under_subs2") (("1" (inst? -1) (("1" (assert) (("1" (case "no_pair?(img(sigma))") (("1" (assert) (("1" (prop) (("1" (hide 1) (("1" (skeep) (("1" (prop) (("1" (inst 1 "s4") (("1" (assert) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "s3") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "X") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 "s5") (("2" (hide -6 -8 -14 -12) (("2" (prop) (("2" (hide -5) (("2" (replace -10 -1) (("2" (lemma "instantiate_step_sub_im_under") (("2" (inst -1 "X" "s5" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (hide -13 -12 -9) (("2" (prop) (("1" (skolem -1 ("X1" "s6")) (("1" (replace -10 :dir rl) (("1" (prop) (("1" (inst 1 "s6") (("1" (assert) (("1" (prop) (("1" (expand "unif_prb05") (("1" (rewrite "subterms_append") (("1" (prop) (("1" (rewrite "subterms_append") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -7 -4 1)) (("2" (lemma "same_func_trans") (("2" (rewrite "same_func_sym" -2) (("2" (inst -1 "s5" "s6" "s4") (("2" (assert) (("2" (rewrite "same_func_sym" -3) (("2" (assert) (("2" (hide -2 -3) (("2" (lemma "same_func_trans") (("2" (inst -1 "s4" "s6" "s1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "X1") (("3" (assert) (("3" (hide-all-but (-2 -12 -8 1)) (("3" (expand "idempotent?" -3) (("3" (inst -3 "X1") (("3" (replace -3 1 :dir rl) (("3" (replace -1) (("3" (expand "subs" -2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -3)) (("2" (reveal -25) (("2" (rewrite "subterm_reflexive_finset") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -25 -53) (("3" (replace -2 :dir rl) (("3" (hide -2) (("3" (lemma "solve_ac_no_pair") (("3" (inst? -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "same_func?" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 1)) (("2" (lemma "instantiate_step_no_pair_img") (("2" (inst? -1) (("2" (assert) (("2" (hide -1 2) (("2" (reveal -21 -49) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (use "solve_ac_no_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" -1) (("2" (inst -1 "t1") (("2" (assert) (("2" (hide -9 -10 -11) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "t1'") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t3") (("2" (prop) (("2" (replace -3 -1) (("2" (lemma "func_subterms_subs") (("2" (inst? -1) (("2" (assert) (("2" (case "member(t1, subterms(img(sigma)))") (("1" (assert) (("1" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step_sub_im_under") (("1" (inst? -1) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (skolem -1 ("X" "t4")) (("1" (prop) (("1" (inst 1 "t4") (("1" (prop) (("1" (replace -11 1 :dir rl) (("1" (rewrite "subterms_append") (("1" (rewrite "subterms_append") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "same_func_sym") nil nil)) nil) ("3" (inst 1 "X") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -17 -45) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (replace -3 :dir rl) (("2" (hide -3) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -10) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skolem -1 "t4") (("1" (flatten) (("1" (replace -2 -13 :dir rl) (("1" (lemma "im_under_subs2") (("1" (inst? -1) (("1" (assert) (("1" (case "no_pair?(img(sigma))") (("1" (assert) (("1" (prop) (("1" (hide 1) (("1" (skeep) (("1" (prop) (("1" (inst 1 "t4") (("1" (assert) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "t3") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "X") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 "t5") (("2" (hide -6 -8 -14 -12) (("2" (prop) (("2" (hide -5) (("2" (replace -10 -1) (("2" (lemma "instantiate_step_sub_im_under") (("2" (inst -1 "X" "t5" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (hide -13 -12 -9) (("2" (prop) (("1" (skolem -1 ("X1" "t6")) (("1" (replace -10 :dir rl) (("1" (prop) (("1" (inst 1 "t6") (("1" (assert) (("1" (prop) (("1" (expand "unif_prb05") (("1" (rewrite "subterms_append") (("1" (prop) (("1" (rewrite "subterms_append") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -7 -4 1)) (("2" (lemma "same_func_trans") (("2" (rewrite "same_func_sym" -2) (("2" (inst -1 "t5" "t6" "t4") (("2" (assert) (("2" (rewrite "same_func_sym" -3) (("2" (assert) (("2" (hide -2 -3) (("2" (lemma "same_func_trans") (("2" (inst -1 "t4" "t6" "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "X1") (("3" (assert) (("3" (hide-all-but (-2 -12 -8 1)) (("3" (expand "idempotent?" -3) (("3" (inst -3 "X1") (("3" (replace -3 1 :dir rl) (("3" (replace -1) (("3" (expand "subs" -2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -3)) (("2" (reveal -24) (("2" (rewrite "subterm_reflexive_finset") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -24 -52) (("3" (replace -2 :dir rl) (("3" (hide -2) (("3" (lemma "solve_ac_no_pair") (("3" (inst? -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "same_func?" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 1)) (("2" (lemma "instantiate_step_no_pair_img") (("2" (inst? -1) (("2" (assert) (("2" (hide -1 2) (("2" (reveal -20 -48) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (use "solve_ac_no_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "t2") (("2" (prop) (("2" (hide -6 -7 -8 -9 -10 -5) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "t2S") (("2" (flatten) (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t2S") (("2" (assert) (("2" (replace -5 1 :dir rl) (("2" (rewrite "apply_sub_append") (("2" (rewrite "member_unif_prb_append" 1) (("2" (prop) (("2" (rewrite "apply_sub_append") (("2" (rewrite "member_unif_prb_append" 2) (("2" (prop) (("2" (rewrite "member_unif_prb_append" -2) (("2" (prop) (("1" (reveal -25) (("1" (assert) nil nil)) nil) ("2" (reveal -26) (("2" (replace -1) (("2" (rewrite "member_unif_prb_append" -2) (("2" (prop) (("2" (reveal -7) (("2" (lemma "instantiate_step1_mem") (("2" (hide 1 3 -9) (("2" (hide -4 -5) (("2" (inst -1 "t2S" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2S1") (("2" (prop) (("2" (replace -6 :dir rl) (("2" (rewrite "apply_sub_mem") (("2" (inst 2 "t2S1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "instantiate_step_idempotent") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (reveal -8 -9) (("2" (rewrite "no_var_pair_append") (("2" (prop) (("1" (replace -1 1) (("1" (lemma "apply_sub_no_var_pair") (("1" (inst? -1) (("1" (assert) (("1" (rewrite "no_var_pair_append") (("1" (prop) (("1" (hide-all-but (-6 1)) (("1" (expand "no_var_pair?" 1) (("1" (skeep) (("1" (expand "no_var_pair?" -2) (("1" (inst -2 "t!1") (("1" (assert) (("1" (expand "member" -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 1) (("2" (rewrite "no_var_pair_append") (("2" (prop) (("1" (hide-all-but 1) (("1" (reveal -11 -21) (("1" (reveal -19) (("1" (replace -1 :dir rl) (("1" (hide -3) (("1" (lemma "instantiate_step_mem") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (prop) (("1" (lemma "instantiate_step_no_var_pair") (("1" (inst? -1) (("1" (assert) (("1" (reveal -23) (("1" (lemma "solve_ac_no_pair") (("1" (replace -2 -3 :dir rl) (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_sub_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (rewrite "no_var_pair_append" -6) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (replace -1 1) (("2" (rewrite "apply_sub_len") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_image application-judgement "finite_set[R]" function_image_aux nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) nil nil nil (subterms_append formula-decl nil unification nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) nil (NOT const-decl "[bool -> bool]" booleans nil) (union const-decl "set" sets nil) nil nil (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (image_subset formula-decl nil function_image nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) nil (instantiate_step_idempotent formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (dif_func? const-decl "bool" term_properties nil) (/= const-decl "boolean" notequal nil) (instantiate_step_var_member formula-decl nil aux_unification nil) (member_lhs_rhs formula-decl nil unification nil) (instantiate_step_rhs_not_id formula-decl nil aux_unification nil) (solve_ac_disjoint_lhs_rhs formula-decl nil aux_unification nil) (empty? const-decl "bool" sets nil) (lhs const-decl "args" unification nil) (args type-eq-decl nil term_properties nil) (mem_lst2set formula-decl nil list_theory nil) (rhs const-decl "args" unification nil) (intersection const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (ord const-decl "upto(5)" term_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (sym const-decl "string" term_properties nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (subterm_reflexive formula-decl nil term_properties nil) (im_under_implies_func formula-decl nil term_properties nil) (solve_ac_vars_rhs formula-decl nil aux_unification nil) nil (same_func_trans formula-decl nil term_properties nil) (is_ac_sym? const-decl "bool" term_properties nil) (solve_ac_lhs_im_under formula-decl nil aux_unification nil) nil nil nil (mimic_var_cor formula-decl nil termination_alg nil) (cond_dif_func formula-decl nil term_properties nil) (same_func_sym formula-decl nil term_properties nil) (dif_func_sym formula-decl nil term_properties nil) (solve_ac_vars_vars2avoid formula-decl nil aux_unification nil) (im_under_var formula-decl nil term_properties nil) (subterms_mem_unif_prb formula-decl nil unification nil) nil nil (vars_subterm formula-decl nil term_properties nil) (vars_unif_prb formula-decl nil unification nil) (member_unif_prb_append formula-decl nil unification nil) (finset2list_mem formula-decl nil list_theory nil) nil (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil) (func? const-decl "bool" term_properties nil) (solve_ac_func formula-decl nil aux_unification nil) (apply_sub_subterms formula-decl nil unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (vars_finset formula-decl nil term_properties nil) (subterm_fin_set formula-decl nil term_properties nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (dom const-decl "finite_set[variable]" substitution nil) (apply_sub_elim_var_t2 formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (func_subterms_subs formula-decl nil substitution nil) (im_under_subs2 formula-decl nil substitution nil) (instantiate_step_no_pair_img formula-decl nil aux_unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (subterm_reflexive_finset formula-decl nil term_properties nil) nil (solve_ac_no_pair formula-decl nil aux_unification nil) (instantiate_step_sub_im_under formula-decl nil aux_unification nil) nil nil (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subs const-decl "term" substitution nil) (same_func? const-decl "bool" term_properties nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_append formula-decl nil unification nil) (idempotent? const-decl "bool" substitution nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (image_composition formula-decl nil function_props nil) (mimic_var_append formula-decl nil termination_alg nil) (apply_sub_no_var_pair formula-decl nil unification nil) (instantiate_step_no_var_pair formula-decl nil aux_unification nil) (instantiate_step_mem formula-decl nil aux_unification nil) (no_var_pair_append formula-decl nil unification nil) (apply_sub_len formula-decl nil unification nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (append_null formula-decl nil list_props nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (finset2list def-decl "list[T]" list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (mimic_var def-decl "variable" termination_alg nil) nil nil (subset? const-decl "bool" sets nil) (append def-decl "list[T]" list_props nil) (no_var_pair? const-decl "bool" unification nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("apply_ac_step" apply_ac_step next_input?_TCC1 0 (next_input?_TCC1-1 nil 3850057287 ("" (subtype-tcc) nil nil) nil nil (next_input? subtype "apply_ac_step.t" "(term_adt[constant, variable, f_symbol, ac_symbol].ac_app?)")))("termination_alg" termination_alg next_input?_vars_under2more 0 (next_input?_vars_under2more-1 nil 3850133732 ("" (skeep) (("" (assert) (("" (prop) (("" (name-replace "unif_prb" "append(input0`1, input0`2)") (("" (name-replace "unif_prb1" "append(input1`1, input1`2)") (("" (expand "next_input?" -1) (("" (split -1) (("1" (flatten) (("1" (replace -3 2) (("1" (assert) (("1" (expand "unif_prb1" 2) (("1" (expand "unif_prb" 2) (("1" (replace -3 2) (("1" (assert) (("1" (expand "subset?" 2) (("1" (skeep) (("1" (expand "member" 2) (("1" (expand "image" 2) (("1" (inst 2 "x") (("1" (expand "mimic_var" 2) (("1" (propax) nil nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (expand "member" -6) (("2" (expand "vars_under2more" -6) (("2" (skeep) (("2" (inst 1 "t" "s") (("2" (assert) (("2" (expand "append" 1) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (delete 1) (("2" (name-replace "unif_pair" "car(input0`1)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_vars2avoid" "union(vars(input0`1), union(input0`4, vars(input0`2)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(input0`1), input0`2, input0`3, new_vars2avoid)") (("2" (expand "input_lst" -2) (("2" (lemma "input_apply_ac_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (case "input1`3 = sigma") (("1" (replace -1) (("1" (hide -1 -5) (("1" (hide -1 -2 -3 -4 -5) (("1" (expand "subset?" 2) (("1" (skolem 2 "Y") (("1" (prop) (("1" (reveal -1 -10 -12) (("1" (replace -2 -1 :dir rl) (("1" (hide -2 -3) (("1" (lemma "instantiate_step_mem2") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (prop) (("1" (hide -1 -2 1) (("1" (case "idempotent?(sigma)") (("1" (name-replace "unif_prb05" "append(cdr(input0`1), append(unif_prbC, input0`2))") (("1" (case "subset?(subterms(unif_prb1), subterms(apply_sub(sigma, unif_prb05)))") (("1" (expand "vars_under2more" -9) (("1" (expand "member" -9 1) (("1" (skolem -9 ("t1" "s1")) (("1" (flatten) (("1" (hide -8 -7 -1 -2 -5 -6) (("1" (case "EXISTS t: (member(t, subterms(unif_prb05)) AND same_func?(t, t1) AND (EXISTS X: subs(sigma)(X) = variable(Y) AND im_under?(X, t)))") (("1" (case "EXISTS s: (member(s, subterms(unif_prb05)) AND same_func?(s, s1) AND (EXISTS X: subs(sigma)(X) = variable(Y) AND im_under?(X, s)))") (("1" (case "subs(sigma)(Y) = variable(Y)") (("1" (case "FORALL t1: dif_func?(t1, t) AND member(t1, subterms(unif_prb05)) IMPLIES member(t1, subterms(unif_prb))") (("1" (hide -1 -2) (("1" (skolem -1 "s2") (("1" (prop) (("1" (skolem -3 "X2") (("1" (prop) (("1" (skolem -5 "t2") (("1" (prop) (("1" (skolem -7 "X1") (("1" (prop) (("1" (hide -11 -12 -13 -14 -15) (("1" (case "X1 = Y AND X2 = Y") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (case "ac_app?(t)") (("1" (case "same_func?(t2, t)") (("1" (case "dif_func?(s2, t)") (("1" (reveal -8) (("1" (inst -1 "s2") (("1" (assert) (("1" (hide -5) (("1" (lemma "im_under_var") (("1" (inst -1 "Y" "s2") (("1" (assert) (("1" (case "member(t2, subterms(unif_prb))") (("1" (expand "member" 2) (("1" (expand "image" 2) (("1" (inst 2 "Y") (("1" (lemma "mimic_var_cor") (("1" (inst -1 "Y" "sigma") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -9) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "s2") (("2" (assert) (("2" (hide-all-but (-4 -5 1)) (("2" (lemma "cond_dif_func") (("2" (rewrite "dif_func_sym") (("2" (inst? -1) (("2" (inst -1 "t") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -9)) (("2" (expand "unif_prb05") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (expand "unif_prb" 1) (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "subterms" 1) (("1" (expand ("member" "union")) (("1" (prop) (("1" (expand "member" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_vars2avoid") (("2" (reveal -9) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -2) (("2" (reveal -29 -43) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst?) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (reveal -6 -7) (("1" (expand "unif_prb" -2) (("1" (rewrite "subterms_append") (("1" (expand "member" 1) (("1" (expand "union" 1 1) (("1" (flatten) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (flatten) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "s2S") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst -1 "Y" "s2" "s2S") (("1" (assert) (("1" (hide -2 -4) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s2S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "s2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "Y" "s2" "s2S") (("2" (assert) (("2" (hide -2 -4) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "s2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -48 -49 -50) (("2" (hide -5 -6 -7) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -4 -8)) (("2" (reveal -10) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t2" "t") (("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t1" "t2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym") (("2" (rewrite "dif_func_sym") (("2" (lemma "cond_dif_func") (("2" (inst -1 "t1" "s1" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dif_func?(t2, t)") (("1" (hide 1) (("1" (reveal -8) (("1" (inst -1 "t2") (("1" (assert) (("1" (hide -8) (("1" (lemma "im_under_var") (("1" (inst -1 "Y" "t2") (("1" (assert) (("1" (case "member(s2, subterms(unif_prb))") (("1" (expand "member" 2) (("1" (expand "image" 2) (("1" (inst 2 "Y") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -9) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more") (("2" (inst 1 "t2" "s2") (("2" (assert) (("2" (hide-all-but (-7 -10 1)) (("2" (reveal -15) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s1" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") (("2" (hide 2 -2) (("2" (rewrite "dif_func_sym") (("2" (rewrite "dif_func_sym" -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s1" "t1" "t2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "unif_prb05") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "subterms" 1) (("1" (expand ("member" "union") 1) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "solve_ac_vars_vars2avoid") (("2" (reveal -28 -42) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (reveal -6) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -2) (("2" (inst? -3) (("2" (inst? -3) (("2" (assert) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "lst_vars2avoid") (("1" (rewrite "finset2list_mem") (("1" (expand "cur_vars2avoid") (("1" (reveal -6 -7) (("1" (expand "unif_prb") (("1" (rewrite "subterms_append") (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (expand "member" 2 1) (("1" (flatten) (("1" (lemma "vars_subterm") (("1" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t2S") (("1" (inst 1 "t2S") (("1" (assert) (("1" (flatten) (("1" (inst -3 "Y" "t2" "t2S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "t2S") (("2" (inst -2 "Y" "t2" "t2S") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide -1 -4) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (assert) (("2" (reveal -47 -48 -49) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -7 1 2)) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (flatten) (("2" (assert) (("2" (prop) (("1" (expand "func?" 2) (("1" (propax) nil nil)) nil) ("2" (expand "func?" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (reveal -42 -43 -31) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "X1 = Y AND X2 /= Y") (("1" (hide 1) (("1" (flatten) (("1" (replace -1) (("1" (hide 1) (("1" (hide-all-but (-4 -10 -11)) (("1" (reveal 3) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X2" "Y" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (prop) (("1" (case "member(variable(Y), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (hide -2 -4 -5) (("1" (reveal -25 -39) (("1" (replace -2 :dir rl) (("1" (reveal -1) (("1" (inst? -4) (("1" (inst -4 "Y") (("1" (assert) (("1" (hide -2 -3) (("1" (case "ac_app?(t)") (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (skolem -5 "t3") (("1" (flatten) (("1" (hide -6) (("1" (case "same_func?(t, s)") (("1" (case "dif_func?(t2, t)") (("1" (reveal -21) (("1" (inst -1 "t2") (("1" (reveal -13) (("1" (assert) (("1" (hide -1) (("1" (reveal 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "Y") (("1" (lemma "mimic_var_cor") (("1" (reveal -22) (("1" (inst? -2) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (reveal -23) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (reveal -15) (("2" (inst 1 "t2" "t3") (("2" (assert) (("2" (hide-all-but (-3 -5 -6 1)) (("2" (reveal -8) (("2" (split 1) (("1" (split) (("1" (assert) nil nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2 -53 -54 -55) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2 3) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (prop) (("1" (replace -1) (("1" (replace -5) (("1" (replace -4) (("1" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (replace -3) (("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "is_ac_sym?" -8) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(t2, t)") (("1" (case "dif_func?(s2, t)") (("1" (reveal -21) (("1" (inst -1 "s2") (("1" (assert) (("1" (reveal -10) (("1" (assert) (("1" (hide -1) (("1" (hide -3 -4 -5 -6 1 2) (("1" (case "member(variable(X2), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (hide -4 -5 -6 -7 -8) (("1" (reveal -37 -51) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (inst? -2) (("1" (inst -2 "X2") (("1" (assert) (("1" (skolem -2 "s3") (("1" (flatten) (("1" (hide -3) (("1" (case "dif_func?(s2, s3)") (("1" (hide -2) (("1" (reveal 3) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X2") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (reveal -17) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "s2" "s3") (("2" (reveal -21) (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -7) (("2" (reveal -61 -62 -63 -14 -15) (("2" (expand "unif_prb" 1) (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (hide 2) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2) (("2" (replace -5) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (expand "is_ac_sym?") (("2" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (rewrite "subterm_reflexive") nil nil)) nil)) nil) ("2" (replace -1) (("2" (replace -5) (("2" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(s2, s3)") (("1" (hide-all-but -1) (("1" (reveal -7 -12) (("1" (reveal -6) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3) (("1" (expand "same_func?") (("1" (expand "dif_func?") (("1" (flatten) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "same_func_trans") (("2" (inst -1 "s" "t" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") (("2" (hide -3 -4) (("2" (rewrite "same_func_sym") (("2" (expand "dif_func?") (("2" (expand "same_func?") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (reveal -6 -12 -7) (("2" (hide 1) (("2" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -6) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (hide 1) (("2" (reveal -39 -53) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst?) (("2" (inst -1 "X2") (("2" (assert) (("2" (hide -1 -2) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (expand "member" 2 1) (("2" (flatten) (("2" (reveal -4 -25) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -3) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "s2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X2" "s2" "s2S") (("2" (assert) (("2" (hide -2 -3) (("2" (expand "unif_prb" -2) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "s2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (reveal -18 -21 -23) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t2" "t") (("2" (assert) (("2" (hide 2) (("2" (hide -5 -4) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t1" "t2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym") (("2" (rewrite "dif_func_sym") (("2" (lemma "cond_dif_func") (("2" (inst -1 "t1" "s1" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (reveal -21) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (flatten) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "same_func?" 1) (("2" (expand "is_ac_sym?") (("2" (assert) (("2" (flatten) (("2" (expand "func?" 1) (("2" (assert) (("2" (expand ("ord" "sym") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (reveal -50 -51 -52) (("2" (reveal -40) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (assert) (("2" (expand "member" -1) (("2" (expand "ac_prb?") (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -39 -51 -50) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (assert) (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -2) (("2" (assert) (("2" (lemma "instantiate_step_rhs_not_id") (("2" (inst -1 "Y" "unif_prbC") (("2" (assert) (("2" (reveal 5) (("2" (assert) (("2" (reveal -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "X1 /= Y AND X2 = Y") (("1" (flatten) (("1" (hide 1 2 3) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X1" "Y" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (reveal 1) (("1" (assert) (("1" (prop) (("1" (reveal -16 -30) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (hide -1) (("1" (case "member(variable(Y), lhs(unif_prbC))") (("1" (hide-all-but -1) (("1" (reveal -12) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "Y") (("1" (assert) (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (case "same_func?(t, s)") (("1" (skolem -4 "s3") (("1" (flatten) (("1" (hide -5) (("1" (case "dif_func?(s2, t)") (("1" (reveal -23) (("1" (inst -1 "s2") (("1" (reveal -6) (("1" (assert) (("1" (hide -1) (("1" (reveal 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (reveal -8) (("1" (inst 1 "Y") (("1" (reveal -24) (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "s2" "s3") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-3 -4 1)) (("1" (reveal -6) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "cond_dif_func") (("2" (inst?) (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -8 -4 -5 -55 -56 -57) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (hide 2) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2) (("2" (replace -6) (("2" (hide -6) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -4) (("2" (replace -5) (("2" (hide -4 -5) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "is_ac_sym?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(s2, t)") (("1" (hide -3 -4 1) (("1" (case "dif_func?(t2, t)") (("1" (reveal -25) (("1" (inst -1 "t2") (("1" (assert) (("1" (reveal -6) (("1" (reveal -14) (("1" (case "member(variable(X1), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "X1") (("1" (hide -4) (("1" (assert) (("1" (skolem -1 "t3") (("1" (flatten) (("1" (hide -2) (("1" (case "dif_func?(t2, t3)") (("1" (reveal 3) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X1") (("1" (lemma "mimic_var_cor") (("1" (reveal -14) (("1" (inst?) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "t3") (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -10 -11 -12 -60 -61 -62) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2 3) (("2" (replace -6) (("2" (hide -6) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -4) (("2" (replace -5) (("2" (hide -4 -5) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "is_ac_sym?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -7 1)) (("2" (reveal -7) (("2" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -2) (("2" (assert) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X1") (("2" (assert) (("2" (hide-all-but (-1 -3 1)) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (expand "member" 2 1) (("2" (flatten) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -2) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "t2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t2" "t2S") (("2" (assert) (("2" (hide -2 -3) (("2" (expand "unif_prb" -2) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -9 -12 -20) (("2" (hide -6 -7 -8) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s2" "t") (("2" (assert) (("2" (hide 2) (("2" (hide -5) (("2" (lemma "cond_dif_func") (("2" (inst -1 "t2" "s1" "s2") (("2" (assert) (("2" (hide 2) (("2" (rewrite "same_func_sym") (("2" (rewrite "dif_func_sym") (("2" (rewrite "dif_func_sym" -3) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s1" "t1" "t2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (reveal -11) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (flatten) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5) (("2" (expand "same_func?") (("2" (expand "is_ac_sym?") (("2" (expand "func?") (("2" (assert) (("2" (expand "ord") (("2" (expand "sym") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (reveal -39 -51 -50 -49) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -39 -50 -51) (("2" (expand "is_ac_sym?") (("2" (expand "all_ac_prb?") (("2" (inst -1 "car(input0`1)") (("2" (expand "member") (("2" (assert) (("2" (expand "ac_prb?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs" -2) (("2" (assert) (("2" (hide-all-but -2) (("2" (lemma "instantiate_step_rhs_not_id") (("2" (reveal -10 -20 7) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "X1 /= Y AND X2 /= Y") (("1" (flatten) (("1" (hide 1 2 3 4 5) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X1" "Y" "unif_prbC") (("1" (assert) (("1" (assert) (("1" (reveal 1) (("1" (assert) (("1" (hide 1) (("1" (prop) (("1" (lemma "instantiate_step_var_member") (("1" (inst -1 "X2" "Y" "unif_prbC") (("1" (assert) (("1" (reveal 2) (("1" (assert) (("1" (hide 1) (("1" (case "member(variable(Y), lhs(unif_prbC))") (("1" (hide-all-but (-1 -13 -14)) (("1" (reveal -26 -40) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "Y") (("1" (assert) (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (hide -1 -2) (("1" (case "same_func?(t, s)") (("1" (skolem -2 "t'") (("1" (flatten) (("1" (hide -3) (("1" (case "dif_func?(t2, t)") (("1" (reveal -23) (("1" (inst -1 "t2") (("1" (reveal -13) (("1" (assert) (("1" (hide -1) (("1" (reveal -16) (("1" (use "im_under_var") (("1" (assert) (("1" (hide -2) (("1" (reveal -8) (("1" (case "member(variable(X1), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (hide -3) (("1" (inst -1 "X1") (("1" (assert) (("1" (skolem -1 "t3") (("1" (flatten) (("1" (hide -2) (("1" (reveal -18 2) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X1") (("1" (lemma "mimic_var_cor") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (reveal -18) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "t3") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-6 -7 1)) (("1" (reveal -10) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "cond_dif_func") (("2" (inst? -1) (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -6 -12 -61 -62 -63) (("2" (expand "unif_prb" 1) (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (hide 2) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -5) (("2" (hide 2) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -3) (("2" (replace -4) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "same_func?" -3) (("1" (expand "func?" -3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "same_func?" -3) (("2" (flatten) (("2" (expand "func?" -3) (("2" (hide-all-but (-1 -3 -4)) (("2" (prop) (("1" (expand "ord" -3) (("1" (assert) nil nil)) nil) ("2" (expand "ord" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (assert) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X1") (("2" (assert) (("2" (hide-all-but (-2 -3 1)) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "t2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t2" "t2S") (("2" (assert) (("2" (hide -2 -3) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (expand "member" 2 1) (("2" (flatten) (("2" (expand "unif_prb" -2) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "same_func?(t2, t)") (("1" (case "dif_func?(s2, t)") (("1" (hide 1) (("1" (reveal -23) (("1" (inst -1 "s2") (("1" (assert) (("1" (reveal -6) (("1" (case "member(variable(X2), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst? -1) (("1" (inst -1 "X2") (("1" (assert) (("1" (skolem -1 "s3") (("1" (flatten) (("1" (hide -2) (("1" (reveal -13) (("1" (reveal 3) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "X2") (("1" (lemma "mimic_var_cor") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (reveal -14) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "s2" "s3") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-6 -8 1)) (("1" (lemma "cond_dif_func") (("1" (reveal -10) (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (inst -1 "s2" "t" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -12 -14 -15 -60 -61 -62) (("2" (expand "unif_prb") (("2" (rewrite "subterms_append") (("2" (flatten) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 2 3) (("2" (replace -6) (("2" (expand "subterms" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -4) (("2" (replace -5) (("2" (hide -4 -5 -6) (("2" (prop) (("1" (replace -1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "subterm_reflexive") (("2" (expand "is_ac_sym?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (assert) (("2" (hide 1) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst? -1) (("2" (inst -1 "X2") (("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (reveal -23) (("2" (use "im_under_var") (("2" (assert) (("2" (hide -2) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "s2S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X2" "s2" "s2S") (("2" (assert) (("2" (hide -2 -3) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (expand "member" 2 1) (("2" (flatten) (("2" (expand "unif_prb") (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "s2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (reveal -16 -20 -24) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t2" "t") (("2" (assert) (("2" (hide 2 -4) (("2" (lemma "cond_dif_func") (("2" (inst -1 "s2" "t1" "t2") (("2" (assert) (("2" (rewrite "same_func_sym") (("2" (hide 2) (("2" (rewrite "dif_func_sym") (("2" (lemma "cond_dif_func") (("2" (inst -1 "t1" "s1" "s2") (("2" (assert) (("2" (rewrite "same_func_sym") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -14) (("2" (hide -3 -4 -5) (("2" (hide -3 -4) (("2" (expand "same_func?") (("2" (expand "dif_func?") (("2" (flatten) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -6 -7) (("2" (expand "is_ac_sym?") (("2" (expand "same_func?") (("2" (expand "func?") (("2" (assert) (("2" (expand "ord") (("2" (expand "sym") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -41 -51 -52 -53) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -51 -52 -40) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (expand "is_ac_sym?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 -13 1 -3)) (("2" (rewrite "member_lhs_rhs") (("2" (assert) (("2" (lemma "instantiate_step_rhs_not_id") (("2" (inst? -1) (("2" (reveal 8 -19) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem 1 "t'") (("2" (prop) (("2" (expand "unif_prb05") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (expand "unif_prb" 1) (("2" (rewrite "subterms_append") (("2" (prop) (("1" (expand "member" 1) (("1" (expand "subterms" 1) (("1" (expand "union" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_func") (("2" (reveal -17 -31) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst? -2) (("2" (inst -2 "t'") (("2" (assert) (("2" (case "ac_app?(t)") (("1" (prop) (("1" (hide -3 -4 1 2) (("1" (expand "is_ac_sym?" -1) (("1" (expand "dif_func?" -3) (("1" (flatten) (("1" (prop) (("1" (expand "ord" 1) (("1" (assert) nil nil)) nil) ("2" (expand "sym" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -4) (("2" (assert) nil nil)) nil) ("3" (hide -2 -3 -4 -5 2) (("3" (reveal -40 -41 -42) (("3" (expand "subterms" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -41 -42) (("2" (reveal -30) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(input0`1)") (("2" (assert) (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -6 -8)) (("2" (reveal -8 -3) (("2" (expand "subset?" -2) (("2" (inst -2 "t1") (("2" (assert) (("2" (hide -4) (("2" (use "apply_sub_subterms") (("2" (assert) (("2" (prop) (("1" (skolem -1 "s1S") (("1" (prop) (("1" (use "im_under_var") (("1" (assert) (("1" (hide -6) (("1" (replace -3 -1) (("1" (lemma "apply_sub_elim_var_t2") (("1" (inst -1 "Y" "sigma" "s1S") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "dom" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst? -1) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "Y") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (prop) (("1" (expand "dom" 1) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "subterm_fin_set") (("2" (skolem -1 "t1S") (("2" (prop) (("2" (rewrite "vars_finset") (("2" (inst?) (("2" (assert) (("2" (lemma "im_under_var") (("2" (inst -1 "Y" "t1") (("2" (assert) (("2" (hide -2 -5 -6) (("2" (lemma "vars_subterm") (("2" (inst -1 "Y" "t1" "t1S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2 3) (("2" (reveal -2) (("2" (expand "subset?" -1) (("2" (inst -1 "s1") (("2" (assert) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "s1'") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "s3") (("2" (prop) (("2" (replace -3 -1) (("2" (lemma "func_subterms_subs") (("2" (inst? -1) (("2" (assert) (("2" (case "member(s1, subterms(img(sigma)))") (("1" (assert) (("1" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step_sub_im_under") (("1" (hide -8 -9 -11) (("1" (inst? -1) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (skolem -1 ("X" "s4")) (("1" (prop) (("1" (inst 1 "s4") (("1" (prop) (("1" (reveal -10) (("1" (replace -1 1 :dir rl) (("1" (rewrite "subterms_append") (("1" (rewrite "subterms_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "same_func_sym") nil nil) ("3" (inst 1 "X") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -23 -37) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -7) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skolem -1 "s4") (("1" (flatten) (("1" (hide -9 -10 -12) (("1" (replace -2 -9 :dir rl) (("1" (lemma "im_under_subs2") (("1" (inst? -1) (("1" (assert) (("1" (case "no_pair?(img(sigma))") (("1" (assert) (("1" (prop) (("1" (hide 1) (("1" (skeep) (("1" (prop) (("1" (inst 1 "s4") (("1" (assert) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "s3") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "X") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 "s5") (("2" (hide -8 -9 -12 -13) (("2" (prop) (("2" (replace -11 -1) (("2" (lemma "instantiate_step_sub_im_under") (("2" (inst -1 "X" "s5" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (skolem -1 ("X1" "s6")) (("1" (replace -12 :dir rl) (("1" (assert) (("1" (prop) (("1" (inst 1 "s6") (("1" (assert) (("1" (prop) (("1" (expand "unif_prb05") (("1" (rewrite "subterms_append") (("1" (prop) (("1" (rewrite "subterms_append") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1 -7 -4)) (("2" (lemma "same_func_trans") (("2" (rewrite "same_func_sym" -2) (("2" (inst -1 "s5" "s6" "s4") (("2" (assert) (("2" (rewrite "same_func_sym" -3) (("2" (assert) (("2" (hide -2 -3) (("2" (lemma "same_func_trans") (("2" (inst -1 "s4" "s6" "s1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "X1") (("3" (assert) (("3" (hide-all-but (-2 -8 -14 1)) (("3" (expand "idempotent?" -3) (("3" (inst -3 "X1") (("3" (replace -3 1 :dir rl) (("3" (replace -1) (("3" (expand "subs" -2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -10 -11)) (("2" (replace -3 :dir rl) (("2" (rewrite "subterm_reflexive_finset") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -30 -44) (("3" (replace -2 :dir rl) (("3" (hide -2) (("3" (use "solve_ac_no_pair") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "same_func?" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (lemma "instantiate_step_no_pair_img") (("2" (inst? -1) (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -26 -40) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (use "solve_ac_no_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -1) (("2" (expand "subset?" -1) (("2" (inst -1 "t1") (("2" (assert) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "t1'") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t3") (("2" (prop) (("2" (replace -3 -1) (("2" (lemma "func_subterms_subs") (("2" (inst? -1) (("2" (assert) (("2" (case "member(t1, subterms(img(sigma)))") (("1" (assert) (("1" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step_sub_im_under") (("1" (hide -8 -10 -12) (("1" (inst? -1) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (skolem -1 ("X" "t4")) (("1" (prop) (("1" (inst 1 "t4") (("1" (prop) (("1" (reveal -9) (("1" (replace -1 1 :dir rl) (("1" (rewrite "subterms_append") (("1" (rewrite "subterms_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "same_func_sym") nil nil) ("3" (inst 1 "X") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -22 -36) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -7) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skolem -1 "t4") (("1" (flatten) (("1" (hide -9 -11 -13) (("1" (replace -2 -9 :dir rl) (("1" (lemma "im_under_subs2") (("1" (inst? -1) (("1" (assert) (("1" (case "no_pair?(img(sigma))") (("1" (assert) (("1" (prop) (("1" (hide 1) (("1" (skeep) (("1" (prop) (("1" (inst 1 "t4") (("1" (assert) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "t3") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "X") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 "t5") (("2" (hide -8 -9 -12 -13) (("2" (prop) (("2" (replace -11 -1) (("2" (lemma "instantiate_step_sub_im_under") (("2" (inst -1 "X" "t5" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (skolem -1 ("X1" "t6")) (("1" (replace -12 :dir rl) (("1" (assert) (("1" (prop) (("1" (inst 1 "t6") (("1" (assert) (("1" (prop) (("1" (expand "unif_prb05") (("1" (rewrite "subterms_append") (("1" (prop) (("1" (rewrite "subterms_append") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1 -7 -4)) (("2" (lemma "same_func_trans") (("2" (rewrite "same_func_sym" -2) (("2" (inst -1 "t5" "t6" "t4") (("2" (assert) (("2" (rewrite "same_func_sym" -3) (("2" (assert) (("2" (hide -2 -3) (("2" (lemma "same_func_trans") (("2" (inst -1 "t4" "t6" "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "X1") (("3" (assert) (("3" (hide-all-but (-2 -8 -14 1)) (("3" (expand "idempotent?" -3) (("3" (inst -3 "X1") (("3" (replace -3 1 :dir rl) (("3" (replace -1) (("3" (expand "subs" -2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -10 -11)) (("2" (replace -3 :dir rl) (("2" (rewrite "subterm_reflexive_finset") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -29 -43) (("3" (replace -2 :dir rl) (("3" (hide -2) (("3" (use "solve_ac_no_pair") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "same_func?" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (lemma "instantiate_step_no_pair_img") (("2" (inst? -1) (("2" (assert) (("2" (hide-all-but 1) (("2" (reveal -25 -39) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (use "solve_ac_no_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dif_func?" -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 -2)) (("2" (reveal -27 -11 -12) (("2" (reveal -8) (("2" (expand "subset?" 1) (("2" (skolem 1 "t1") (("2" (prop) (("2" (replace -6 :dir rl) (("2" (rewrite "apply_sub_append") (("2" (rewrite "apply_sub_append") (("2" (rewrite "subterms_append") (("2" (rewrite "subterms_append") (("2" (prop) (("2" (hide -6) (("2" (replace -4 :dir rl) (("2" (rewrite "subterms_append") (("2" (prop) (("1" (assert) nil nil) ("2" (replace -4) (("2" (hide -5) (("2" (rewrite "subterms_append") (("2" (prop) (("2" (hide -3 -4 1 3) (("2" (lemma "instantiate_step1_mem") (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "t1S") (("2" (prop) (("2" (inst? -1) (("2" (inst -1 "t1S") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (prop) (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 2 "t1S") (("2" (assert) (("2" (rewrite "apply_sub_mem") (("2" (inst 2 "t2") (("2" (assert) (("2" (reveal -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4 -13) (("2" (hide -4 -5 -6 -7 -8) (("2" (lemma "instantiate_step_sub") (("2" (replace -3 -2 :dir rl) (("2" (hide -3) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -9 1)) (("2" (case "input0`3 = null") (("1" (replace -1) (("1" (rewrite "append_null") nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_image application-judgement "finite_set[R]" function_image_aux nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (unif_prb type-eq-decl nil unification nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (next_input? const-decl "bool" apply_ac_step nil) nil (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) nil (instantiate_step_mem2 formula-decl nil aux_unification nil) (idempotent? const-decl "bool" substitution nil) (apply_sub def-decl "unif_prb" unification nil) (same_func? const-decl "bool" term_properties nil) (subs const-decl "term" substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) nil nil (instantiate_step_sub_im_under formula-decl nil aux_unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (im_under_subs2 formula-decl nil substitution nil) (instantiate_step_no_pair_img formula-decl nil aux_unification nil) (subterm_reflexive_finset formula-decl nil term_properties nil) nil (func_subterms_subs formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (solve_ac_func formula-decl nil aux_unification nil) (all_ac_prb? const-decl "bool" unification nil) (member def-decl "bool" list_props nil) (ac_prb? const-decl "bool" unification nil) (im_under_var formula-decl nil term_properties nil) (subterms_append formula-decl nil unification nil) nil nil (vars_subterm formula-decl nil term_properties nil) (vars_unif_prb formula-decl nil unification nil) (subterms_mem_unif_prb formula-decl nil unification nil) (finset2list_mem formula-decl nil list_theory nil) (solve_ac_vars_vars2avoid formula-decl nil aux_unification nil) nil nil (mimic_var_cor formula-decl nil termination_alg nil) (dif_func_sym formula-decl nil term_properties nil) (same_func_sym formula-decl nil term_properties nil) (cond_dif_func formula-decl nil term_properties nil) (func? const-decl "bool" term_properties nil) nil (instantiate_step_var_member formula-decl nil aux_unification nil) (instantiate_step_rhs_not_id formula-decl nil aux_unification nil) (solve_ac_lhs_im_under formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (sym const-decl "string" term_properties nil) (ord const-decl "upto(5)" term_adt nil) (subterm_reflexive formula-decl nil term_properties nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) nil (same_func_trans formula-decl nil term_properties nil) (solve_ac_vars_rhs formula-decl nil aux_unification nil) (member_unif_prb_append formula-decl nil unification nil) (member_lhs_rhs formula-decl nil unification nil) (lhs const-decl "args" unification nil) (args type-eq-decl nil term_properties nil) (/= const-decl "boolean" notequal nil) (dif_func? const-decl "bool" term_properties nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (empty? const-decl "bool" sets nil) (vars_finset formula-decl nil term_properties nil) (subterm_fin_set formula-decl nil term_properties nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (intersection const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (apply_sub_elim_var_t2 formula-decl nil substitution nil) (dom const-decl "finite_set[variable]" substitution nil) (apply_sub_subterms formula-decl nil unification nil) (apply_sub_append formula-decl nil unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (instantiate_step_sub formula-decl nil aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (append_null formula-decl nil list_props nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (finset2list def-decl "list[T]" list_theory nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) nil nil (union const-decl "set" sets nil) nil (mimic_var def-decl "variable" termination_alg nil) nil nil nil (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) nil) shostak))("termination_alg" termination_alg apply_ac_vars_under2more_eq_terms 0 (apply_ac_vars_under2more_eq_terms-1 nil 3850081549 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (name-replace "unif_prb" "append(unseen_unif_prb, seen_unif_prb)") (("" (name-replace "unif_prbn" "ac_sol`1") (("" (name-replace "sigma_0n" "ac_sol`2") (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (inst 1 "tn") (("1" (hide -4) (("1" (prop) (("1" (expand "sigma_0n") (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (expand "unif_prbn") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (reveal -4) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (inst -1 "tn") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "t") (("1" (assert) (("1" (expand "sigma_0n" 2) (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 4 "s") (("1" (assert) (("1" (expand "member" 4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "unif_prbn" -4) (("2" (use "subset_antisymmetric[variable]") (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (lemma "apply_ac_step_vars_under2more") (("1" (inst -1 "ac_sol" "seen_unif_prb" "cdr(unseen_unif_prb)" "vars2avoid") (("1" (assert) (("1" (expand "unif_prb" -6) (("1" (hide-all-but (-6 1 3)) (("1" (expand "no_var_pair?") (("1" (skeep) (("1" (inst -2 "t") (("1" (expand "append" -2) (("1" (expand "member" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (replace -5) (("2" (expand "image" 1) (("2" (expand "member" 1) (("2" (expand "member" -1) (("2" (expand "image" -1) (("2" (skeep) (("2" (inst 1 "x_1") (("1" (expand "sigma_0n") (("1" (propax) nil nil)) nil) ("2" (typepred "x_1") (("2" (expand "unif_prb" 1) (("2" (hide-all-but (-1 1 2)) (("2" (expand "vars_under2more") (("2" (skeep) (("2" (inst 1 "t" "s") (("2" (assert) (("2" (expand "append" 1) (("2" (expand "subterms" 1) (("2" (expand ("member" "union")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "unif_prbn") (("3" (propax) nil nil)) nil) ("4" (expand "unif_prb" -6) (("4" (expand "no_var_pair?") (("4" (skeep) (("4" (inst -7 "t") (("4" (assert) (("4" (expand "append" -7) (("4" (assert) (("4" (expand "member" -7) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (case "ac_app?(t)") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split) (("1" (flatten) (("1" (hide-all-but -2) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide -2 -3 -4) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (expand "input_lst" -1) (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (hide -2) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (prop) (("2" (rewrite "append_null") (("2" (replace -8) (("2" (hide -6 -7 -8 -9) (("2" (reveal -20 -21) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (name-replace "unif_prb1" "append(input`1, input`2)") (("2" (name-replace "sigma_1n" "ac_sol1`2") (("2" (hide -1 -3 -4 -5) (("2" (reveal -28) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst?) (("1" (assert) (("1" (inst?) (("1" (case "no_var_pair?(append(input`1, input`2))") (("1" (assert) (("1" (hide -2) (("1" (reveal -20 -22) (("1" (replace -1 -5 :dir rl) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (hide -1) (("1" (reveal -3) (("1" (case "vars_under2more(ac_sol1`1) = image(mimic_var(ac_sol1`2), vars_under2more(append(input`1, input`2)))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 2 3)) (("1" (skolem -1 "t1") (("1" (flatten) (("1" (prop) (("1" (reveal -19) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (reveal -8) (("1" (prop) (("1" (hide 1 -3) (("1" (lemma "instantiate_step_not_temp_unif_pair") (("1" (replace -3 -4) (("1" (reveal -1) (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (skolem -2 ("t2" "unif_pair1")) (("1" (prop) (("1" (hide -6) (("1" (lemma "solve_ac_rhs_is_temp") (("1" (expand "member" -4) (("1" (prop) (("1" (hide 2 -2) (("1" (lemma "solve_ac_mem_lhs") (("1" (reveal -12 -35) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (flatten) (("1" (hide -2 -3 1) (("1" (inst?) (("1" (inst -2 "t2") (("1" (assert) (("1" (case "member(t2, lhs(unif_prbC))") (("1" (assert) (("1" (inst 3 "t2") (("1" (reveal -21 -23) (("1" (replace -1) (("1" (replace -2) (("1" (replace -8 -12) (("1" (rewrite "subs_append2") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 2 4)) (("1" (inst 2 "t") (("1" (reveal -38 -39 -47 -48 -49) (("1" (expand "member" 2 2) (("1" (assert) (("1" (expand "get_args" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 2 4)) (("2" (reveal -39 -47 -48 -49) (("2" (inst 2 "s") (("2" (expand "member" 2 2) (("2" (assert) (("2" (expand "get_args" 2) (("2" (lift-if) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 4) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (reveal -11 -34) (("2" (flatten) (("2" (hide -2 -3 1) (("2" (inst?) (("2" (inst -4 "t2" "unif_pair1" "unif_prbC") (("2" (replace -2 -1 :dir rl) (("2" (assert) (("2" (hide -1 -2 -5) (("2" (hide-all-but (1 4)) (("2" (expand "subset?" 1) (("2" (skolem 1 "X") (("2" (prop) (("2" (expand "lst_vars2avoid" 1) (("2" (use "mem_lst2set[variable]") (("2" (assert) (("2" (hide 2) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide 2) (("2" (reveal -47 -48 -49) (("2" (expand "member" 1) (("2" (expand "vars" 1) (("2" (expand "union" 1) (("2" (replace -3) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) (("2" (expand "vars" -4) (("2" (expand ("member" "union") -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t0") (("2" (prop) (("2" (inst 2 "t0") (("2" (reveal -15 -17) (("2" (replace -1) (("2" (replace -2) (("2" (replace -4 -5) (("2" (rewrite "subs_append2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 "t1'") (("2" (flatten) (("2" (reveal -18) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2'") (("2" (prop) (("2" (reveal -26) (("2" (expand "all_ac_prb?" -1) (("2" (rewrite "member_unif_prb_equiv") (("2" (skolem -3 "unif_pair1") (("2" (flatten) (("2" (inst -1 "unif_pair1") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (case "ac_app?(t2')") (("1" (hide -2 -4 -5) (("1" (lemma "term_ac_app_eta") (("1" (inst?) (("1" (name-replace "f" "ac_sym(t2')") (("1" (replace -1 -4 :dir rl) (("1" (hide -2) (("1" (rewrite "subs_ac") (("1" (replace -3 -2) (("1" (expand "get_args" -2) (("1" (lemma "subs_ac") (("1" (inst?) (("1" (replace -1 -3 :dir rl) (("1" (hide -1) (("1" (lemma "args_subs_ac") (("1" (inst?) (("1" (replace -1) (("1" (rewrite "mem_flatten_map2") (("1" (hide -1) (("1" (skolem -2 "t3_s") (("1" (prop) (("1" (rewrite "map_member4") (("1" (skolem -2 "t3") (("1" (prop) (("1" (replace -3) (("1" (hide -3) (("1" (case "var?(t3)") (("1" (case "member(subs(sigma)(t3), img(sigma))") (("1" (reveal -37) (("1" (case "f = ac_sym(t)") (("1" (lemma "instantiate_step_get_args") (("1" (reveal -20) (("1" (inst -2 "f" "t1" "subs(sigma)(t3)" "unif_prbC") (("1" (assert) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (assert) (("1" (skolem -4 "t4'") (("1" (prop) (("1" (skolem -5 "t4") (("1" (hide -1 -2 1) (("1" (prop) (("1" (hide -1 -7 -8 -9 -11 -12 -13) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_mem_lhs") (("1" (reveal -7 -52) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (inst?) (("1" (inst -2 "t4'") (("1" (assert) (("1" (replace -7 :dir rl) (("1" (prop) (("1" (lemma "get_args_not_pair_ac") (("1" (inst -1 "f" "t4'") (("1" (prop) (("1" (replace -1) (("1" (expand "member" -5) (("1" (expand "member" -5) (("1" (replace -5 :dir rl) (("1" (hide -1 -2 -5) (("1" (reveal -42 -44) (("1" (replace -2) (("1" (inst 3 "t4") (("1" (replace -1) (("1" (rewrite "subs_append2") (("1" (assert) (("1" (prop) (("1" (reveal -2) (("1" (inst 4 "t") (("1" (expand "get_args" 4) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -8 1)) (("1" (grind) nil nil)) nil) ("2" (reveal -63 -62) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "get_args_mem_not_pair") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "get_args_mem_not_ac") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "t4'") (("2" (prop) (("1" (replace -1) (("1" (expand "member" -5) (("1" (expand "member" -5) (("1" (replace -5 :dir rl) (("1" (hide -1 -3 -4) (("1" (reveal -42 -44) (("1" (replace -2) (("1" (inst 3 "t4") (("1" (replace -1) (("1" (rewrite "subs_append2") (("1" (assert) (("1" (prop) (("1" (inst 4 "s") (("1" (assert) (("1" (case "is_ac_sym?(s, f)") (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (prop) (("1" (expand "get_args" 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 -9 1)) (("2" (grind) nil nil)) nil) ("3" (reveal -61 -62 -63) (("3" (expand "member" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "is_ac_sym?" 1) (("2" (reveal -5 -60 -68 -69 -70) (("2" (expand "all_ac_prb?" -2) (("2" (inst -2 "unif_pair") (("2" (expand "member" -2) (("2" (assert) (("2" (expand "ac_prb?" -2) (("2" (replace -3) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "get_args_mem_not_pair") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "get_args_mem_not_ac") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7 -52) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (hide 3) (("2" (lemma "solve_ac_mem_rhs") (("2" (inst?) (("2" (inst -1 "t4'") (("2" (assert) (("2" (prop) (("1" (lemma "get_args_not_pair_ac") (("1" (inst?) (("1" (assert) (("1" (expand "is_ac_sym?" -1) (("1" (replace -1) (("1" (expand "member" -5) (("1" (expand "member" -5) (("1" (assert) (("1" (replace -5) (("1" (hide-all-but (-2 -7 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -8) (("2" (replace -8 :dir rl) (("2" (rewrite "all_var?_args") (("2" (inst -2 "t4") (("2" (assert) (("2" (hide-all-but (-2 -7 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "term_variable_eta") (("2" (inst -1 "t3") (("2" (case "var?(subs(sigma)(t3))") (("1" (lemma "get_args_not_pair_ac") (("1" (inst -1 "f" "subs(sigma)(t3)") (("1" (assert) (("1" (expand "is_ac_sym?" -1) (("1" (replace -1) (("1" (expand "member" -9) (("1" (expand "member" -9) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "X1" "mimic_var(sigma)(V(t3))") (("2" (case "member(X1, dom(sigma))") (("1" (hide 5 -8 -9 -10 -11) (("1" (case "member(X1, new_vars2avoid)") (("1" (reveal -20) (("1" (reveal -34) (("1" (lemma "apply_ac_step_sub_dom") (("1" (inst?) (("1" (inst -1 "X1") (("1" (assert) (("1" (case "NOT member(X1, vars(input`1))") (("1" (assert) (("1" (name-replace "X" "V(t3)") (("1" (case "member(X, vars_under2more(unif_prb))") (("1" (case "member(X1, image(mimic_var(sigma_0n), vars_under2more(unif_prb)))") (("1" (case "NOT member(X1, image(mimic_var(sigma_1n), vars_under2more(unif_prb1)))") (("1" (hide-all-but (-1 1)) (("1" (reveal -29 -55 -66) (("1" (reveal -45 -42) (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (hide -1 -2 -5) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (expand "unif_prb1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "member" -1) (("2" (expand "image" -1) (("2" (skolem -1 "X2") (("2" (typepred "X2") (("2" (lemma "mimic_var_sec_proj") (("2" (inst?) (("2" (case "X1 /= X2") (("1" (assert) (("1" (replace -4 :dir rl) (("1" (reveal -47 -33 -44) (("1" (lemma "apply_ac_step_sub") (("1" (inst?) (("1" (inst -1 "X1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (flatten) (("2" (replace -1 :dir rl) (("2" (expand "vars_under2more" -2) (("2" (reveal -6) (("2" (skolem -3 ("t2" "s2")) (("2" (prop) (("2" (hide -5 -7 -3) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -4 "t2S") (("2" (prop) (("2" (expand "unif_prb1" -5) (("2" (reveal -52 -53 -42) (("2" (flatten) (("2" (hide 1 -7) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) (("2" (replace -4 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "X1") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "member_unif_prb_append") (("2" (case "member(X1, vars(t2S))") (("1" (hide -9 -10) (("1" (hide -10) (("1" (prop) (("1" (hide -5 -8) (("1" (replace -6) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2S_p") (("1" (prop) (("1" (replace -2) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -8) (("2" (hide -7) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (replace -5 :hide? t) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t2S_p") (("1" (flatten) (("1" (hide -1 1) (("1" (replace -6 :dir rl) (("1" (hide -7) (("1" (replace -1) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t2S_p") (("2" (prop) (("2" (replace -2) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (lemma "im_under_var") (("2" (inst -1 "X1" "t2") (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t2" "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "image" 1) (("2" (inst 1 "X") (("1" (hide 2 3 4 6) (("1" (reveal -35) (("1" (replace -1) (("1" (rewrite "mimic_var_append") (("1" (expand "o") (("1" (replace -7) (("1" (case "NOT member(X1, dom(sigma_1n))") (("1" (lemma "mimic_var_cor") (("1" (inst -1 "X1" "sigma_1n") (("1" (expand "member" 1) (("1" (expand "dom" 1) (("1" (flatten) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6)) (("2" (reveal -44 -30) (("2" (lemma "apply_ac_step_sub_dom") (("2" (inst?) (("2" (inst -1 "X1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4-7 -2 -1 -3 -4 -5 -6) (("2" (reveal -4) (("2" (replace -1 :dir rl) (("2" (reveal -8) (("2" (reveal -22 -23) (("2" (replace -4 :dir rl) (("2" (hide -1) (("2" (case "member(X, dom(sigma))") (("1" (reveal -32) (("1" (flatten) (("1" (hide 1 -2) (("1" (reveal -56) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (inst -1 "unif_prbC") (("1" (assert) (("1" (assert) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (case "is_ac_sym?(t, ac_sym(t)) AND is_ac_sym?(s, ac_sym(t))") (("1" (flatten) (("1" (assert) (("1" (skolem -3 "t'") (("1" (hide -10 -11 -13 -5 -6 -7 -8) (("1" (flatten) (("1" (hide -4) (("1" (expand "vars_under2more" 1) (("1" (expand "member" 1 1) (("1" (inst 1 "t2'" "t'") (("1" (assert) (("1" (prop) (("1" (hide -4 -5 -6 2 4) (("1" (reveal -4) (("1" (expand "is_ac_sym?") (("1" (expand "dif_func?") (("1" (expand "func?") (("1" (reveal -32) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sym" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (expand "sym" -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "im_under?" 1) (("2" (expand "im_under" 1) (("2" (rewrite "mem_list2set" 1 :dir rl) (("2" (reveal -29) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -32 33) (("3" (rewrite "subterms_mem_unif_prb") (("3" (inst 1 "t2'") (("3" (split 1) (("1" (rewrite "subterm_reflexive") nil nil) ("2" (reveal -33) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 1 "unif_pair1") (("2" (expand "unif_prb") (("2" (split 1) (("1" (propax) nil nil) ("2" (rewrite "member_append") (("2" (flatten) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -1) (("4" (reveal -68 -69 -70) (("4" (rewrite "subterms_mem_unif_prb") (("4" (inst 1 "t'") (("4" (split 1) (("1" (rewrite "subterm_reflexive") (("1" (expand "is_ac_sym?") (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "unif_prb" 1) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 1) (("2" (assert) (("2" (split -4) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -9 6)) (("2" (reveal -64) (("2" (expand "all_ac_prb?" -1) (("2" (reveal -72 -73 -74) (("2" (inst -4 "unif_pair") (("2" (expand "member" -4) (("2" (assert) (("2" (expand "ac_prb?" -4) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_rhs") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (hide-all-but (-6 1 6)) (("2" (reveal -34 -35) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (flatten) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2'") (("2" (split 1) (("1" (rewrite "member_unif_prb_equiv") (("1" (inst 1 "unif_pair1") (("1" (assert) (("1" (split 1) (("1" (propax) nil nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (lemma "vars_get_args") (("2" (inst?) (("2" (assert) (("2" (reveal -8) (("2" (replace -1) (("2" (replace -2 :dir rl) (("2" (rewrite "vars_args") (("2" (inst 1 "variable(X)") (("2" (assert) (("2" (expand "member" 1) (("2" (expand "vars" 1) (("2" (expand "singleton" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -9) (("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (flatten) (("2" (expand "subs" -2) (("2" (replace -5) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -38) (("2" (hide-all-but (-1 -2 -6 4)) (("2" (replace -1) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2_p") (("2" (prop) (("2" (replace -3) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (reveal -35) (("2" (flatten) (("2" (hide -1 -2 1) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "X1") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "new_vars2avoid" 1) (("2" (reveal -25) (("2" (flatten) (("2" (hide 1 -2) (("2" (reveal -49) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "instantiate_step_dom2") (("2" (inst -1 "X1" "unif_prbC") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4 -9 -8 -5) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(X1)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "X2") (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (rewrite "mem_list2set" 1 :dir rl) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (reveal -64 -65 -66) (("2" (expand "vars" 1) (("2" (expand ("member" "union")) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (assert) (("2" (expand "union" 1) (("2" (expand "vars" -4) (("2" (expand "union" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mimic_var_dom") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (assert) (("1" (expand "subs" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -22) (("2" (flatten) (("2" (hide -1 -2 8 1) (("2" (lemma "instantiate_step_sub_nice") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (hide 4) (("2" (expand "member" 1) (("2" (expand "img" 1) (("2" (lemma "term_variable_eta") (("2" (inst?) (("2" (inst 1 "V(t3)") (("2" (expand "subs" 1 1) (("2" (assert) (("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (flatten) (("2" (expand "subs" -2) (("2" (replace -1) (("2" (replace -2) (("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "t3") (("2" (assert) (("2" (expand "is_ac_sym?" -1) (("2" (replace -1) (("2" (hide-all-but (-4 -7 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "get_args_not_pair_ac") (("2" (inst -1 "f" "subs(sigma)(t3)") (("2" (prop) (("1" (replace -1) (("1" (hide -1 2) (("1" (expand "member" -3) (("1" (prop) (("1" (replace -2) (("1" (inst 3 "t3") (("1" (prop) (("1" (reveal -29 -31) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (inst 1 "t2'") (("2" (assert) (("2" (expand "get_args" 1 1) (("2" (assert) (("2" (reveal -9) (("2" (assert) (("2" (hide -1) (("2" (reveal -12 -13) (("2" (hide-all-but (-1 -2 1 3)) (("2" (rewrite "member_unif_prb_equiv") (("2" (inst 1 "unif_pair1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "subs_pair2") (("2" (inst?) (("2" (assert) (("2" (lemma "get_args_mem_not_pair") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "subs_func") (("3" (expand "is_ac_sym?" -2) (("3" (flatten) (("3" (inst?) (("3" (expand "func?" -1) (("3" (assert) (("3" (expand "same_func?" -1) (("3" (flatten) (("3" (expand "sym" -3) (("3" (assert) (("3" (hide 2 4 -9 -10) (("3" (expand "ord" -2) (("3" (assert) (("3" (lift-if -2) (("3" (assert) (("3" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (lemma "get_args_mem_not_ac") (("2" (inst?) (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (reveal -13) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "subset_antisymmetric") (("1" (hide 2) (("1" (expand "subset?" 1) (("1" (skolem 1 "X") (("1" (prop) (("1" (lemma "apply_ac_step_vars_under2more") (("1" (reveal -1 -2) (("1" (inst -3 "ac_sol1" "input`2" "input`1" "input`4") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "X") (("2" (prop) (("2" (reveal -26 -13) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (reveal -15 -17) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (rewrite "mimic_var_append") (("2" (lemma "image_composition[variable, variable, variable]") (("2" (inst?) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "image_subset[variable, variable]") (("2" (inst -1 "vars_under2more(append(input`1, input`2))" "image(mimic_var(sigma), vars_under2more(unif_prb))" "mimic_var(sigma_1n)") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "X") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "X1") (("2" (prop) (("2" (lemma "next_input_vars_under2more") (("2" (inst -1 "(unseen_unif_prb, seen_unif_prb, null, vars2avoid)" "(input`1, input`2, input`3, input`4)") (("2" (assert) (("2" (prop) (("1" (reveal -25) (("1" (replace -1) (("1" (expand "subset?" -2) (("1" (inst -2 "X1") (("1" (assert) (("1" (expand "unif_prb" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "next_input?" 1) (("2" (reveal -35 -36 -37 -38 -39 -40 -41 -42) (("2" (replace -8 :hide? t) (("2" (replace -7 :hide? t) (("2" (replace -6 :hide? t) (("2" (replace -5 :hide? t) (("2" (replace -4 :hide? t) (("2" (replace -3 :hide? t) (("2" (replace -2 :hide? t) (("2" (replace -1 :hide? t) (("2" (reveal -29 -32) (("2" (assert) (("2" (reveal 7) (("2" (expand "t" 2) (("2" (expand "s" 2) (("2" (expand "unif_pair") (("2" (assert) (("2" (hide 1) (("2" (hide -2) (("2" (case "(input`1, input`2, input`3, input`4) = input") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -12) (("3" (expand "unif_prb" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -14 -15 -6) (("2" (rewrite "no_var_pair_append") (("2" (prop) (("1" (replace -2) (("1" (rewrite "apply_sub_no_var_pair") (("1" (expand "unif_prb") (("1" (rewrite "no_var_pair_append") (("1" (prop) (("1" (expand "no_var_pair?" 1) (("1" (expand "no_var_pair?" -1) (("1" (skolem 1 "t1") (("1" (inst -1 "t1") (("1" (assert) (("1" (flatten) (("1" (expand "member" -2 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (rewrite "no_var_pair_append") (("2" (prop) (("1" (reveal -3 -25 -27) (("1" (replace -2 :dir rl) (("1" (lemma "instantiate_step_mem2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (prop) (("1" (lemma "instantiate_step_no_var_pair") (("1" (inst?) (("1" (assert) (("1" (replace -6 -1 :dir rl) (("1" (lemma "solve_ac_no_pair") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_no_var_pair") (("2" (expand "unif_prb" -1) (("2" (rewrite "no_var_pair_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -11) (("2" (replace -1) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (reveal -5 -6 -7) (("2" (expand "all_ac_prb?" -4) (("2" (inst -4 "car(unseen_unif_prb)") (("2" (expand "member" -4) (("2" (reveal 1) (("2" (assert) (("2" (expand "ac_prb?" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) nil (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) nil (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (apply_sub_len formula-decl nil unification nil) (no_var_pair_append formula-decl nil unification nil) (instantiate_step_no_var_pair formula-decl nil aux_unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (apply_sub_no_var_pair formula-decl nil unification nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (member_unif_prb_append formula-decl nil unification nil) (apply_sub_mem formula-decl nil unification nil) (member const-decl "bool" unification nil) (mem_lst2set formula-decl nil list_theory nil) nil (vars const-decl "finite_set[variable]" unification nil) (finset2list_mem formula-decl nil list_theory nil) nil (lhs const-decl "args" unification nil) (subs_append2 formula-decl nil substitution nil) (first_proj_mem formula-decl nil list_theory2 nil) (solve_ac_mem_lhs formula-decl nil aux_unification nil) (solve_ac_rhs_is_temp formula-decl nil aux_unification nil) (instantiate_step_not_temp_unif_pair formula-decl nil aux_unification nil) (term_ac_app_eta formula-decl nil term_adt nil) (args_subs_ac formula-decl nil substitution nil) (term_variable_eta formula-decl nil term_adt nil) (dom const-decl "finite_set[variable]" substitution nil) nil (mimic_var_append formula-decl nil termination_alg nil) (mimic_var_cor formula-decl nil termination_alg nil) (O const-decl "T3" function_props nil) nil (mimic_var_sec_proj formula-decl nil termination_alg nil) (/= const-decl "boolean" notequal nil) (apply_ac_step_sub formula-decl nil apply_ac_step nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) nil (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (im_under_var formula-decl nil term_properties nil) (vars_subterm formula-decl nil term_properties nil) (disjoint? const-decl "bool" sets nil) (subterms_mem_unif_prb formula-decl nil unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (solve_ac_vars_rhs formula-decl nil aux_unification nil) (vars_unif_prb formula-decl nil unification nil) (vars_get_args formula-decl nil term_properties nil) (vars_args formula-decl nil term_properties nil) (singleton const-decl "(singleton?)" sets nil) (solve_ac_lhs_im_under formula-decl nil aux_unification nil) (member_append formula-decl nil list_theory nil) (subterm_reflexive formula-decl nil term_properties nil) nil (mem_list2set formula-decl nil list_theory nil) (im_under def-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) (func? const-decl "bool" term_properties nil) (sym const-decl "string" term_properties nil) (dif_func? const-decl "bool" term_properties nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (subs const-decl "term" substitution nil) (apply_ac_step_sub_dom formula-decl nil apply_ac_step nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) nil (instantiate_step_sub_nice formula-decl nil aux_unification nil) (mimic_var_dom formula-decl nil termination_alg nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) nil (instantiate_step_get_args formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (get_args_not_pair_ac formula-decl nil term_properties nil) (ord const-decl "upto(5)" term_adt nil) (get_args_mem_not_pair formula-decl nil term_properties nil) (get_args_mem_not_ac formula-decl nil term_properties nil) (all_var?_args formula-decl nil term_properties nil) (solve_ac_mem_rhs formula-decl nil aux_unification nil) (member_lhs_rhs formula-decl nil unification nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (subs_func formula-decl nil substitution nil) (same_func? const-decl "bool" term_properties nil) (subs_pair2 formula-decl nil substitution nil) (map_member4 formula-decl nil map_theory nil) nil nil (ac_app adt-constructor-decl "[[ac_symbol, term] -> (ac_app?)]" term_adt nil) (subs_ac formula-decl nil substitution nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) nil (member_unif_prb_equiv formula-decl nil unification nil) (image_composition formula-decl nil function_props nil) (image_subset formula-decl nil function_image nil) (next_input_vars_under2more formula-decl nil termination_alg nil) nil nil nil (next_input? const-decl "bool" apply_ac_step nil) (append_null formula-decl nil list_props nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) (finset2list def-decl "list[T]" list_theory nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) nil (apply_ac_step_vars_under2more formula-decl nil termination_alg nil) nil (union const-decl "set" sets nil) nil nil nil (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (subset_antisymmetric formula-decl nil sets_lemmas nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) nil nil (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) nil (args type-eq-decl nil term_properties nil) nil (OR const-decl "[bool, bool -> bool]" booleans nil) nil (no_var_pair? const-decl "bool" unification nil) nil (mimic_var def-decl "variable" termination_alg nil) nil nil (= const-decl "[T, T -> boolean]" equalities nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("termination_alg" termination_alg apply_ac_adm_subterms_subset 0 (apply_ac_adm_subterms_subset-1 nil 3850139337 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 ("unseen_unif_prb")) (("" (prop) (("" (hide -1) (("" (skeep) (("" (hide -3) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (decompose-equality -1) (("1" (replace -1) (("1" (replace -2) (("1" (hide-all-but 1) (("1" (expand "subset?" 1) (("1" (skolem 1 "t") (("1" (prop) (("1" (expand "image" 1) (("1" (expand "member" 1) (("1" (inst 1 "t") (("1" (expand "subs" 1) (("1" (propax) nil nil)) nil) ("2" (expand "admissible_subterms" -1) (("2" (expand "member" -1 1) (("2" (skolem -1 "tS") (("2" (flatten) (("2" (expand "admissible_subterms" 1) (("2" (inst 1 "tS") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (reveal -2) (("1" (inst -1 "cdr(unseen_unif_prb)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (reveal -2) (("1" (assert) (("1" (prop) (("1" (expand "subset?" 2) (("1" (skeep) (("1" (hide -4 -6) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "member") (("1" (expand "image") (("1" (skeep) (("1" (inst 2 "x_1") (("1" (typepred "x_1") (("1" (hide -1) (("1" (expand "admissible_subterms") (("1" (skeep) (("1" (inst 1 "t") (("1" (assert) (("1" (expand "append" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "subset_antisymmetric[variable]") (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (lemma "apply_ac_step_vars_under2more") (("1" (inst?) (("1" (assert) (("1" (rewrite "no_var_pair_append") (("1" (use "all_ac_prb_no_var_pair") (("1" (assert) (("1" (expand "all_ac_prb?") (("1" (skeep) (("1" (inst -5 "unif_pair") (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (hide -3 -5) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand ("member" "image")) (("2" (skeep) (("2" (inst 1 "x_1") (("2" (typepred "x_1") (("2" (expand "vars_under2more") (("2" (skeep) (("2" (inst 1 "t" "s") (("2" (assert) (("2" (expand "append" 1) (("2" (expand "subterms" 1) (("2" (expand ("member" "union")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("1" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (prop) (("2" (lemma "input_apply_ac_step_mem") (("2" (reveal -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 ("unif_prbCI" "sigma")) (("2" (prop) (("2" (rewrite "append_null") (("2" (name-replace "unif_prb1" "append(input`1, input`2)") (("2" (hide -7) (("2" (hide -3 -4 -5 -6) (("2" (hide -1 -2) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (prop) (("2" (hide -5) (("2" (reveal -5 -6 -7 -8) (("2" (replace -3) (("2" (replace -6) (("2" (replace -7) (("2" (hide -6 -7 -8) (("2" (hide -1 -2 -3 -4) (("2" (reveal -24) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst? -1) (("1" (assert) (("1" (case "vars_under2more(ac_sol1`1) = image(mimic_var(ac_sol1`2), vars_under2more(append(input`1, input`2)))") (("1" (assert) (("1" (prop) (("1" (hide -2 -5) (("1" (case "subset?(admissible_subterms(append(input`1, input`2)), image(subs(sigma),
                                               admissible_subterms(append(unseen_unif_prb, seen_unif_prb))))") (("1" (lemma "image_subset[term, term]") (("1" (inst -1 "admissible_subterms(append(input`1, input`2))" "image(subs(sigma), admissible_subterms(append(unseen_unif_prb, seen_unif_prb)))" "subs(ac_sol1`2)") (("1" (assert) (("1" (hide -2) (("1" (expand "subset?" 3) (("1" (skolem 3 "t1") (("1" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "t1") (("1" (assert) (("1" (hide -5) (("1" (expand "subset?" -1) (("1" (inst -1 "t1") (("1" (assert) (("1" (hide -2) (("1" (expand "member" -1) (("1" (expand "image" -1) (("1" (skolem -1 "t2") (("1" (typepred "t2") (("1" (hide -1) (("1" (skolem -1 "t3") (("1" (replace -1) (("1" (hide -1) (("1" (expand "member" 3) (("1" (expand "image" 3) (("1" (typepred "t3") (("1" (hide -1) (("1" (inst 3 "t3") (("1" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide -1) (("2" (hide -1) (("2" (expand "subset?" 1) (("2" (skolem 1 "t1s") (("2" (prop) (("2" (name-replace "unif_prb" "append(unseen_unif_prb, seen_unif_prb)") (("2" (reveal -12) (("2" (replace -1) (("2" (hide -1) (("2" (reveal -13) (("2" (reveal -21) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "instantiate_step_mem2") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (flatten) (("2" (hide-all-but (-5 2)) (("2" (name-replace "unif_prb05" "append(cdr(unseen_unif_prb), append(unif_prbC, seen_unif_prb))") (("2" (hide -1) (("2" (expand "admissible_subterms" -1) (("2" (expand "member" -1 1) (("2" (skolem -1 "t1") (("2" (flatten) (("2" (case "EXISTS t: member(t, unif_prb05) AND t1 = subs(sigma)(t) AND NOT var?(t)") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2) (("1" (hide -2) (("1" (lemma "adm_subterms_subs2") (("1" (case "inst_step_nice?(unif_prbC, ac_sym(t))") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (expand "unif_prb05") (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (case "member(t2, unif_prbC)") (("1" (hide -4) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (expand "image" -2) (("1" (expand "member" -2 1) (("1" (skolem -2 "t2s") (("1" (typepred "t2s") (("1" (hide -1) (("1" (expand "member" 2 1) (("1" (expand "image" 2) (("1" (inst 2 "t2s") (("1" (expand "admissible_subterms" 1) (("1" (hide -4 -5 -6) (("1" (reveal -9 -37) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_mem_lhs") (("1" (inst?) (("1" (inst -1 "t2") (("1" (assert) (("1" (prop) (("1" (reveal -42 -43 -44) (("1" (inst 1 "t") (("1" (expand "unif_prb" 1) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil) ("2" (lemma "adm_subterms_trans") (("2" (inst -1 "t" "t2" "t2s") (("2" (assert) (("2" (expand "member" 1 1) (("2" (lemma "get_args_subterms2") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -42 -43 -44) (("2" (inst 1 "s") (("2" (expand "unif_prb" 1) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil) ("2" (lemma "adm_subterms_trans") (("2" (inst -1 "s" "t2" "t2s") (("2" (assert) (("2" (expand "member" 1 1) (("2" (lemma "get_args_subterms2") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "adm_subterms_solve_ac") (("2" (reveal -5 -33) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst?) (("2" (assert) (("2" (expand "member" -4) (("2" (expand "image" -4) (("2" (skolem -4 "t2s") (("2" (typepred "t2s") (("2" (hide -1) (("2" (case "member(t2s, admissible_subterms(rhs(unif_prbC)))") (("1" (replace -4) (("1" (expand "member" -1) (("1" (expand "emptyset" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "admissible_subterms" 1) (("2" (inst 1 "t2") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "member" -1) (("2" (expand "image" -1) (("2" (skolem -1 "t2s") (("2" (typepred "t2s") (("2" (hide -1) (("2" (expand "member" 3) (("2" (expand "image" 3) (("2" (inst 3 "t2s") (("2" (expand "admissible_subterms" 1) (("2" (inst 1 "t2") (("2" (expand "member" 1 2) (("2" (expand "unif_prb" 1) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "adm_subterms_inst_step2") (("2" (inst -1 "ac_sym(t)" "unif_prbC") (("2" (assert) (("2" (name-replace "unif_prbA" "{t_1: term[constant, variable, f_symbol, ac_symbol] | member(t_1, unif_prbC) AND
                                                                             is_ac_sym? (t_1, ac_sym(t))}") (("2" (name-replace "unif_prbB" "{t_1: term[constant, variable, f_symbol, ac_symbol] | member(t_1, unif_prbC) AND
                                                                          NOT is_ac_sym?(t_1, ac_sym(t))}") (("2" (reveal -9) (("2" (replace -1 :dir rl) (("2" (expand "subset?" -2) (("2" (inst -2 "t1s") (("2" (assert) (("2" (hide -5 -6 -7 1) (("2" (reveal -11 -39) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "adm_subterms_solve_ac_lhs_rhs") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (reveal -6 -7) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (prop) (("2" (hide -6 -7) (("2" (expand "member" -5) (("2" (expand "union" -5) (("2" (prop) (("1" (hide -3) (("1" (expand "member" -1) (("1" (expand "image" -1) (("1" (skolem -1 "t2s") (("1" (typepred "t2s") (("1" (hide -1) (("1" (expand "subset?" -3) (("1" (inst -3 "t2s") (("1" (expand "member" -3 1) (("1" (lemma "adm_subterms_solve_ac") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (expand "member" -4) (("1" (expand "emptyset" -4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "member" -1) (("2" (expand "image" -1) (("2" (skolem -1 "t2s") (("2" (typepred "t2s") (("2" (hide -1) (("2" (expand "subset?" -3) (("2" (inst -3 "t2s") (("2" (assert) (("2" (expand "member" -3 1) (("2" (expand "non_var_subterms" -3) (("2" (expand "member" -3 1) (("2" (skolem -3 "t2sS") (("2" (prop) (("2" (lemma "solve_ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "t2sS") (("2" (assert) (("2" (prop) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "t2s") (("1" (expand "admissible_subterms" 1) (("1" (inst 1 "t") (("1" (prop) (("1" (reveal -50 -51 -52) (("1" (expand "unif_prb" 1) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "adm_subterms_nvs_trans") (("2" (inst -1 "t" "t2sS" "t2s") (("2" (assert) (("2" (expand "admissible_subterms" 1) (("2" (expand "member" 1 1) (("2" (lemma "get_args_prop_subterms") (("2" (inst? -1) (("2" (assert) (("2" (split 1) (("1" (prop) (("1" (hide-all-but 1) (("1" (reveal -60 -59 -31) (("1" (expand "is_ac_sym?") (("1" (expand "all_ac_prb?") (("1" (inst -1 "unif_pair") (("1" (expand "member") (("1" (assert) (("1" (expand "ac_prb?" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -7)) (("2" (expand "non_var_subterms" -2) (("2" (expand "member" -2) (("2" (expand "subterms" -2) (("2" (assert) (("2" (expand "singleton" -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "image" 1) (("2" (inst 1 "t2s") (("2" (expand "admissible_subterms" 1) (("2" (inst 1 "s") (("2" (prop) (("1" (reveal -50 -52) (("1" (expand "unif_prb") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "adm_subterms_nvs_trans") (("2" (inst -1 "s" "t2sS" "t2s") (("2" (assert) (("2" (expand "admissible_subterms" 1) (("2" (expand "member" 1 1) (("2" (prop) (("1" (lemma "get_args_prop_subterms") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (reveal -58 -59 -60 -31) (("1" (expand "is_ac_sym?" 1) (("1" (expand "all_ac_prb?" -1) (("1" (inst -1 "unif_pair") (("1" (expand "member" -1) (("1" (assert) (("1" (expand "ac_prb?" -1) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem -1 ("X" "t3")) (("3" (flatten) (("3" (case "NOT var?(t1s)") (("1" (case "member(t1s, img(sigma))") (("1" (lemma "instantiate_step2_mem") (("1" (inst -1 "t1s" "unif_prbC") (("1" (reveal -7) (("1" (assert) (("1" (assert) (("1" (skolem -2 "t4") (("1" (flatten) (("1" (replace -1 :dir rl) (("1" (rewrite "member_lhs_rhs") (("1" (hide -8) (("1" (prop) (("1" (hide-all-but (-3 -1 4)) (("1" (expand "member" 1) (("1" (expand "image" 1) (("1" (inst 1 "t4") (("1" (reveal -14 -42) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_mem_lhs") (("1" (inst?) (("1" (inst -1 "t4") (("1" (assert) (("1" (expand "admissible_subterms" 1) (("1" (reveal 2) (("1" (prop) (("1" (inst 2 "t") (("1" (prop) (("1" (reveal -47 -48 -49) (("1" (expand "unif_prb" 1) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "admissible_subterms" 1) (("2" (prop) (("2" (lemma "get_args_prop_subterms") (("2" (inst?) (("2" (assert) (("2" (reveal -21 -48 -49 50) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (assert) (("2" (reveal -51) (("2" (expand "member" -2) (("2" (assert) (("2" (expand "ac_prb?" -2) (("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -47 -48 -49 -20) (("2" (inst 2 "s") (("2" (prop) (("1" (expand "unif_prb" 1) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "admissible_subterms" 1) (("2" (expand "member" 1 1) (("2" (prop) (("2" (lemma "get_args_prop_subterms") (("2" (inst?) (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (expand "all_ac_prb?") (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (expand "ac_prb?" -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_mem_rhs") (("2" (hide -3 -5 -10 -11 -12) (("2" (reveal -5) (("2" (reveal -10 -38) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (inst? -3) (("2" (inst -3 "t4") (("2" (assert) (("2" (flatten) (("2" (expand "is_ac_sym?" -3) (("2" (name-replace "f" "ac_sym(t)") (("2" (flatten) (("2" (lemma "term_ac_app_eta") (("2" (inst -1 "t4") (("2" (replace -5 :dir rl) (("2" (replace -1 -8 :dir rl) (("2" (rewrite "subs_ac") (("2" (assert) (("2" (case "idempotent?(sigma)") (("1" (case "nice?(sigma)") (("1" (case "member(X, dom(sigma))") (("1" (case "member(X, vars_under2more(unif_prb))") (("1" (hide-all-but (-1 -15 2)) (("1" (name-replace "X1" "mimic_var(sigma)(X)") (("1" (lemma "mimic_var_dom") (("1" (reveal -2) (("1" (inst -2 "X" "sigma") (("1" (assert) (("1" (replace -3) (("1" (reveal -38 -39) (("1" (name-replace "sigma_1n" "ac_sol1`2") (("1" (name-replace "sigma_0n" "append(sigma_1n, sigma)") (("1" (case "NOT member(X1, dom(sigma_1n))") (("1" (case "member(X1, image(mimic_var(sigma_0n), vars_under2more(append(unseen_unif_prb, seen_unif_prb))))") (("1" (replace -3 :dir rl) (("1" (replace -2) (("1" (expand "member" -1) (("1" (expand "image" -1) (("1" (skolem -1 "X2") (("1" (typepred "X2") (("1" (case "X2 = X1") (("1" (replace -1) (("1" (hide-all-but (-2 -7 1)) (("1" (reveal -57 -58) (("1" (expand "vars_under2more" -3) (("1" (skolem -3 ("t5" "s5")) (("1" (prop) (("1" (hide -3 -5 -7) (("1" (lemma "im_under_var") (("1" (inst?) (("1" (assert) (("1" (hide -4) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -4 "t5S") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (case "member(X1, vars(t5S))") (("1" (hide -2 1 -5) (("1" (prop) (("1" (replace -3) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t6") (("1" (prop) (("1" (replace -2) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (reveal -21) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X1") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (lemma "instantiate_step1_mem") (("1" (inst -1 "t5S" "unif_prbC") (("1" (reveal -47) (("1" (assert) (("1" (assert) (("1" (skolem -2 "t6") (("1" (flatten) (("1" (reveal -48) (("1" (replace -1 :dir rl) (("1" (replace -4 -6) (("1" (hide-all-but (-6 -9)) (("1" (reveal -24) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -2) (("1" (expand "empty?" -2) (("1" (inst -2 "X1") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t6") (("2" (prop) (("2" (replace -2) (("2" (hide-all-but (-3 -6)) (("2" (reveal -22) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "X1") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t5" "t5S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mimic_var_sec_proj") (("2" (inst?) (("2" (assert) (("2" (replace -3) (("2" (replace -3 :dir rl) (("2" (hide -4 -5) (("2" (hide -2) (("2" (lemma "apply_ac_step_sub") (("2" (hide -3 -8 3 -7) (("2" (reveal -45) (("2" (inst?) (("2" (inst -2 "X1") (("2" (assert) (("2" (expand "sigma_1n") (("2" (assert) (("2" (prop) (("1" (reveal -59 -15) (("1" (replace -2 -3) (("1" (hide -2) (("1" (rewrite "vars_unif_prb" -2) (("1" (skolem -2 "t6") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -2 "t6p") (("1" (prop) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 -2 -9)) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X1") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -62) (("2" (replace -1) (("2" (hide -3 2 3) (("2" (hide -1) (("2" (expand "new_vars2avoid" 1) (("2" (reveal -43) (("2" (lemma "instantiate_step_dom2") (("2" (replace -2 -5) (("2" (inst?) (("2" (inst -1 "X1") (("2" (assert) (("2" (replace -2 :dir rl) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (reveal -21) (("2" (inst -2 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "variable(X1)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand "member" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "lst_vars2avoid") (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (reveal -80 -81 -82) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "image" 1) (("2" (inst 1 "X") (("1" (reveal -1) (("1" (replace -1 :dir rl) (("1" (rewrite "mimic_var_append") (("1" (expand "o" 1) (("1" (replace -6) (("1" (lemma "mimic_var_cor") (("1" (expand "member" 2) (("1" (expand "dom" 2) (("1" (flatten) (("1" (inst -1 "X1" "sigma_1n") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "unif_prb" -6) (("2" (expand "member" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -6 -7 -8 1) (("2" (reveal -43) (("2" (lemma "apply_ac_step_sub_dom") (("2" (inst?) (("2" (inst -1 "X1") (("2" (assert) (("2" (expand "sigma_1n" -3) (("2" (assert) (("2" (prop) (("1" (hide -2) (("1" (reveal -57 -13) (("1" (replace -2) (("1" (rewrite "vars_unif_prb" -3) (("1" (skolem -3 "t5") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -3 "t5p") (("1" (prop) (("1" (replace -4) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst -1 "sigma") (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X1") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -60) (("2" (replace -1) (("2" (expand "new_vars2avoid" 1) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (reveal -15) (("2" (inst?) (("2" (inst -2 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (reveal -42) (("1" (replace -1 -7) (("1" (lemma "instantiate_step_dom2") (("1" (inst -1 "X1" "unif_prbC") (("1" (assert) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "variable(X1)") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "vars" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (reveal -74 -75 -76) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -7 -9 -10 -14 -15 2 3 5) (("2" (reveal -13) (("2" (case "member(t2, subterms(unif_prb))") (("1" (lemma "instantiate_step_dom2") (("1" (inst?) (("1" (reveal -24) (("1" (inst -2 "unif_prbC") (("1" (assert) (("1" (assert) (("1" (hide -1) (("1" (rewrite "member_lhs_rhs") (("1" (prop) (("1" (lemma "solve_ac_lhs_im_under") (("1" (inst?) (("1" (inst -1 "X") (("1" (assert) (("1" (case "is_ac_sym?(t, f) AND is_ac_sym?(s, f)") (("1" (flatten) (("1" (assert) (("1" (skolem -3 "t5") (("1" (flatten) (("1" (hide -4) (("1" (expand "vars_under2more" 1) (("1" (expand "member" 1 1) (("1" (inst 1 "t3" "t5") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-10 -11 1 -13 -1 -2)) (("1" (use "im_under_implies_func") (("1" (assert) (("1" (hide -6) (("1" (reveal -9 -11) (("1" (hide -7) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -5 1)) (("2" (rewrite "subterms_mem_unif_prb") (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -1 "t2S") (("2" (inst 1 "t2S") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "subterm_transitive") (("2" (inst -1 "t3" "t2" "t2S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (reveal -12 -68 -69 -70) (("3" (rewrite "subterms_mem_unif_prb") (("3" (inst 1 "t5") (("3" (expand "unif_prb" 1) (("3" (rewrite "member_unif_prb_append") (("3" (expand "member" 1 2) (("3" (expand "is_ac_sym?") (("3" (prop) (("1" (rewrite "subterm_reflexive") nil nil) ("2" (assert) nil nil) ("3" (rewrite "subterm_reflexive") nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -40 -67 -68 -69) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "is_ac_sym?") (("2" (expand "ac_prb?" -1) (("2" (flatten) (("2" (assert) (("2" (expand "f") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_vars_rhs") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "lst_vars2avoid" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -2 "t2S") (("2" (prop) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand ("member" "union") 2) (("2" (prop) (("2" (expand "unif_prb" -3) (("2" (rewrite "member_unif_prb_append") (("2" (case "member(X, vars(t2S))") (("1" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2S") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2S") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-11 -12 -2 1)) (("2" (lemma "vars_subterm") (("2" (inst -1 "X" "t2" "t2S") (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst -1 "X" "t3" "t2") (("2" (assert) (("2" (lemma "im_under_var") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "unif_prb05") (("2" (case "NOT pair?(t2)") (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 2 "t2") (("1" (expand "unif_prb" 2 1) (("1" (rewrite "member_unif_prb_append") (("1" (expand "member" 2 2) (("1" (assert) (("1" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (prop) (("1" (lemma "solve_ac_mem_lhs") (("1" (inst?) (("1" (inst -1 "t2") (("1" (assert) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 2 "t") (("1" (prop) (("1" (use "get_args_subterms2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "unif_prb") (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (reveal -64 -65 -66) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 2 "s") (("2" (prop) (("1" (use "get_args_subterms2") (("1" (assert) nil nil)) nil) ("2" (expand "unif_prb" 1) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (hide-all-but 1) (("2" (reveal -64 -65 -66) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_mem_rhs") (("2" (inst?) (("2" (inst -1 "t2") (("2" (assert) (("2" (expand "is_ac_sym?" -1) (("2" (flatten) (("2" (expand "subterms" -12) (("2" (assert) (("2" (expand "member" -12) (("2" (expand "union" -12) (("2" (prop) (("1" (expand "singleton" -1) (("1" (expand "member" -1) (("1" (replace -1) (("1" (expand "dif_func?" -9) (("1" (expand "func?" -9) (("1" (assert) (("1" (prop) (("1" (expand "ord" 1) (("1" (propax) nil nil)) nil) ("2" (expand "sym" 1) (("2" (assert) (("2" (replace -3 :dir rl) (("2" (replace -10 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_union_map") (("2" (skolem -1 "ti") (("2" (prop) (("2" (replace -4 :dir rl) (("2" (rewrite "all_var?_args") (("2" (inst -5 "ti") (("2" (assert) (("2" (expand "subterms" -2) (("2" (expand "member" -2) (("2" (expand "singleton" -2) (("2" (replace -2 :dir rl) (("2" (expand "im_under?" -13) (("2" (expand "im_under" -13) (("2" (assert) (("2" (expand "member" -13) (("2" (expand "emptyset" -13) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "subterms_mem_unif_prb") (("3" (inst 2 "t2") (("3" (expand "unif_prb" 2) (("3" (rewrite "member_unif_prb_append") (("3" (assert) (("3" (rewrite "subterm_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -25 -55) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (expand "all_ac_prb?" -2) (("1" (rewrite "member_unif_prb_equiv") (("1" (skolem -1 "unif_pair1") (("1" (inst -2 "unif_pair1") (("1" (expand "member" -2) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "ac_prb?" -3) (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (lemma "solve_ac_no_pair") (("1" (inst?) (("1" (assert) (("1" (expand "no_pair?" -1) (("1" (inst -1 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_var_pair?" -3) (("2" (inst -3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (reveal -16) (("2" (lemma "instantiate_step_sub_nice") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -16) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "img" 1) (("2" (inst 1 "X") (("2" (assert) (("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "admissible_subterms" -9) (("2" (expand "member" -9 1) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (replace -1 1) (("4" (rewrite "instantiate_step_no_pair_img") (("4" (hide 2 3 4 -1 -2 -3 -4 -5) (("4" (reveal -8 -36) (("4" (replace -2 -1 :dir rl) (("4" (lemma "solve_ac_no_pair") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "inst_step_nice?" 1) (("2" (hide -1) (("2" (prop) (("1" (skolem 1 ("X" "t3" "t4")) (("1" (reveal -6) (("1" (replace -1 1 :dir rl) (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -3 "t3S") (("1" (prop) (("1" (rewrite "member_lhs_rhs") (("1" (case "member(t3S, rhs(unif_prbC))") (("1" (hide -5) (("1" (hide-all-but (-1 -4 -5 2)) (("1" (reveal -9 -37) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (lemma "solve_ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "t3S") (("1" (assert) (("1" (prop) (("1" (expand "subterms" -4) (("1" (assert) (("1" (expand ("member" "singleton") -4) (("1" (replace -4) (("1" (expand "im_under?" -5) (("1" (expand "im_under" -5) (("1" (expand ("member" "emptyset") -5) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_ac_sym?" -1) (("2" (flatten) (("2" (expand "subterms" -6) (("2" (assert) (("2" (expand "member" -6) (("2" (expand "union" -6) (("2" (prop) (("1" (expand "member" -1) (("1" (expand "singleton" -1) (("1" (expand "is_ac_sym?" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "mem_union_map") (("2" (skolem -1 "t3_S1") (("2" (prop) (("2" (replace -4) (("2" (rewrite "all_var?_args") (("2" (inst -5 "t3_S1") (("2" (assert) (("2" (expand "member" -2) (("2" (expand "subterms" -2) (("2" (expand "singleton" -2) (("2" (replace -2 :dir rl) (("2" (expand "im_under?" -8) (("2" (expand "im_under" -8) (("2" (assert) (("2" (expand "member" -8) (("2" (expand "emptyset" -8) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "member(X, vars_under2more(unif_prb))") (("1" (name-replace "sigma_1n" "ac_sol1`2") (("1" (name-replace "sigma_0n" "append(sigma_1n, sigma)") (("1" (case "member(mimic_var(sigma_0n)(X), image(mimic_var(sigma_0n), vars_under2more(unif_prb)))") (("1" (hide-all-but (-1 -6 2)) (("1" (name-replace "X1" "mimic_var(sigma)(X)") (("1" (case "NOT member(X1, vars(unif_prb1))") (("1" (case "NOT member(X1, vars_under2more(unif_prb1))") (("1" (case "NOT member(X1, image(mimic_var(sigma_1n), vars_under2more(unif_prb1)))") (("1" (reveal -22 -23) (("1" (reveal -1) (("1" (reveal -2) (("1" (replace -1) (("1" (replace -2) (("1" (expand "unif_prb" -6) (("1" (replace -4 :dir rl) (("1" (case "mimic_var(sigma_0n)(X) = X1") (("1" (replace -1) (("1" (replace -4 -7) (("1" (expand "unif_prb1" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -2 :dir rl) (("2" (rewrite "mimic_var_append") (("2" (expand "o" 1) (("2" (replace -5) (("2" (hide-all-but (-7 1 5)) (("2" (case "subs(sigma_1n)(X1) = variable(X1)") (("1" (lemma "mimic_var_cor") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_ac_step_sub_dom") (("2" (hide 2) (("2" (expand "sigma_1n") (("2" (reveal -24) (("2" (inst?) (("2" (inst -2 "X1") (("2" (assert) (("2" (case "member(X1, dom(sigma))") (("1" (case "idempotent?(sigma)") (("1" (prop) (("1" (expand "member" 1) (("1" (expand "dom" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -38) (("2" (hide -5 -6 1 2) (("2" (replace -1) (("2" (rewrite "vars_unif_prb" -2) (("2" (skolem -2 "t5") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t5_p") (("2" (prop) (("2" (replace -3) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -1) (("2" (expand "empty?" -1) (("2" (inst -1 "X1") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4 2) (("3" (reveal -42) (("3" (replace -1) (("3" (expand "new_vars2avoid" 1) (("3" (reveal -22) (("3" (lemma "instantiate_step_dom2") (("3" (inst?) (("3" (inst -1 "X1") (("3" (assert) (("3" (assert) (("3" (lemma "solve_ac_first_proj_sec_proj_vars") (("3" (reveal -22 -50) (("3" (replace -2 :dir rl) (("3" (hide -2) (("3" (inst?) (("3" (inst -2 "unif_prbC") (("3" (assert) (("3" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(X1)") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "vars" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_vars2avoid" 1) (("2" (hide-all-but 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (reveal -59 -60 -61) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand "vars" -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -24) (("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (expand "X1" 1) (("2" (lemma "mimic_var_dom") (("2" (inst?) (("2" (assert) (("2" (lemma "instantiate_step_sub_nice") (("2" (reveal -23) (("2" (replace -1) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (expand "image" -1) (("2" (skolem -1 "X2") (("2" (typepred "X2") (("2" (lemma "mimic_var_sec_proj") (("2" (case "X1 /= X2") (("1" (flatten) (("1" (inst -1 "X2" "sigma_1n") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide-all-but -1) (("1" (lemma "apply_ac_step_sub") (("1" (reveal -8 -26) (("1" (inst -3 "X1" "ac_sol1" "input`2" "input`1" "input`4") (("1" (assert) (("1" (prop) (("1" (reveal -39 3) (("1" (expand "unif_prb1") (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t5") (("1" (prop) (("1" (inst 1 "t5") (("1" (assert) (("1" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -42) (("2" (replace -1) (("2" (hide-all-but 1) (("2" (reveal -6 -8 4) (("2" (lemma "mimic_var_dom") (("2" (inst?) (("2" (assert) (("2" (reveal -25) (("2" (lemma "instantiate_step_sub_nice") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (hide -1) (("2" (replace -3) (("2" (lemma "instantiate_step_dom2") (("2" (inst?) (("2" (inst -1 "X1") (("2" (assert) (("2" (hide -2 -3 -4 -5 1) (("2" (expand "new_vars2avoid" 1) (("2" (reveal -56 -28) (("2" (replace -2 -1 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_first_proj_sec_proj_vars") (("2" (inst?) (("2" (inst -1 "unif_prbC") (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(X1)") (("1" (assert) (("1" (expand "vars" 1) (("1" (expand ("member" "singleton") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "Y") (("2" (prop) (("2" (lemma "mem_lst2set[variable]") (("2" (inst?) (("2" (assert) (("2" (hide -2 -3 2 3) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid") (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (reveal -64 -65 -66) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "vars_under2more" -1) (("2" (expand "member" -1 1) (("2" (skolem -1 ("t5" "s5")) (("2" (prop) (("2" (lemma "im_under_var") (("2" (inst?) (("2" (assert) (("2" (rewrite "subterms_mem_unif_prb") (("2" (skolem -5 "t5S") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "X1" "t5" "t5S") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t5S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mimic_var_dom") (("2" (inst -1 "X" "sigma") (("2" (assert) (("2" (reveal -16) (("2" (lemma "instantiate_step_sub_nice") (("2" (inst?) (("2" (assert) (("2" (case "idempotent?(sigma)") (("1" (hide -1 -2 -3) (("1" (replace -3) (("1" (rewrite "vars_unif_prb" -2) (("1" (skolem -2 "t5") (("1" (prop) (("1" (hide -4 -5 -6 1) (("1" (expand "unif_prb1") (("1" (reveal -39 -40) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (replace -2) (("1" (hide -2 -3) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t5_p") (("1" (prop) (("1" (reveal -4) (("1" (replace -3 -5) (("1" (rewrite "apply_sub_elim_var_t") (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X1") (("1" (expand "member" 1) (("1" (expand "intersection" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst?) (("2" (assert) (("2" (hide -2) (("2" (hide -3) (("2" (replace -3) (("2" (hide -3) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (reveal -22) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "instantiate_step1_mem") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (skolem -1 "t5_p") (("1" (prop) (("1" (reveal -24) (("1" (replace -1 :dir rl) (("1" (replace -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "X1") (("1" (expand "member" 2) (("1" (expand "intersection" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_mem") (("2" (skolem -1 "t5_p") (("2" (prop) (("2" (replace -2 -5) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst?) (("2" (assert) (("2" (expand "disjoint?" -4) (("2" (expand "empty?" -4) (("2" (inst -4 "X1") (("2" (expand "member" 1) (("2" (expand "intersection" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_idempotent3") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "image" 1) (("2" (inst 1 "X") (("2" (expand "member" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "instantiate_step_dom2") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (replace -2 :dir rl) (("2" (prop) (("1" (case "member(variable(X), lhs(unif_prbC))") (("1" (lemma "solve_ac_lhs_im_under") (("1" (hide -3 -4 -5 9 -10 -11 2 5 6) (("1" (reveal -10 -38) (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (inst?) (("1" (inst -2 "X") (("1" (assert) (("1" (case "is_ac_sym?(t, ac_sym(t))") (("1" (assert) (("1" (case "is_ac_sym?(s, ac_sym(t))") (("1" (assert) (("1" (skolem -4 "t'") (("1" (flatten) (("1" (hide -5) (("1" (expand "member" 1) (("1" (expand "vars_under2more" 1) (("1" (inst 1 "t3" "t'") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -2 3 1)) (("1" (reveal -8) (("1" (expand "is_ac_sym?") (("1" (expand "dif_func?") (("1" (reveal -6) (("1" (use "im_under_implies_func") (("1" (assert) (("1" (hide -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -6 -7 1)) (("2" (lemma "solve_ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "t3S") (("2" (assert) (("2" (rewrite "subterms_mem_unif_prb") (("2" (reveal -52 -53 -54) (("2" (prop) (("1" (inst 1 "t") (("1" (assert) (("1" (expand "unif_prb") (("1" (rewrite "member_unif_prb_append") (("1" (expand "member" 1 2) (("1" (lemma "subterm_transitive") (("1" (inst?) (("1" (inst -1 "t3S") (("1" (assert) (("1" (lemma "get_args_subterms") (("1" (inst?) (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "t3S") (("1" (assert) (("1" (rewrite "subterm_reflexive" 1) (("1" (use "get_args_mem_not_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "s") (("2" (expand "unif_prb") (("2" (rewrite "member_unif_prb_append") (("2" (expand "member" 1 2) (("2" (assert) (("2" (lemma "subterm_transitive") (("2" (inst?) (("2" (inst -1 "t3S") (("2" (assert) (("2" (lemma "get_args_subterms") (("2" (inst?) (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "t3S") (("2" (assert) (("2" (rewrite "subterm_reflexive" 1) (("2" (use "get_args_mem_not_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -10 -53 -54 -55) (("3" (expand "unif_prb") (("3" (rewrite "subterms_append") (("3" (assert) (("3" (flatten) (("3" (rewrite "subterms_mem_unif_prb") (("3" (inst 1 "t'") (("3" (split 1) (("1" (rewrite "subterm_reflexive" 1) (("1" (reveal -1 -2) (("1" (prop) (("1" (expand "is_ac_sym?" -3) (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (reveal -23 -50 -51 -52) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (expand "is_ac_sym?") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -23 -50 -51 -52) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "unif_pair") (("2" (expand "member" -1) (("2" (assert) (("2" (expand "is_ac_sym?") (("2" (expand "ac_prb?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_lhs_rhs") (("2" (assert) (("2" (hide-all-but (-1 -4 -5 -6)) (("2" (reveal -10 -38) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "solve_ac_vars_rhs") (("2" (inst?) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "lst_vars2avoid") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_vars2avoid" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (hide 2) (("2" (reveal -43 -44 -45) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (replace -3) (("2" (expand "vars" 1) (("2" (replace -1) (("2" (replace -2) (("2" (expand ("member" "union") 1) (("2" (flatten) (("2" (hide 3) (("2" (lemma "solve_ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "t3S") (("2" (assert) (("2" (lemma "im_under_var") (("2" (inst -1 "X" "t3") (("2" (assert) (("2" (lemma "vars_subterm") (("2" (inst -1 "X" "t3" "t3S") (("2" (assert) (("2" (lemma "vars_get_args") (("2" (prop) (("1" (inst?) (("1" (replace -2 :dir rl) (("1" (rewrite "vars_args") (("1" (inst 1 "t3S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst?) (("2" (replace -2 :dir rl) (("2" (rewrite "vars_args") (("2" (inst 2 "t3S") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4 -32) (("2" (lemma "solve_ac_no_pair") (("2" (replace -3 :dir rl) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -39 -40 -11) (("3" (expand "all_ac_prb?" -1) (("3" (inst -1 "unif_pair") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "ac_prb?" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "unif_prb05") (("2" (expand "unif_prb1") (("2" (hide -2) (("2" (reveal -22 -23) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (rewrite "member_unif_prb_append") (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("1" (use "apply_sub_mem") (("1" (assert) (("1" (skolem -1 "t1_pre") (("1" (inst 1 "t1_pre") (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (flatten) (("1" (assert) (("1" (reveal -8) (("1" (lemma "all_ac_prb_no_var_pair") (("1" (inst? -1) (("1" (assert) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1_pre") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t1_pre") (("2" (inst 1 "t1_pre") (("2" (flatten) (("2" (reveal -7) (("2" (replace -1 :dir rl) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "apply_sub_mem") (("3" (assert) (("3" (skolem -1 "t1_pre") (("3" (prop) (("3" (inst 1 "t1_pre") (("3" (rewrite "member_unif_prb_append") (("3" (rewrite "member_unif_prb_append") (("3" (assert) (("3" (reveal -38) (("3" (expand "no_var_pair?" -1) (("3" (inst -1 "t1_pre") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4 -1 -4) (("2" (reveal -12) (("2" (replace -1 1) (("2" (expand "no_var_pair?" 1) (("2" (skolem 1 "t1") (("2" (flatten) (("2" (hide -3) (("2" (hide -1) (("2" (rewrite "member_unif_prb_append") (("2" (reveal -11 -19) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (lemma "instantiate_step_mem2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "unif_prbC") (("2" (flatten) (("2" (hide 1) (("2" (reveal -22) (("2" (replace -1 :dir rl) (("2" (hide -5) (("2" (hide -1) (("2" (split -4) (("1" (lemma "instantiate_step_no_var_pair") (("1" (inst -1 "unif_prbCI" "unif_prbC") (("1" (assert) (("1" (split -1) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -29) (("2" (use "apply_sub_no_var_pair") (("2" (assert) (("2" (expand "no_var_pair?" -1) (("2" (inst -1 "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (rewrite "subset_antisymmetric" 1) (("1" (hide 2) (("1" (hide-all-but (-1 1)) (("1" (lemma "apply_ac_step_vars_under2more") (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (hide -1) (("1" (reveal -3 -14 -15 -29) (("1" (expand "no_var_pair?" 1) (("1" (skolem 1 "t1") (("1" (flatten) (("1" (rewrite "member_unif_prb_append") (("1" (split -5) (("1" (replace -3) (("1" (lemma "apply_sub_no_var_pair") (("1" (inst? -1) (("1" (assert) (("1" (split -1) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "all_ac_prb_no_var_pair") (("2" (inst? -1) (("2" (prop) (("2" (hide 2) (("2" (expand "all_ac_prb?" 1) (("2" (expand "all_ac_prb?" -1) (("2" (skeep) (("2" (inst -2 "unif_pair!1") (("2" (assert) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (rewrite "member_unif_prb_append") (("2" (split -1) (("1" (hide -2 -3 -4 -5) (("1" (reveal -13) (("1" (reveal -21) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "instantiate_step_mem2") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prbC") (("1" (flatten) (("1" (lemma "instantiate_step_no_var_pair") (("1" (inst -1 "unif_prbCI" "unif_prbC") (("1" (assert) (("1" (split -1) (("1" (expand "no_var_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (hide-all-but (-1 1)) (("2" (reveal -29) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "solve_ac_no_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (lemma "apply_sub_no_var_pair") (("2" (inst? -1) (("2" (assert) (("2" (expand "no_var_pair?" -1) (("2" (inst -1 "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -3) (("2" (rewrite "mimic_var_append") (("2" (hide -3) (("2" (rewrite "image_composition" :dir rl) (("2" (rewrite "image_subset") (("2" (hide 2) (("2" (reveal -13) (("2" (lemma "next_input_vars_under2more") (("2" (inst -1 "(unseen_unif_prb, seen_unif_prb, null, vars2avoid)" "(input`1, input`2, input`3, input`4)") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "next_input?" 1) (("1" (reveal -26 -25 -24 -23 -22 -21 -20 -19) (("1" (replace -8 1 nil t) (("1" (replace -7 1 nil t) (("1" (replace -6 1 nil t) (("1" (replace -5 1 nil t) (("1" (replace -4 1 nil t) (("1" (replace -3 1 nil t) (("1" (replace -2 1 nil t) (("1" (replace -1) (("1" (reveal -16) (("1" (assert) (("1" (reveal 5) (("1" (expand "t" 2) (("1" (expand "s" 2) (("1" (expand "unif_pair" 2) (("1" (assert) (("1" (hide 1) (("1" (hide-all-but (-1 1)) (("1" (case "input = (input`1, input`2, input`3, input`4)") (("1" (replace -1 -2) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -27) (("2" (rewrite "no_var_pair_append") (("2" (assert) (("2" (hide-all-but (-4 1)) (("2" (lemma "all_ac_prb_no_var_pair") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (hide-all-but (-1 1 3)) (("2" (replace -1 1 nil t) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(unseen_unif_prb)") (("1" (reveal -8 -9) (("1" (expand "member" -3) (("1" (assert) (("1" (reveal 1) (("1" (assert) (("1" (expand "ac_prb?" -3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 3) (("2" (expand "all_ac_prb?" -1) (("2" (reveal -6 -7) (("2" (inst -3 "unif_pair") (("2" (expand "member" -3) (("2" (assert) (("2" (expand "ac_prb?" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (append_null formula-decl nil list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) (subs_append2 formula-decl nil substitution nil) (image_subset formula-decl nil function_image nil) (adm_subterms_subs2 formula-decl nil termination_alg nil) (lhs const-decl "args" unification nil) (get_args_subterms formula-decl nil term_properties nil) (get_args_mem_not_pair formula-decl nil term_properties nil) (subterms_append formula-decl nil unification nil) (vars_args formula-decl nil term_properties nil) (vars_get_args formula-decl nil term_properties nil) (mem_lst2set formula-decl nil list_theory nil) (/= const-decl "boolean" notequal nil) nil nil (vars const-decl "finite_set[variable]" unification nil) (subs const-decl "term" substitution nil) nil nil (member_lhs_rhs formula-decl nil unification nil) (adm_subterms_solve_ac formula-decl nil termination_alg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (rhs const-decl "args" unification nil) nil (args type-eq-decl nil term_properties nil) (get_args_subterms2 formula-decl nil term_properties nil) (adm_subterms_trans formula-decl nil termination_alg nil) (solve_ac_mem_lhs formula-decl nil aux_unification nil) nil nil nil nil nil nil (is_ac_sym? const-decl "bool" term_properties nil) nil nil (get_args_prop_subterms formula-decl nil term_properties nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) nil nil (ac_prb? const-decl "bool" unification nil) (adm_subterms_nvs_trans formula-decl nil termination_alg nil) nil nil nil (adm_subterms_solve_ac_lhs_rhs formula-decl nil termination_alg nil) (adm_subterms_inst_step2 formula-decl nil termination_alg nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (solve_ac_mem_rhs formula-decl nil aux_unification nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (nice? def-decl "bool" substitution nil) (apply_ac_step_sub_dom formula-decl nil apply_ac_step nil) (mimic_var_sec_proj formula-decl nil termination_alg nil) nil (instantiate_step_dom2 formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) nil (finset2list_mem formula-decl nil list_theory nil) nil (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (vars_unif_prb formula-decl nil unification nil) nil (apply_ac_step_sub formula-decl nil apply_ac_step nil) (vars_subterm formula-decl nil term_properties nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) nil (subterms_mem_unif_prb formula-decl nil unification nil) (im_under_var formula-decl nil term_properties nil) (mimic_var_append formula-decl nil termination_alg nil) (mimic_var_cor formula-decl nil termination_alg nil) (O const-decl "T3" function_props nil) nil (mimic_var_dom formula-decl nil termination_alg nil) (member_unif_prb_equiv formula-decl nil unification nil) (no_pair? const-decl "bool" unification nil) (solve_ac_no_pair formula-decl nil aux_unification nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) nil (mem_union_map formula-decl nil map_theory nil) (all_var?_args formula-decl nil term_properties nil) (im_under def-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) nil (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (subterm_reflexive formula-decl nil term_properties nil) (subterm_transitive formula-decl nil term_properties nil) (dif_func? const-decl "bool" term_properties nil) (sym const-decl "string" term_properties nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (ord const-decl "upto(5)" term_adt nil) (func? const-decl "bool" term_properties nil) (im_under_implies_func formula-decl nil term_properties nil) (solve_ac_lhs_im_under formula-decl nil aux_unification nil) (solve_ac_vars_rhs formula-decl nil aux_unification nil) (dom const-decl "finite_set[variable]" substitution nil) (instantiate_step_sub_nice formula-decl nil aux_unification nil) (idempotent? const-decl "bool" substitution nil) (subs_ac formula-decl nil substitution nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (term_ac_app_eta formula-decl nil term_adt nil) nil (instantiate_step2_mem formula-decl nil aux_unification nil) (instantiate_step_no_pair_img formula-decl nil aux_unification nil) (inst_step_nice? const-decl "bool" termination_alg nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (apply_sub_no_var_pair formula-decl nil unification nil) (instantiate_step_no_var_pair formula-decl nil aux_unification nil) nil nil nil (next_input? const-decl "bool" apply_ac_step nil) (next_input_vars_under2more formula-decl nil termination_alg nil) (image_composition formula-decl nil function_props nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) nil (finite_union application-judgement "finite_set" finite_sets nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil nil (NOT const-decl "[bool -> bool]" booleans nil) (subset_antisymmetric formula-decl nil sets_lemmas nil) nil (union const-decl "set" sets nil) nil (apply_ac_step_vars_under2more formula-decl nil termination_alg nil) (all_ac_prb_no_var_pair formula-decl nil unification nil) (all_ac_prb? const-decl "bool" unification nil) (no_var_pair_append formula-decl nil unification nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) nil nil nil (member_unif_prb_append formula-decl nil unification nil) (member const-decl "bool" sets nil) nil nil (subset? const-decl "bool" sets nil) (no_var_pair? const-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (mimic_var def-decl "variable" termination_alg nil) nil nil (= const-decl "[T, T -> boolean]" equalities nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("aux_unification" aux_unification instantiate_step_not_fail 0 (instantiate_step_not_fail-1 nil 3850239459 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skeep) (("" (expand "instantiate_step" -3) (("" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "delta" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (reveal -1 -2 -3 -4 -5) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification instantiate_step_unifies_not_fail 0 (instantiate_step_unifies_not_fail-1 nil 3850239631 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skeep) (("" (expand "instantiate_step" -3) (("" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "delta" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (reveal -1 -2 -3 -4 -5) (("1" (prop) (("1" (expand "fail1" -1) (("1" (expand "instantiate_step" -1) (("1" (split -1) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil))("aux_unification" aux_unification inst_step_unifies_sub 0 (inst_step_unifies_sub-1 nil 3850239966 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skeep) (("" (expand "instantiate_step" 1) (("" (prop) (("1" (expand "instantiate_step" 1) (("1" (assert) (("1" (rewrite "append_null") (("1" (expand "equal?") (("1" (skeep) (("1" (expand "subs" 1) (("1" (use "equal?_ref") nil))))))))))))) ("2" (name-replace "t" "car(P)`1") (("2" (name-replace "s" "car(P)`2") (("2" (name-replace "delta" "instantiate_step(t, s)`1") (("2" (expand "instantiate_step" 4 1) (("2" (assert) (("2" (lift-if) (("2" (split 4) (("1" (flatten) (("1" (expand ("t" "s")) (("1" (propax) nil))))) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -1 2) (("1" (reveal -2 -3) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "instantiate_step2_no_effect") (("1" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("1" (replace -1) (("1" (hide -1) (("1" (inst -5 "cdr(P)") (("1" (prop) (("1" (inst -1 "sigma") (("1" (assert) (("1" (prop) (("1" (expand "unifies?" -5) (("1" (flatten) nil))) ("2" (lemma "instantiate_step3_no_effect") (("2" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("2" (assert) nil))))))))))) ("2" (grind) nil))))))))))))))))))))))) ("2" (flatten) (("2" (hide 2) (("2" (expand ("t" "s")) (("2" (propax) nil))))))))))))))))))))))))) ("3" (name-replace "t" "car(P)`1") (("3" (name-replace "s" "car(P)`2") (("3" (name-replace "delta" "instantiate_step(t, s)`1") (("3" (name-replace "skip1" "instantiate_step(t, s)`2") (("3" (name-replace "fail1" "instantiate_step(t, s)`3") (("3" (rewrite "append_null") (("3" (expand "apply_sub" 2 2) (("3" (name-replace "gamma" "instantiate_step(P, null, null)`2") (("3" (reveal -1) (("3" (inst -2 "apply_sub(delta, cdr(P))") (("3" (prop) (("1" (inst -1 "sigma") (("1" (prop) (("1" (reveal -4 -5 -6 -7 -8) (("1" (expand "instantiate_step" -7) (("1" (assert) (("1" (replace -4) (("1" (replace -5) (("1" (replace -3) (("1" (rewrite "append_null") (("1" (expand "apply_sub" -7 2) (("1" (lemma "instantiate_step_sub_append") (("1" (inst -1 "null" "delta" "apply_sub(delta, cdr(P))") (("1" (hide -2 -3) (("1" (assert) (("1" (replace -6) (("1" (name-replace "gamma1" "instantiate_step(apply_sub(delta, cdr(P)), null, null)`2") (("1" (replace -1 5) (("1" (case "equal?(append(sigma, gamma1), append(sigma, append(gamma1, delta)))") (("1" (hide-all-but (-1 -6 5)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -2 "X") (("1" (inst -1 "X") (("1" (expand "subs") (("1" (lemma "equal?_trans") (("1" (inst -1 "subs(sigma)(variable(X))" "subs(append(sigma, gamma1))(variable(X))" "subs(append(sigma, append(gamma1, delta)))(variable(X))") (("1" (assert) nil))))))))))))))))) ("2" (hide 6 -1) (("2" (rewrite "append_assoc" :dir rl) (("2" (case "unifies?(append(sigma, gamma1), P)") (("1" (hide -5 -7) (("1" (expand "unifies?" -1) (("1" (flatten) (("1" (expand "unifies?" -1) (("1" (replace -4) (("1" (replace -5) (("1" (expand "instantiate_step" -3) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (prop) (("1" (name-replace "sigma1" "append(sigma, gamma1)") (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sigma1" "t") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lemma "term_variable_eta") (("1" (inst -1 "s") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma1)(s)" "subs(sigma1)(t)") (("1" (assert) nil))))))))))))))))))))))) ("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (hide-all-but 1) (("2" (expand "equal?") (("2" (skeep) (("2" (expand "subs" 1) (("2" (use "equal?_ref") nil))))))))))))))))) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "sigma1" "append(sigma, gamma1)") (("2" (split -1) (("1" (flatten) (("1" (prop) (("1" (hide 1) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sigma1" "s") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lemma "term_variable_eta") (("1" (inst -1 "t") (("1" (replace -1) (("1" (propax) nil))))))))))))))))))) ("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (hide-all-but 1) (("2" (expand "equal?") (("2" (skeep) (("2" (expand "subs" 1) (("2" (rewrite "equal?_ref") nil))))))))))))))))) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (rewrite "append_null") (("2" (hide-all-but 2) (("2" (expand "equal?") (("2" (skeep) (("2" (use "equal?_ref") nil))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but (-4 -6 1)) (("2" (use "unifies?_equal") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (case "equal?(sigma, append(sigma, delta))") (("1" (rewrite "unifies?_equiv") (("1" (skeep) (("1" (use "apply_sub_unif_pair") (("1" (assert) (("1" (skolem -1 "unif_p1") (("1" (flatten) (("1" (replace -2) (("1" (expand "unifies?" 1) (("1" (expand "apply_sub" 1) (("1" (lemma "unifies?_equal") (("1" (inst -1 "sigma" "append(sigma, delta)" "P") (("1" (assert) (("1" (rewrite "unifies?_equiv") (("1" (inst -1 "unif_p1") (("1" (expand "member" -1 1) (("1" (expand "unifies?" -1) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") nil))))))))))))))))))))))))))))))))))) ("2" (hide 2 7 -1) (("2" (reveal -6) (("2" (reveal -7 -8) (("2" (expand "unifies?" -4) (("2" (assert) (("2" (flatten) (("2" (hide -5) (("2" (expand "unifies?" -4) (("2" (replace -1) (("2" (replace -2) (("2" (expand "instantiate_step" -3) (("2" (lift-if) (("2" (split -3) (("1" (flatten) (("1" (prop) (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sigma" "t") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lemma "term_variable_eta") (("1" (inst -1 "s") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma)(s)" "subs(sigma)(t)") (("1" (assert) nil))))))))))))))))))))) ("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (hide-all-but 1) (("2" (expand "equal?") (("2" (skeep) (("2" (expand "subs" 1) (("2" (use "equal?_ref") nil))))))))))))))))) ("2" (flatten) (("2" (hide 1) (("2" (prop) (("1" (hide 1) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sigma" "s") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lemma "term_variable_eta") (("1" (inst -1 "t") (("1" (replace -1) (("1" (propax) nil))))))))))))))))))) ("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (hide-all-but 1) (("2" (expand "equal?") (("2" (skeep) (("2" (expand "subs" 1) (("2" (use "equal?_ref") nil))))))))))))) ("3" (replace -1 :dir rl) (("3" (rewrite "append_null") (("3" (hide-all-but 2) (("3" (expand "equal?") (("3" (skeep) (("3" (expand "subs" 1) (("3" (use "equal?_ref") nil))))))))))))))))))))))))))))))))))))))))))))))) ("3" (lemma "instantiate_step3_no_effect2") (("3" (inst -1 "delta" "null" "apply_sub(delta, cdr(P))" "null") (("3" (assert) nil))))))))) ("2" (rewrite "apply_sub_len") (("2" (hide-all-but (1 5)) (("2" (grind) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil))("aux_unification" aux_unification solve_ac_complete_no_common 0 (solve_ac_complete_no_common-2 nil 3850308510 ("" (skeep) (("" (expand "unifies?" -1) (("" (lemma "ac_perm_args2") (("" (inst -1 "f" "subs(delta)(s)" "subs(delta)(t)") (("" (assert) (("" (hide -2) (("" (name-replace "args_t" "count_elem2(get_args(f)(t), equal?)`1") (("1" (name-replace "coef_t" "count_elem2(get_args(f)(t), equal?)`2") (("1" (name-replace "args_s" "count_elem2(get_args(f)(s), equal?)`1") (("1" (name-replace "coef_s" "count_elem2(get_args(f)(s), equal?)`2") (("1" (hide -1 -2 -3 -4) (("1" (name-replace "args_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`1") (("1" (name-replace "coef_delta_t" "count_elem2(get_args(f)(subs(delta)(t)), equal?)`2") (("1" (name-replace "B" "calculate_upper_bound(coef_t, coef_s)") (("1" (hide 1) (("1" (hide -8 -9 -10 -11 -12) (("1" (name-replace "delta_args" "subs(delta)(append(args_t, args_s))") (("1" (lemma "dio_solver_coef_matrix") (("1" (inst -1 "map(count_vec(delta_args, f))(args_delta_t)" "coef_t" "coef_s") (("1" (assert) (("1" (replace -3) (("1" (name-replace "D" "dio_solver(coef_t, coef_s, B)") (("1" (case "FORALL row:
                                                                                                                 member(row, map(count_vec(delta_args, f))(args_delta_t)) IMPLIES
                                                                                                                  is_solution?(row, coef_t, coef_s)") (("1" (prop) (("1" (skolem -1 "C") (("1" (name-replace "m" "length(coef_t)") (("1" (name-replace "n" "length(coef_s)") (("1" (name-replace "l" "length(D)") (("1" (prop) (("1" (rewrite "map_length") (("1" (name-replace "k" "length(args_delta_t)") (("1" (name-replace "D1" "construct_submatrix(D, C)`1") (("1" (name-replace "C1" "construct_submatrix(D, C)`2") (("1" (hide -5 -6) (("1" (name-replace "args_" "append(args_t, args_s)") (("1" (name-replace "P1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`1") (("1" (name-replace "V1" "dio_matrix2ac_sol(args_, vars2avoid, f)(D1)`2") (("1" (case "const1?(D1, m+n)") (("1" (hide -10 -9 -11 -13 -14 -15 -7 -4 -5) (("1" (name-replace "lambda1" "construct_sub(D1, C1, args_delta_t, vars2avoid, f)") (("1" (case "unifies?(append(lambda1, delta), P1)") (("1" (reveal 1) (("1" (name-replace "V" "vars2avoid") (("1" (inst 1 "P1" "lambda1" "V1") (("1" (assert) (("1" (prop) (("1" (expand "solve_ac" 1) (("1" (reveal -10) (("1" (lemma "elim_com_arg_no_common_arg") (("1" (inst -1 "f" "s" "t") (("1" (assert) (("1" (prop) (("1" (reveal -26 -27 -28 -29) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide -1 -2 -3 -4 -5 -6 -7) (("1" (reveal -15) (("1" (replace -1) (("1" (rewrite "map_member4") (("1" (inst 1 "D1") (("1" (assert) (("1" (reveal -9 -22) (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "extract_submatrices_mem" :dir rl) (("1" (assert) (("1" (prop) (("1" (expand "D1" 1) (("1" (use "construct_submatrix_get_sublists") nil nil)) nil) ("2" (expand "nice_submatrix?" 1) (("2" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (prop) (("1" (expand "m" 1) (("1" (case "n > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (use "count_elem_len[term]") (("2" (assert) (("2" (expand "length" -1 1) (("2" (expand "length" -1 1) (("2" (replace -1) (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (expand "D" 1) (("2" (use "dio_solver_matrix") (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "if_non_var_const2_cor2") (("3" (assert) (("3" (hide 2) (("3" (skolem 1 "j") (("3" (flatten) (("3" (name-replace "tj" "nth(args_, j)") (("3" (case "is_ac_sym?(tj, f)") (("1" (hide -10 -11 -12 -13 -14 -15 -8 -9) (("1" (expand "is_ac_sym?" -1) (("1" (flatten) (("1" (case "member(tj, args_)") (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (use "get_args_mem_not_ac") (("1" (assert) (("1" (expand "is_ac_sym?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (use "get_args_mem_not_ac") (("2" (assert) (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj" 1) (("2" (rewrite "member_nth2") (("2" (inst 1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -12 -3 -4 -5-2-14 -13) (("2" (use "const2_sum") (("2" (assert) (("2" (hide 4) (("2" (lemma "dio_matrix2ac_is_var_sum") (("2" (inst -1 "args_" "D1" "f" "j" "V") (("2" (assert) (("2" (replace -3) (("2" (split) (("1" (replace -7) (("1" (name-replace "tj_" "nth(P1, j)`2") (("1" (lemma "dio_matrix2ac_mem_rhs") (("1" (inst?) (("1" (inst -1 "tj_") (("1" (assert) (("1" (replace -8) (("1" (assert) (("1" (prop) (("1" (rewrite "unifies?_equiv") (("1" (inst -6 "nth(P1, j)") (("1" (prop) (("1" (expand "unifies?" -1) (("1" (reveal -4 -11) (("1" (replace -1) (("1" (use "dio_matrix2ac_mem_lhs_nth") (("1" (assert) (("1" (replace -11) (("1" (replace -1) (("1" (replace -3) (("1" (name-replace "sigma2" "append(lambda1, delta)") (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sigma2)(tj_)" "subs(sigma2)(tj)") (("1" (assert) (("1" (hide -5) (("1" (expand "is_ac_sym?" -5) (("1" (flatten) (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "tj_") (("1" (replace -7 :dir rl) (("1" (replace -1 -2 :dir rl) (("1" (rewrite "subs_ac") (("1" (expand "equal?" -2) (("1" (flatten) (("1" (hide -4) (("1" (case "is_ac_sym?(subs(sigma2)(tj), f)") (("1" (use "subs_ac3") (("1" (assert) nil nil)) nil) ("2" (expand "is_ac_sym?" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_nth") (("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "P1" 1) (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "tj_" 1) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem" 1) (("2" (inst 1 "nth(P1, j)") (("1" (rewrite "member_nth") (("1" (expand "P1" 1) (("1" (use "dio_matrix2ac_len") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "P1") (("2" (use "dio_matrix2ac_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6) (("2" (expand "D1" 1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) (("2" (assert) (("2" (hide 2 3 4) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "D" 1) (("3" (use "dio_solver_matrix") (("3" (expand "matrix?" 1) (("3" (prop) (("3" (replace -3) (("3" (case "length(car(D)) = length(coef_t) + length(coef_s)") (("1" (assert) nil nil) ("2" (use "matrix_row_len[nat]") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "m + n > 0") (("1" (expand "const1?" -9) (("1" (inst -9 "1") (("1" (assert) (("1" (expand "empty_col?" 1) (("1" (prop) (("1" (skeep) (("1" (expand "get_col_i" -1) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "m") (("2" (expand "coef_t") (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (rewrite "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "supset_dom_correct2") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -4 -1 :dir rl) (("2" (use "construct_sub_mem_dom") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 1) (("1" (reveal -5) (("1" (replace -1) (("1" (use "dio_matrix2ac_new_vars") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "V" -1) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (expand "V" -1) (("2" (use "select_greater_lt[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "mem_list2set" :dir rl) (("3" (replace -3 -1 :dir rl) (("3" (use "construct_sub_vars_img") (("3" (assert) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "args_delta_t" -1) (("3" (rewrite "vars_count_elem2") (("3" (rewrite "vars_get_args") (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand "member" -1) (("3" (expand "union" -1) (("3" (hide -2) (("3" (expand "V1" 1) (("3" (hide -9 -10 -8) (("3" (reveal -28 -30) (("3" (use "dio_matrix2ac_new_vars") (("3" (assert) (("3" (assert) (("3" (hide 2) (("3" (rewrite "member_append") (("3" (flatten) (("3" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (split -3) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "construct_sub_well_formed") (("4" (assert) (("4" (assert) (("4" (prop) (("1" (expand "args_delta_t" 1) (("1" (use "well_formed_count_elem2") (("1" (assert) (("1" (use "alm_well_formed_get_args") (("1" (assert) (("1" (prop) (("1" (use "alm_well_formed_subs") (("1" (assert) (("1" (reveal -28) (("1" (expand "alm_well_formed?" -1) (("1" (inst -1 "t") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -11) (("2" (expand "is_ac_sym?" -1) (("2" (flatten) (("2" (lemma "term_ac_app_eta") (("2" (inst -1 "t") (("2" (replace -3 :dir rl) (("2" (replace -1 1 :dir rl) (("2" (rewrite "subs_ac") (("2" (expand "is_ac_sym?" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -5 -15) (("2" (replace -2) (("2" (expand "C1") (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (assert) (("2" (expand "l" -8) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_equiv") (("2" (skolem 1 "unif_pair") (("2" (prop) (("2" (expand "unifies?" 1) (("2" (name-replace "ti" "unif_pair`1") (("2" (name-replace "ti_" "unif_pair`2") (("2" (hide -4 -7 -8) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(lambda1)(subs(delta)(ti)) = subs(delta)(ti)") (("1" (replace -1) (("1" (case "subs(lambda1)(subs(delta)(ti_)) = subs(lambda1)(ti_)") (("1" (replace -1) (("1" (use "perm_args_ac_well_formed") (("1" (assert) (("1" (case "well_formed?(subs(delta)(ti))") (("1" (assert) (("1" (case "well_formed?(subs(lambda1)(ti_))") (("1" (assert) (("1" (hide 2) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" 1) (("1" (skeep) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1 :dir rl) (("1" (rewrite "count" 1) (("1" (case "EXISTS t: member(t, args_delta_t) AND equal?(x, t)") (("1" (skolem -1 "Aj") (("1" (prop) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(delta)(ti)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "count_eq3") (("1" (inst -1 "f" "x" "Aj" "subs(lambda1)(ti_)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "member_nth2") (("1" (skolem -1 "j") (("1" (reveal -21) (("1" (inst -1 "j") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -2 :dir rl) (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (lemma "dio_matrix2ac_mem_lhs_nth") (("1" (inst -1 "args_" "D1" "f" "i" "vars2avoid") (("1" (assert) (("1" (replace -12) (("1" (case "i < length(args_)") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (reveal -11) (("1" (replace -1) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "i" "Aj") (("1" (prop) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -4) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -4) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "j" "m+n") (("1" (assert) (("1" (prop) (("1" (reveal -15 -16) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (hide -3) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, j)" "D1" "i" "m+n") (("1" (assert) (("1" (case "matrix?(D1, m + n) AND length(nth(C1, j)) = length(D1)") (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -3 -4 -5 -6 -7 -8 -9 -12 -13 -14 -15) (("1" (lemma "count_subs_subset") (("1" (name-replace "Z0" "select_greater[nat](vars2avoid)") (("1" (name-replace "l1" "length(D1)") (("1" (hide -1) (("1" (inst -2 "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))" "_" "_" "_" "_") (("1" (name-replace "new_var_lst" "var_lst(from_min2max[nat](Z0 + 1, Z0 + l1))") (("1" (inst -2 "f" "Aj" "lambda1" "ti_") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "count_coef1") (("1" (lemma "dio_matrix2ac_count_coef") (("1" (name-replace "V" "vars2avoid") (("1" (inst -1 "args_" "D1" "f" "i" "V") (("1" (assert) (("1" (case "length(args_) = m + n") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (replace -10) (("1" (reveal -5 -7) (("1" (replace -2) (("1" (replace -1) (("1" (expand "ti_" 1) (("1" (replace -9) (("1" (replace -4) (("1" (hide -4) (("1" (lemma "construct_sub_count_nth") (("1" (hide -8) (("1" (inst -1 "args_delta_t" "C1" "D1" "f" "j" "V") (("1" (assert) (("1" (replace -9) (("1" (replace -5) (("1" (expand "l1" -2) (("1" (replace -2) (("1" (prop) (("1" (replace -7 :dir rl) (("1" (replace -1) (("1" (rewrite "dot_product_sym") nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6) (("2" (reveal -42 -52) (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "C1" 1) (("2" (use "construct_submatrix_coef_len") (("2" (assert) (("2" (expand "l" -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "construct_submatrix_no_zero_col") (("3" (inst -1 "C" "D") (("3" (assert) (("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (assert) (("3" (expand "l" -9) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "args_delta_t" 1) (("4" (use "count_elem2_dif_elem[term]") nil nil)) nil)) nil) ("5" (hide 2 -1 -2 -3) (("5" (expand "args_delta_t" 1) (("5" (rewrite "no_pair_ac_count_elem2") (("5" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("6" (hide 2 -1 -2 -3) (("6" (expand "subset?" 1) (("6" (skolem 1 "x1") (("6" (prop) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "args_delta_t" -1) (("6" (rewrite "vars_count_elem2") (("6" (rewrite "vars_get_args") (("6" (use "vars_subs_t") (("6" (expand "subset?" -1) (("6" (inst -1 "x1") (("6" (prop) (("6" (expand ("member" "union") -1) (("6" (reveal -59 -60) (("6" (expand "V" 1) (("6" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x1") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil) ("2" (expand "subset?" -3) (("2" (inst -3 "x1") (("2" (prop) (("1" (rewrite "mem_list2set" :dir rl) nil nil) ("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2 -2) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) = length(coef_s)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "coef_t" 1) (("1" (expand "args_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset_lst?" 1) (("2" (skolem 1 "ti_j") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_rhs_get_args") (("2" (inst?) (("2" (inst -1 "ti_j" "ti_") (("2" (assert) (("2" (case "length(args_) = m + n") (("1" (assert) (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -5) (("1" (expand "new_var_lst" 1) (("1" (expand "l1" 1) (("1" (rewrite "var_lst_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "args_" 1) (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (expand "args_s" 1) (("2" (expand "args_t" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "new_var_lst" 1) (("3" (rewrite "var_lst_dif_elem" :dir rl) (("3" (rewrite "dif_elem_from_min2max") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -11 -12 -13 -14) (("2" (hide 2) (("2" (expand "args_" -1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -10 -11 -12 -13 2 -7 -6) (("2" (prop) (("1" (expand "D1" 1) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "m+n") (("1" (assert) (("1" (assert) (("1" (expand ("D" "m" "n")) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (prop) (("1" (expand "l" -11) (("1" (lemma "construct_submatrix_matrix") (("1" (inst -1 "C" "D") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "l" -13) (("2" (assert) (("2" (replace -3) (("2" (replace -1) (("2" (reveal -28) (("2" (replace -1) (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand ("D" "m" "n")) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "l" -15) (("3" (propax) nil nil)) nil) ("4" (hide -4 -5 -6 -7 -8 -9 2 -10) (("4" (reveal -24) (("4" (replace -1) (("4" (expand "k" 1) (("4" (typepred "j") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (expand "args_" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "i") (("2" (replace -12 -1 :dir rl) (("2" (lemma "dio_matrix2ac_len") (("2" (inst -1 "args_" "D1" "f" "vars2avoid") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "count(x, subs(delta)(ti), f) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "count" 2) (("1" (lemma "count0_eq[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(lambda1)(ti_))" "x") (("1" (assert) (("1" (skolem -1 "x1") (("1" (prop) (("1" (hide 2) (("1" (lemma "construct_sub_mem_get_args_dio_matrix2ac_sol") (("1" (inst -1 "args_" "args_delta_t" "C1" "D1" "f" "x1" "ti_" "vars2avoid") (("1" (assert) (("1" (replace -9) (("1" (replace -11) (("1" (case "length(args_) = m+n") (("1" (assert) (("1" (replace -1) (("1" (prop) (("1" (inst 1 "x1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "m > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "m" 1) (("2" (expand "coef_t" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (prop) (("1" (use "count_elem_len[term]") (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5 -6 -7 -8 -1 -2) (("3" (expand "D1" 1) (("3" (lemma "construct_submatrix_matrix2") (("3" (inst -1 "C" "D" "m+n") (("3" (assert) (("3" (assert) (("3" (expand "D" 1) (("3" (expand "m" 1) (("3" (expand "n") (("3" (use "dio_solver_matrix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -4 -5 -6 -7 2) (("4" (expand "subset?" 1) (("4" (skolem 1 "y") (("4" (prop) (("4" (expand "args_delta_t" -1) (("4" (rewrite "vars_count_elem2") (("4" (rewrite "vars_get_args") (("4" (use "vars_subs_t") (("4" (expand "subset?" -1) (("4" (inst -1 "y") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (reveal -36) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -37) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -13) (("5" (hide -4 -5 -6 -7 -8 -9 -10) (("5" (expand "k" -1) (("5" (expand "C1") (("5" (lemma "construct_submatrix_coef_len") (("5" (inst -1 "C" "D") (("5" (assert) (("5" (assert) (("5" (expand "l" -6) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "construct_submatrix_no_zero_col") (("6" (inst -1 "C" "D") (("6" (assert) (("6" (expand "C1" 1) (("6" (expand "D1" 1) (("6" (assert) (("6" (expand "l" -12) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "args_delta_t" 1) (("7" (use "no_pair_ac_count_elem2") (("7" (replace -1) (("7" (use "get_args_no_pair_ac") nil nil)) nil)) nil)) nil) ("8" (expand "rhs" 1) (("8" (rewrite "sec_proj_mem") (("8" (inst 1 "unif_pair") (("8" (assert) (("8" (expand "ti_") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7) (("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (hide-all-but 1) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "count" 1) (("2" (lemma "count0_eq[term]") (("2" (inst -1 "equal?" "get_args(f)(subs(delta)(ti))" "x") (("2" (assert) (("2" (skolem -1 "Aj") (("2" (prop) (("2" (lemma "dio_matrix2ac_mem_lhs") (("2" (inst?) (("2" (inst -1 "ti") (("2" (assert) (("2" (replace -11) (("2" (prop) (("1" (expand "args_") (("1" (rewrite "member_append" -1) (("1" (lemma "mem_get_args_subs4") (("1" (prop) (("1" (inst -2 "f" "Aj" "delta" "t" "ti") (("1" (assert) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) (("1" (lemma "count_elem2_mem2[term]") (("1" (inst -1 "equal?" "get_args(f)(subs(delta)(t))" "Aj") (("1" (assert) (("1" (skolem -1 "Aj1") (("1" (prop) (("1" (expand "args_delta_t" 2) (("1" (inst 2 "Aj1") (("1" (assert) (("1" (hide-all-but (-1 -7 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s" -1) (("2" (use "count_elem2_mem[term]") (("2" (assert) (("2" (hide -2) (("2" (inst -2 "f" "Aj" "delta" "s" "ti") (("2" (assert) (("2" (lemma "member_ac_count_elem2") (("2" (inst -1 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "Aj") (("2" (assert) (("2" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Aj1") (("1" (flatten) (("1" (inst 2 "Aj1") (("1" (expand "args_delta_t") (("1" (assert) (("1" (hide-all-but (-1 -6 2)) (("1" (lemma "equal?_trans") (("1" (inst -1 "x" "Aj" "Aj1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "Aj") (("2" (assert) (("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem" 1) (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (hide 2 3) (("2" (prop) (("1" (replace -5 1 :dir rl) (("1" (use "construct_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (expand "args_delta_t" 1) (("1" (use "well_formed_count_elem2") (("1" (assert) (("1" (hide 2) (("1" (use "alm_well_formed_get_args") (("1" (assert) (("1" (hide 2) (("1" (prop) (("1" (use "alm_well_formed_subs") (("1" (assert) (("1" (reveal -35) (("1" (expand "alm_well_formed?" -1) (("1" (inst -1 "t") (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -18) (("2" (hide-all-but (-1 1)) (("2" (expand "is_ac_sym?") (("2" (flatten) (("2" (use "term_ac_app_eta") (("2" (replace -3 :dir rl) (("2" (use "subs_ac") (("2" (replace -2 1 :dir rl) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -1 -5) (("2" (reveal -15 -16 -17) (("2" (replace -1 :dir rl) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (expand "k" -4) (("2" (assert) (("2" (expand "l" -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "C1" 1) (("3" (expand "D1" 1) (("3" (use "construct_submatrix_no_zero_col") (("3" (assert) (("3" (assert) (("3" (expand "l" -8) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_rhs_well_formed") (("2" (assert) (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (expand "args_" 1) (("1" (rewrite "length_append" 1) (("1" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_" 1) (("2" (rewrite "length_append" 1) (("2" (case "length(args_s) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "args_s" 1) (("2" (rewrite "count_elem2_cor") (("2" (use "count_elem_len_gt0[term]") (("2" (assert) (("2" (assert) (("2" (rewrite "get_args_len") (("2" (use "num_arg_ge1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "args_" 1) (("3" (rewrite "length_append" 1) (("3" (case "length(args_s) = n AND length(args_t) = m") (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (lemma "construct_submatrix_matrix2") (("1" (inst -1 "C" "D" "n+m") (("1" (expand "D1" 1) (("1" (assert) (("1" (assert) (("1" (expand "D" 1) (("1" (expand "m" 1) (("1" (expand "n" 1) (("1" (use "dio_solver_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "n" 1) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "m" 1) (("2" (expand "args_t" 1) (("2" (expand "coef_t" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -7) (("4" (expand "rhs" 1) (("4" (rewrite "sec_proj_mem") (("4" (inst 1 "unif_pair") (("4" (assert) (("4" (expand "ti_") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "args_" 1) (("5" (reveal -33) (("5" (rewrite "well_formed_args") (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "member_append" -2) (("5" (prop) (("1" (case "well_formed?(args_t)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (hide 2 3) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (reveal -35) (("2" (expand "alm_well_formed?" -1) (("2" (inst -1 "t") (("2" (assert) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "well_formed?(args_s)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "s") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (prop) (("1" (reveal -33) (("1" (expand "args_" -2) (("1" (rewrite "member_append" -2) (("1" (prop) (("1" (case "well_formed?(args_t)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "t") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "well_formed?(args_s)") (("1" (rewrite "well_formed_args") (("1" (inst -1 "ti") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (use "well_formed_count_elem2") (("2" (assert) (("2" (use "alm_well_formed_get_args") (("2" (assert) (("2" (expand "alm_well_formed?" -2) (("2" (inst -2 "s") (("2" (expand "member" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "delta" "ti_") (("2" (assert) (("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (prop) (("2" (reveal -25) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide -2) (("2" (lemma "dio_matrix2ac_mem_var_rhs") (("2" (inst?) (("2" (inst -1 "ti_") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "vars2avoid" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (expand "rhs" 1) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti_") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "lambda1" "subs(delta)(ti)") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (case "NOT member(x, vars2avoid)") (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (reveal -28) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set") nil nil)) nil)) nil)) nil)) nil) ("2" (use "dio_matrix2ac_mem_lhs") (("2" (assert) (("2" (replace -8) (("2" (prop) (("1" (reveal -31) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "args_" -1) (("1" (rewrite "member_append") (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "args_t" -1) (("1" (use "vars_get_args") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (use "vars_count_elem2") (("1" (replace -1 :dir rl) (("1" (rewrite "vars_args" 1) (("1" (inst 1 "ti") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_s") (("2" (hide 1) (("2" (use "vars_get_args") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (use "vars_count_elem2") (("2" (replace -1 :dir rl) (("2" (rewrite "vars_args" 1) (("2" (inst 1 "ti") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (replace -7) (("2" (expand "lhs" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "unif_pair") (("2" (assert) (("2" (expand "ti" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "construct_sub_mem_dom_cor") (("2" (assert) (("2" (expand "lambda1" -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "const1?" 1) (("2" (skolem 1 "j") (("2" (flatten) (("2" (name-replace "tj" "nth(args_, j-1)") (("1" (case "EXISTS t: member_ac(t, args_delta_t) AND count(t, subs(delta)(tj), f) > 0") (("1" (skolem -1 "Ai") (("1" (hide -14 -15 -16 -17 -18 -19) (("1" (prop) (("1" (expand "member_ac" -1) (("1" (skolem -1 "Ai_") (("1" (prop) (("1" (rewrite "member_nth2") (("1" (skolem -2 "i") (("1" (hide -8 -9 -10 -11) (("1" (reveal -12) (("1" (case "count(Ai_, subs(delta)(tj), f) > 0") (("1" (hide -5) (("1" (inst -2 "i") (("1" (case "i < k") (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (replace -5 :dir rl) (("1" (lemma "count_vec_nth") (("1" (inst -1 "delta_args" "f" "j-1" "Ai_") (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (prop) (("1" (hide -15 -16) (("1" (expand "delta_args" -1 2) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_nth_rw") (("1" (expand "args_" -9) (("1" (replace -9) (("1" (lemma "construct_submatrix_linear_comb") (("1" (inst -1 "C" "D" "i" "n+m") (("1" (assert) (("1" (case "matrix?(D, m+n)") (("1" (assert) (("1" (expand "l" -15) (("1" (assert) (("1" (replace -2) (("1" (reveal -8 -9) (("1" (replace -1) (("1" (replace -2) (("1" (hide -4) (("1" (replace -7) (("1" (lemma "get_linear_comb_nth") (("1" (inst -1 "nth(C1, i)" "D1" "j-1" "m+n") (("1" (case "matrix?(D1, m+n)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (replace -6) (("1" (hide -1 -12 -13 -14 -15 -16) (("1" (use "empty_col_get_repeat_lst") (("1" (assert) (("1" (replace -1) (("1" (replace -6 :dir rl) (("1" (use "dot_product_get_repeat_lst02") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "construct_submatrix_matrix") (("2" (inst -1 "C" "D") (("2" (assert) (("2" (replace -3) (("2" (replace -4) (("2" (use "matrix_nth[nat]") (("2" (assert) (("2" (hide 2) (("2" (lemma "construct_submatrix_coef_len") (("2" (inst -1 "C" "D") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "construct_submatrix_matrix2") (("2" (inst -1 "C" "D" "m+n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "D" 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (use "dio_solver_matrix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "delta_args" 1) (("2" (rewrite "subs_len") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "m" 1) (("2" (expand "n" 1) (("2" (prop) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil) ("2" (expand "args_s" 1) (("2" (expand "coef_s" 1 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "i") (("2" (expand "k" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "count") (("2" (lemma "count_eq[term]") (("2" (inst -1 "equal?" "_" "Ai" "Ai_") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "select(f, subs(delta)(tj))(1)") (("2" (prop) (("1" (hide -12 -13 -14 -15 -16 -17 -18) (("1" (expand "args_delta_t" 1) (("1" (lemma "member_ac_count_elem2") (("1" (name-replace "tj1" "select(f, subs(delta)(tj))(1)") (("1" (expand "args_" -2) (("1" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (rewrite "nth_append" -4) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(t))" "tj1") (("1" (use "perm?_ref") (("1" (assert) (("1" (inst 1 "tj1") (("1" (prop) (("1" (hide 2) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "t" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "j-1" "args_t") (("1" (assert) (("1" (replace -4) (("1" (expand "args_t" -1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (reveal -5) (("2" (inst -5 "get_args(f)(subs(delta)(t))" "get_args(f)(subs(delta)(s))" "tj1") (("2" (assert) (("2" (inst 2 "tj1") (("2" (prop) (("1" (hide 3 -1) (("1" (lemma "mem_get_args_subs4") (("1" (inst -1 "f" "tj1" "delta" "s" "tj") (("1" (assert) (("1" (prop) (("1" (lemma "member_nth[term]") (("1" (inst -1 "-1 -m + j" "args_s") (("1" (assert) (("1" (replace -2) (("1" (expand "args_s" -1 1) (("1" (use "count_elem2_mem[term]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tj1" 1) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "equal?_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "args_t" 1) (("2" (expand "args_s" 1) (("2" (expand "m" 1) (("2" (expand "n") (("2" (prop) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil) ("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_mem[term]") (("2" (expand "count" 1) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (hide -12 -13 -14 -15 -16 -17 -18) (("2" (use "get_args_mem_select1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "args_" 1) (("2" (rewrite "length_append") (("2" (case "length(args_t) = m AND length(args_s) = n") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (prop) (("1" (expand "m" 1) (("1" (expand "args_t" 1) (("1" (expand "coef_t" 1) (("1" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil) ("2" (expand "n" 1) (("2" (expand "args_s" 1) (("2" (expand "coef_s" 1) (("2" (use "count_elem2_same_len[term]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skolem 1 "sol") (("2" (prop) (("2" (expand "is_solution?" 1) (("2" (hide -4 -5) (("2" (hide -5 -6 -7) (("2" (rewrite "map_member4") (("2" (skolem -1 "Ai") (("2" (flatten) (("2" (expand "delta_args" -2) (("2" (rewrite "subs_append" -2) (("2" (rewrite "count_vec_append") (("2" (replace -2) (("2" (rewrite "length_append") (("2" (rewrite "count_vec_len") (("2" (rewrite "count_vec_len") (("2" (case "length(args_s) = length(coef_s) AND length(args_t) = length(coef_t)") (("1" (prop) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "subs_map" :dir rl) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "split_append[nat]") (("2" (rewrite "count_vec_len") (("2" (rewrite "subs_map" -1 :dir rl) (("2" (rewrite "map_length") (("2" (replace -3) (("2" (replace -1) (("2" (assert) (("2" (rewrite "subs_map") (("2" (hide -1 -5 -6) (("2" (name-replace "args_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`1") (("1" (name-replace "coef_delta_s" "count_elem2(get_args(f)(subs(delta)(s)), equal?)`2") (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "t") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_t") (("1" (expand "coef_t" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "count_subs_count_elem") (("1" (inst -1 "f" "Ai" "delta" "s") (("1" (assert) (("1" (rewrite "count_elem2_cor" :dir rl) (("1" (expand "args_s" 1) (("1" (expand "coef_s" 1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "perm?_equiv_same_count?") (("1" (expand "same_count?" -7) (("1" (inst -7 "Ai") (("1" (expand "count" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2) (("2" (prop) (("1" (expand "args_s") (("1" (expand "coef_s" 1) (("1" (rewrite "count_elem2_same_len") nil nil)) nil)) nil) ("2" (expand "args_t" 1) (("2" (expand "coef_t") (("2" (rewrite "count_elem2_same_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "coef_s") (("2" (rewrite "count_elem2_cor") (("2" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "coef_t" 1) (("3" (rewrite "count_elem2_cor") (("3" (rewrite "count_elem_tcc_solver") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "equal?_equiv" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ac_perm_args2 formula-decl nil equality nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (equivalence? const-decl "bool" relations nil) (equiv type-eq-decl nil list_theory nil) (count_elem2 def-decl "[list[T], list[nat]]" list_theory nil) (args type-eq-decl nil term_properties nil) (count_elem_tcc_solver formula-decl nil list_theory nil) (append def-decl "list[T]" list_props nil) (subs def-decl "args" substitution nil) (count_vec def-decl "list[nat]" equality nil) (dio_matrix type-eq-decl nil diophantine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (is_solution? const-decl "bool" diophantine nil) (count_eq formula-decl nil list_theory nil) (empty_col_get_repeat_lst formula-decl nil aux_unification nil) (dot_product_get_repeat_lst02 formula-decl nil diophantine nil) (nth_append formula-decl nil list_theory nil) (perm?_ref formula-decl nil equality nil) (get_args_mem_select1 formula-decl nil term_properties nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (count_mem formula-decl nil list_theory nil) (select def-decl "term" term_properties nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (unifies? def-decl "bool" unification nil) (construct_sub_well_formed formula-decl nil aux_unification nil) (construct_submatrix_no_zero_col formula-decl nil diophantine nil) (construct_submatrix_coef_len formula-decl nil diophantine nil) (alm_well_formed_subs formula-decl nil substitution nil) (alm_well_formed? const-decl "bool" unification nil) (alm_well_formed_get_args formula-decl nil term_properties nil) (well_formed_count_elem2 formula-decl nil equality nil) (construct_sub_vars_img formula-decl nil aux_unification nil) (vars_count_elem2 formula-decl nil equality nil) (vars_subs_t formula-decl nil substitution nil) (vars const-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (vars_get_args formula-decl nil term_properties nil) (subset? const-decl "bool" sets nil) (supset_dom_correct2 formula-decl nil substitution nil) (member const-decl "bool" sets nil) (dio_matrix2ac_new_vars formula-decl nil aux_unification nil) (select_greater_lt formula-decl nil list_theory nil) (from_min2max_mem2 formula-decl nil list_theory nil) (difference const-decl "set" sets nil) (mem_list2set formula-decl nil list_theory nil) (from_min2max def-decl "list[nat]" list_theory nil) (select_greater def-decl "nat" list_theory nil) (construct_sub_mem_dom formula-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (elim_com_arg_no_common_arg formula-decl nil aux_unification nil) (empty_col? const-decl "bool" aux_unification nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (matrix? const-decl "bool" list_theory nil) (matrix_row_len formula-decl nil list_theory nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nice_submatrix? const-decl "bool" aux_unification nil) (length_append formula-decl nil list_props nil) (count_elem2_same_len formula-decl nil more_list_theory_props nil) (equiv type-eq-decl nil more_list_theory_props nil) (count_elem2_cor formula-decl nil more_list_theory_props nil) (get_args_len formula-decl nil term_properties nil) (num_arg_ge1 formula-decl nil term_properties nil) (count_elem_len formula-decl nil list_theory nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (count_elem_len_gt0 formula-decl nil list_theory nil) (construct_submatrix_matrix2 formula-decl nil diophantine nil) (dio_solver_matrix formula-decl nil diophantine nil) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (dio_matrix2ac_is_var_sum formula-decl nil aux_unification nil) (sec_proj_mem formula-decl nil list_theory2 nil) (rhs const-decl "args" unification nil) (unifies?_equiv formula-decl nil unification nil) (dio_matrix2ac_mem_lhs_nth formula-decl nil aux_unification nil) (equal?_sym formula-decl nil equality nil) (term_ac_app_eta formula-decl nil term_adt nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (subs_ac formula-decl nil substitution nil) (subs_ac3 formula-decl nil substitution nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (dio_matrix2ac_len formula-decl nil aux_unification nil) (member_nth formula-decl nil list_theory nil) (dio_matrix2ac_mem_rhs formula-decl nil aux_unification nil) (get_col_i def-decl "list[T]" list_theory nil) (const2_sum formula-decl nil aux_unification nil) (member_nth2 formula-decl nil list_theory nil) (count_elem2_mem formula-decl nil more_list_theory_props nil) (get_args_mem_not_ac formula-decl nil term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member_append formula-decl nil list_theory nil) (is_ac_sym? const-decl "bool" term_properties nil) (if_non_var_const2_cor2 formula-decl nil aux_unification nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (construct_submatrix_get_sublists formula-decl nil diophantine nil) (extract_submatrices_mem formula-decl nil aux_unification nil) (map_member4 formula-decl nil map_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (subs_append2 formula-decl nil substitution nil) (perm_args_ac_well_formed formula-decl nil equality nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (subs_len formula-decl nil substitution nil) (construct_submatrix_linear_comb formula-decl nil diophantine nil) (matrix? def-decl "bool" list_theory nil) (count_subs_subset formula-decl nil substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (var_lst def-decl "list[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) (dio_matrix2ac_count_coef formula-decl nil aux_unification nil) (construct_sub_count_nth formula-decl nil aux_unification nil) (dot_product_sym formula-decl nil list_theory nil) (count_elem2_dif_elem formula-decl nil more_list_theory_props nil) (get_args_no_pair_ac formula-decl nil term_properties nil) (no_pair_ac_count_elem2 formula-decl nil equality nil) (int_minus_int_is_int application-judgement "int" integers nil) (count_coef1 formula-decl nil list_theory nil) (subset_lst? const-decl "bool" list_theory nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (var_lst_mem formula-decl nil term_properties nil) (dio_matrix2ac_mem_rhs_get_args formula-decl nil aux_unification nil) (dif_elem_from_min2max formula-decl nil more_list_theory_props nil) (var_lst_dif_elem formula-decl nil equality nil) (NOT const-decl "[bool -> bool]" booleans nil) (construct_submatrix_matrix formula-decl nil diophantine nil) (matrix_nth formula-decl nil list_theory nil) (get_linear_comb_nth formula-decl nil diophantine nil) (subs_map formula-decl nil substitution nil) (count_vec_nth formula-decl nil equality nil) (count_eq3 formula-decl nil equality nil) (count_elem2_mem2 formula-decl nil more_list_theory_props nil) (equal?_trans formula-decl nil equality nil) (member_ac const-decl "bool" equality nil) (equal?_ref formula-decl nil equality nil) (member_ac_count_elem2 formula-decl nil equality nil) (mem_get_args_subs4 formula-decl nil substitution nil) (first_proj_mem formula-decl nil list_theory2 nil) (lhs const-decl "args" unification nil) (dio_matrix2ac_mem_lhs formula-decl nil aux_unification nil) (construct_sub_mem_get_args_dio_matrix2ac_sol formula-decl nil aux_unification nil) (count0_eq formula-decl nil list_theory nil) (perm?_equiv_same_count? formula-decl nil equality nil) (well_formed_subs formula-decl nil substitution nil) (dio_matrix2ac_mem_rhs_well_formed formula-decl nil aux_unification nil) (well_formed_args formula-decl nil term_properties nil) (subs_no_effect_t formula-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (dio_matrix2ac_mem_var_rhs formula-decl nil aux_unification nil) (empty? const-decl "bool" sets nil) (vars_args formula-decl nil term_properties nil) (construct_sub_mem_dom_cor formula-decl nil aux_unification nil) (construct_sub def-decl "sub" aux_unification nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (const1? const-decl "bool" aux_unification nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (ac_sol type-eq-decl nil aux_unification nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (construct_submatrix def-decl "[dio_matrix, dio_matrix]" diophantine nil) (map_length formula-decl nil more_map_props nil) (length def-decl "nat" list_props nil) (count_vec_append formula-decl nil equality nil) (count_subs_count_elem formula-decl nil substitution nil) (equal?_equiv formula-decl nil equality nil) (split_append formula-decl nil list_theory nil) (count_vec_len formula-decl nil equality nil) (subs_append formula-decl nil substitution nil) (dio_solver def-decl "dio_matrix" diophantine nil) (dio_solver_coef_matrix formula-decl nil diophantine nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (calculate_upper_bound const-decl "nat" diophantine nil) (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (f_symbol type-eq-decl nil term_properties nil) (number nonempty-type-decl nil numbers nil) (ac_symbol type-eq-decl nil term_properties nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (unifies? const-decl "bool" unification nil)) nil) (solve_ac_complete_no_common-1 nil 3850308007 ("" (postpone) nil nil) nil shostak))("unification" unification all_ac_prb_sub 0 (all_ac_prb_sub-1 nil 3850316584 ("" (skolem 1 ("sig" "P")) (("" (prop) (("" (expand "all_ac_prb?" 1) (("" (skolem 1 "u_pair") (("" (prop) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification elim_com_arg_solve_ac_null 0 (elim_com_arg_solve_ac_null-1 nil 3808775035 ("" (skeep) (("" (assert) (("" (flatten) (("" (name-replace "mult_t2_" "elim_com_arg(t1, t2, f)`3") (("" (name-replace "args_" "elim_com_arg(t1, t2, f)`1") (("" (name-replace "mult_t1_" "elim_com_arg(t1, t2, f)`2") (("" (expand "args_" -2 1) (("" (expand "elim_com_arg" -2) (("" (name-replace "args1_" "count_elem(null, null,
                                      remove_common(get_args(f)(t1),
                                                    get_args(f)(t2), equal?),
                                      equal?)`1") (("1" (name-replace "args2_" "count_elem(null, null,
                                        remove_common(get_args(f)(t2),
                                                      get_args(f)(t1), equal?),
                                        equal?)`1") (("1" (case "length(mult_t1_) = length(args1_) AND length(mult_t2_) = length(args2_)") (("1" (flatten) (("1" (case "null?(mult_t1_) OR null?(mult_t2_)") (("1" (hide -5) (("1" (expand "solve_ac" 1) (("1" (replace -4 1) (("1" (reveal -4) (("1" (replace -1 1) (("1" (expand "calculate_upper_bound" 1) (("1" (expand "max_lcm" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split 1) (("1" (flatten) (("1" (hide -1) (("1" (expand "dio_solver" 1) (("1" (reveal -6) (("1" (replace -1 1) (("1" (hide -1) (("1" (name-replace "zero_row" "get_repeat_lst[nat]
                                                   (0,
                                                    length(mult_t1_) +
                                                     length(mult_t2_))") (("1" (expand "extract_submatrices" 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (hide 1) (("1" (expand "nonmatrix?" -1) (("1" (expand "matrix?" 1) (("1" (expand "matrix?" 1) (("1" (expand "matrix?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "get_all_sublists" 2) (("2" (expand "length" 2 1) (("2" (expand "length" 2) (("2" (expand "get_nice_submatrices" 2) (("2" (hide 1) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (hide 1) (("1" (expand "nice_submatrix?" -1) (("1" (flatten) (("1" (lemma "const1_implies_non_empty_row_n") (("1" (inst?) (("1" (inst -1 "0") (("1" (assert) (("1" (skolem -1 "row") (("1" (expand "member" -1) (("1" (flatten) (("1" (split -1) (("1" (replace -1) (("1" (expand "nth" -2) (("1" (reveal -3) (("1" (replace -1 -3 :dir rl) (("1" (expand "get_repeat_lst" -3) (("1" (assert) (("1" (lift-if) (("1" (split -3) (("1" (flatten) (("1" (expand "matrix?" -6) (("1" (assert) (("1" (replace -3 -6 :dir rl) (("1" (rewrite "get_repeat_lst_len") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "get_nice_submatrices" 2) (("2" (expand "map" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (replace -2 -1) (("1" (lemma "split_append[term]") (("1" (inst? -1) (("1" (replace -1 -2) (("1" (hide -1) (("1" (assert) (("1" (hide -3 -4 2 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "args_") (("2" (expand "elim_com_arg" -1) (("2" (reveal -1 -2) (("2" (replace -1 -3) (("2" (replace -2 -3) (("2" (hide -1 -2) (("2" (replace -2 -1) (("2" (lemma "split_append[term]") (("2" (inst? -1) (("2" (replace -1 -2) (("2" (hide -1) (("2" (assert) (("2" (hide -2 -4 1 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (prop) (("1" (expand "mult_t1_" 1) (("1" (expand "elim_com_arg" 1) (("1" (expand "args1_" 1) (("1" (lemma "count_elem_len[term]") (("1" (inst? -1) (("1" (assert) (("1" (assert) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_t1_") (("2" (expand "args1_" 1) (("2" (expand "elim_com_arg" 1) (("2" (lemma "count_elem_len[term]") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (expand "length" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "mult_t2_") (("3" (expand "args2_") (("3" (expand "elim_com_arg" 1) (("3" (hide -1) (("3" (lemma "count_elem_len[term]") (("3" (inst? -1) (("3" (assert) (("3" (assert) (("3" (expand "length" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "mult_t2_") (("4" (expand "args2_") (("4" (expand "elim_com_arg" 1) (("4" (lemma "count_elem_len[term]") (("4" (inst? -1) (("4" (assert) (("4" (assert) (("4" (expand "length" 1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "equal?_equiv") nil nil)) nil)) nil) ("2" (rewrite "equal?_equiv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (args type-eq-decl nil term_properties nil) (count_elem_len formula-decl nil list_theory nil) (split_append formula-decl nil list_theory nil) (max_lcm const-decl "nat" diophantine nil) (matrix? const-decl "bool" list_theory nil) (matrix? def-decl "bool" list_theory nil) (nonmatrix? const-decl "bool" list_theory nil) (get_all_sublists def-decl "list[list[T]]" list_theory nil) (dio_matrix type-eq-decl nil diophantine nil) (get_repeat_lst_len formula-decl nil list_theory nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (dio_solver def-decl "dio_matrix" diophantine nil) (calculate_upper_bound const-decl "nat" diophantine nil) (equal?_equiv formula-decl nil equality nil) (remove_common def-decl "list[T]" list_theory nil) (count_elem def-decl "[list[T], list[nat]]" list_theory nil) (equiv type-eq-decl nil list_theory nil)) SHOSTAK))("apply_ac_step" apply_ac_step apply_ac_complete 0 (apply_ac_complete-1 nil 3850320307 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("delta" "Ps" "sigma" "V")) (("" (flatten) (("" (hide -1) (("" (case "null?(Pu)") (("1" (inst 1 "(Ps, sigma, V)" "null") (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "well_formed?" 1) (("4" (skeep) (("4" (expand "subs" 1) (("4" (expand "subs" 1) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "img_null") (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (name-replace "u_pair" "car(Pu)") (("1" (name-replace "t" "u_pair`1") (("1" (name-replace "s" "u_pair`2") (("1" (case "equal?(t, s)") (("1" (reveal -1) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "Ps" "sigma") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "ac_sol" "gamma") (("1" (assert) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (expand "unifies?" -5) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "all_ac_prb?") (("3" (skeep) (("3" (inst -7 "unif_pair") (("3" (assert) (("3" (expand "member" 3) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 -2 -3 3)) (("4" (expand "nice_input?") (("4" (flatten) (("4" (prop) (("1" (hide-all-but (-6 1 2)) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -2 "x") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1 2)) (("2" (expand "subset?") (("2" (skeep) (("2" (inst -2 "x") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-9 1 2)) (("3" (rewrite "well_formed_unif_prb") (("3" (rewrite "well_formed_unif_prb") (("3" (skolem 1 "t1") (("3" (inst -1 "t1") (("3" (flatten) (("3" (expand "append" -2) (("3" (expand "member" -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sigma, V1)") (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9) (("1" (lemma "solve_ac_unify_complete") (("1" (inst -1 "delta" "f" "s" "t" "lst_V") (("1" (assert) (("1" (prop) (("1" (skolem -1 ("P_C" "lambda1" "V2")) (("1" (flatten) (("1" (hide -3 -4 -5 -9 -10 -11 -8) (("1" (hide -3) (("1" (name-replace "i_step_output" "instantiate_step(P_C, null, null)") (("1" (name-replace "P_CI" "i_step_output`1") (("1" (name-replace "lambda2" "i_step_output`2") (("1" (expand "more_general?" -7) (("1" (skolem -7 "delta1") (("1" (lemma "unifies?_equal") (("1" (inst -1 "delta" "append(delta1, sigma)" "append(Pu, Ps)") (("1" (assert) (("1" (hide -7) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "P_C") (("1" (case "equal?(append(lambda1, delta), append(append(lambda1, delta1), sigma))") (("1" (assert) (("1" (hide -1 -8) (("1" (lemma "unifies?_append_disjoint") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step_unifies_sub") (("1" (inst -1 "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (replace -6) (("1" (replace -4) (("1" (assert) (("1" (prop) (("1" (reveal -26) (("1" (inst -1 "apply_sub(lambda2, cdr(Pu))") (("1" (prop) (("1" (inst -1 "append(lambda1, delta)" "append(P_CI, apply_sub(lambda2, Ps))" "append(lambda2, sigma)" "V1") (("1" (prop) (("1" (skolem -1 ("ac_sol" "gamma")) (("1" (flatten) (("1" (inst 2 "ac_sol" "append(gamma, lambda1)") (("1" (prop) (("1" (reveal -18 -19 -20 -21 -22 -23 -24 -25 -26) (("1" (reveal -9) (("1" (expand "apply_ac_step" 1) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but (-1 -10 -11 2)) (("1" (reveal 3) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (replace -10) (("2" (replace -9) (("2" (replace -8) (("2" (replace -7) (("2" (replace -6) (("2" (replace -5) (("2" (split 1) (("1" (flatten) (("1" (hide -10 -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (lemma "instantiate_step_lst_mem") (("1" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil) ("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (reveal -26) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2 1) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ac_results" 1) (("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (hide -12 -13 -14 -15 -16 -17 -18 -19 -21) (("2" (use "input_apply_ac_step_mem2") (("2" (assert) (("2" (hide 2) (("2" (inst 1 "P_CI" "lambda2") (("2" (reveal -9 -10) (("2" (hide -13 -16 -9 -10) (("2" (lemma "instantiate_step_lst_mem") (("2" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -30) (("1" (expand "nice_input?" -1) (("1" (flatten) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2) (("3" (expand "member" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ac_results" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc") nil nil) ("3" (hide -1 -2 -6 -7 -8 -9 -10 -11 -13) (("3" (reveal -19) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (case "subset?(V1, ac_sol`3)") (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "difference" 1) (("1" (expand "member" -5) (("1" (expand "difference" -5) (("1" (flatten) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand ("member" "difference") -3) (("2" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 2) (("1" (rewrite "vars_lst_lst_vars") (("1" (inst 2 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 2 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1 2 3) (("2" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (hide -3) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -3) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (assert) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -4) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (flatten) (("1" (inst -4 "y") (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t2") (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (lemma "instantiate_step1_mem") (("2" (inst -1 "t1" "P_C") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (reveal -9) (("2" (expand "i_step_output" -1) (("2" (replace -1) (("2" (replace -3) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (expand "subset?" -8) (("1" (inst -8 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 2) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skolem 1 "z") (("3" (prop) (("3" (rewrite "mem_list2set" :dir rl) (("3" (expand "lst_V" 1) (("3" (rewrite "finset2list_mem") (("3" (expand "cur_V" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "vars" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "t" -1) (("3" (expand "s" -1) (("3" (expand "u_pair" -1) (("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -11) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -3) (("2" (inst -3 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "contained?" 1) (("2" (expand "lambda2" 1) (("2" (expand "i_step_output" 1) (("2" (case "subset?(vars(P_C), V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "member" 2 1) (("1" (expand "vars" 2 1) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (expand "subset?" -2) (("2" (flatten) (("2" (inst -3 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (hide -2 -4 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil) ("5" (expand "subset?" 1) (("5" (skeep) (("5" (hide -2 -7 -8 -9) (("5" (use "vars_img_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -17) (("2" (hide -3 -4 -5 -7) (("2" (case "subset?(V1, ac_sol`3)") (("1" (expand "V1" -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "vars_lst_lst_vars" 1) (("1" (inst 1 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1) (("2" (hide -8 2 3 -1 -2) (("2" (reveal -28) (("2" (case "subset?(vars(P_C), V1)") (("1" (case "subset?(V, V1)") (("1" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -8) (("2" (flatten) (("2" (expand "subset?" -11) (("2" (inst -11 "y") (("2" (rewrite "vars_unif_prb" -11) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (inst 3 "t2") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (assert) (("2" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (replace -12) (("2" (replace -10) (("2" (replace -2 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -6) (("1" (flatten) (("1" (expand "subset?" -7) (("1" (inst -7 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -3) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5 1 :dir rl) (("2" (expand "i_step_output" 1) (("2" (expand "contained?" 1) (("2" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" -4) (("1" (inst -4 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1") (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "unifies?_append") (("2" (case "disjoint?(dom(sigma), vars(img(lambda2)))") (("1" (prop) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "apply_sub(lambda2, cdr(Pu))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc" 1 :dir rl) (("2" (hide -9 2 -5 -6 -7) (("2" (lemma "unifies?_append_disjoint3") (("2" (inst -1 "sigma" "append(lambda1, delta1)" "apply_sub(lambda2, cdr(Pu))") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2 -2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "cdr(Pu)") (("1" (assert) (("1" (prop) (("1" (expand "append" -3 2) (("1" (expand "unifies?" -3) (("1" (flatten) (("1" (rewrite "unifies?_append" -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide-all-but (-2 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 1 "t1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_append") (("2" (prop) (("1" (rewrite "unifies?_equiv") (("1" (skolem 1 "up") (("1" (prop) (("1" (expand "P_CI" -1) (("1" (expand "i_step_output" -1) (("1" (lemma "instantiate_step1_mem_unif_pair") (("1" (inst -1 "null" "up" "P_C") (("1" (assert) (("1" (assert) (("1" (skolem -1 "up1") (("1" (rewrite "append_null") (("1" (prop) (("1" (replace -10) (("1" (replace -8) (("1" (replace -2) (("1" (hide -7) (("1" (case "unifies?(append(lambda1, delta), apply_sub(lambda2, cons(up1, null)))") (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-11 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (use "unifies?_append_disjoint3") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (expand "unifies?" 1) (("1" (expand "unifies?" 1 2) (("1" (rewrite "unifies?_equiv" -6) (("1" (inst -6 "up1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x" "P_C") (("2" (reveal -28) (("2" (prop) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide-all-but (-1 1 3)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil) ("4" (rewrite "vars_unif_prb") (("4" (inst 1 "t2") (("4" (assert) (("4" (rewrite "member_unif_prb_equiv") (("4" (inst 1 "up1") (("4" (assert) (("4" (expand "member" -4) (("4" (expand "member" -4) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -9) (("2" (lemma "unifies?_append_disjoint3") (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (inst -1 "sigma" "append(lambda1, delta1)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "Ps") (("1" (assert) (("1" (prop) (("1" (hide -1) (("1" (rewrite "unifies?_append" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -21) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (flatten) (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -3 "t3") (("2" (prop) (("2" (replace -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (expand "disjoint?" -3) (("2" (expand "empty?" -3) (("2" (inst -3 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t3") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -8) (("2" (reveal -19) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "lambda2" -3) (("2" (expand "i_step_output" -3) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (lemma "solve_ac_vars") (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (assert) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (1 -1)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (use "apply_sub_all_ac") (("3" (assert) (("3" (reveal -14) (("3" (expand "all_ac_prb?" -1) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "up") (("3" (flatten) (("3" (inst -1 "up") (("3" (assert) (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (reveal -15) (("5" (lemma "next_input_nice_input") (("5" (inst -1 "(Pu, Ps, sigma, V)" "_") (("5" (inst -1 "(apply_sub(lambda2, cdr(Pu)), append(P_CI, apply_sub(lambda2, Ps)), append(lambda2, sigma), V1)") (("5" (assert) (("5" (hide 2) (("5" (hide -1 -2 -3 -4 -8 -9) (("5" (reveal -16 -25 -26 -26 -28 -29 -30 -31 -32 -33) (("5" (expand "next_input?" 1) (("5" (replace -1) (("5" (replace -8) (("5" (replace -9) (("5" (replace -7) (("5" (replace -6) (("5" (replace -5) (("5" (replace -4) (("5" (replace -3) (("5" (reveal 3) (("5" (assert) (("5" (use "input_apply_ac_step_mem2") (("5" (assert) (("5" (hide 3) (("5" (inst 1 "P_CI" "lambda2") (("5" (expand "V1" 1) (("5" (expand "ac_results_subs" 1) (("5" (lemma "instantiate_step_lst_mem") (("5" (reveal -3) (("5" (inst?) (("5" (inst -2 "ac_results") (("5" (assert) (("5" (replace -14 :dir rl) (("5" (replace -12) (("5" (replace -13) (("5" (assert) (("5" (replace -5 1 :dir rl) (("5" (reveal -7) (("5" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -27) (("1" (hide -5 -6 -7 -8 -9 -10) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (rewrite "well_formed_unif_prb" -5) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2 1) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb" -5) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 2) (("3" (prop) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 3 -4 -5 -6) (("6" (reveal -22 -16 -17) (("6" (expand "contained?" 1) (("6" (case "subset?(V, V1)") (("1" (case "subset?(V2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand ("member" "difference") -5) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "vars_lst_lst_vars") (("2" (inst 1 "V2") (("2" (assert) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -6 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (case "equal?(append(append(lambda1, delta1), sigma), append(append(append(lambda1, delta1), lambda2), sigma))") (("1" (expand "more_general?" 1) (("1" (inst 1 "append(lambda1, delta1)") (("1" (lemma "equal_sub_trans") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "append(append(lambda1, delta1), append(lambda2, sigma))") (("1" (assert) (("1" (rewrite "append_assoc" -1) (("1" (lemma "append_assoc[basic_sub]") (("1" (inst -1 "append(lambda1, delta1)" "lambda2" "sigma") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "equal?" 1) (("2" (skeep) (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (name-replace "t2" "subs(sigma)(variable(X))") (("2" (lemma "equal_sub_equiv") (("2" (inst -1 "append(lambda1, delta1)" "append(append(lambda1, delta1), lambda2)" "t2") (("2" (assert) (("2" (rewrite "subs_append2" -1) (("2" (rewrite "subs_append2" -1) (("2" (rewrite "subs_append2" -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1 :dir rl) (("2" (use "instantiate_step_unifies_not_fail") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (reveal -17) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append") (("3" (flatten) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "solve_ac_vars") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (flatten) (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (reveal -13) (("2" (hide -7 -8 -5 -6) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (expand "u_pair" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skeep) (("2" (inst -1 "X") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_equal?") (("2" (inst -1 "_" "lambda1" "_") (("2" (inst?) (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -2) (("2" (expand "unifies?" -2) (("2" (prop) (("2" (reveal -9 -10) (("2" (assert) (("2" (replace -3) (("2" (replace -1 1 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -6) (("3" (expand "all_ac_prb?" -4) (("3" (expand "t") (("3" (inst -4 "u_pair") (("3" (expand "member" -4) (("3" (expand "ac_prb?" -4) (("3" (flatten) (("3" (expand "is_ac_sym?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (expand "all_ac_prb?" -4) (("4" (inst -4 "u_pair") (("4" (expand "member" -4) (("4" (expand "ac_prb?" -4) (("4" (flatten) (("4" (expand "s" 1) (("4" (expand "is_ac_sym?" 1) (("4" (assert) (("4" (expand "t" -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal 1) (("5" (propax) nil nil)) nil) ("6" (hide 3) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (expand "contained?" -7) (("6" (flatten) (("6" (expand "subset?" -7) (("6" (inst -7 "x") (("6" (assert) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "lst_V") (("6" (rewrite "finset2list_mem") (("6" (expand "cur_V") (("6" (expand ("member" "union") 1) (("6" (expand "member" 1 2) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (expand "subset?" 1) (("7" (skeep) (("7" (expand "contained?" -7) (("7" (flatten) (("7" (expand "subset?" -8) (("7" (inst -8 "x") (("7" (assert) (("7" (rewrite "mem_list2set" :dir rl) (("7" (expand "lst_V") (("7" (rewrite "finset2list_mem") (("7" (expand "cur_V" 1) (("7" (expand ("member" "union") 1) (("7" (expand "member" 1 2) (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 3) (("8" (expand "subset?" 1) (("8" (skeep) (("8" (rewrite "mem_list2set" :dir rl) (("8" (expand "lst_V" 1) (("8" (rewrite "finset2list_mem") (("8" (expand "cur_V" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand "vars" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand ("t" "s")) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 3) (("9" (expand "nice_input?" -5) (("9" (flatten) (("9" (rewrite "well_formed_unif_prb") (("9" (skolem 1 "t1") (("9" (prop) (("9" (rewrite "well_formed_unif_prb") (("9" (inst -10 "t1") (("9" (assert) (("9" (expand "append" 3) (("9" (expand "member" 3) (("9" (expand "member" -1) (("9" (split -1) (("1" (split) (("1" (assert) (("1" (expand "t" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "s" -1) (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" -7) (("2" (inst -7 "u_pair") (("2" (expand "member" -7) (("2" (assert) (("2" (expand "ac_prb?" -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (all_ac_prb? const-decl "bool" unification nil) (well_formed? const-decl "bool" substitution nil) (nice_input? const-decl "bool" apply_ac_step nil) (contained? const-decl "bool" substitution nil) nil (ac_sol_simp type-eq-decl nil apply_ac_step nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (subset? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (difference const-decl "set" sets nil) nil (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (subs const-decl "term" substitution nil) nil nil (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (img_null formula-decl nil substitution nil) (null adt-constructor-decl "(null?)" list_adt nil) nil (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil (well_formed_unif_prb formula-decl nil unification nil) (union const-decl "set" sets nil) nil (vars const-decl "finite_set[variable]" unification nil) (intersection const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) nil (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (solve_ac_unify_complete formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (ac_prb? const-decl "bool" unification nil) (unifies? const-decl "bool" unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (unifies?_append_disjoint formula-decl nil unification nil) (instantiate_step_unifies_not_fail formula-decl nil aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (instantiate_step_lst_mem formula-decl nil aux_unification nil) nil (solve_ac_well_formed formula-decl nil aux_unification nil) nil nil (first_proj_mem formula-decl nil list_theory2 nil) (append_assoc formula-decl nil list_props nil) (vars_unif_prb formula-decl nil unification nil) nil (instantiate_step1_mem formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) nil nil (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (member_unif_prb_append formula-decl nil unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) nil (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) nil (apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (sec_proj_mem formula-decl nil list_theory2 nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) (finset2list_mem formula-decl nil list_theory nil) nil nil nil (well_formed_append formula-decl nil substitution nil) (vars_img_append formula-decl nil substitution nil) (unifies?_append formula-decl nil unification nil) (subs_append2 formula-decl nil substitution nil) (subs_equal? formula-decl nil substitution nil) (equal?_sym formula-decl nil equality nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_append_disjoint4 formula-decl nil unification nil) (unifies?_append_disjoint3 formula-decl nil unification nil) (instantiate_step1_mem_unif_pair formula-decl nil aux_unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (solve_ac_vars formula-decl nil aux_unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_null formula-decl nil list_props nil) (unifies?_equiv formula-decl nil unification nil) (apply_sub_all_ac formula-decl nil unification nil) (next_input? const-decl "bool" apply_ac_step nil) nil (next_input_nice_input formula-decl nil apply_ac_step nil) (list2set def-decl "set[T]" list2set nil) (equal_sub_trans formula-decl nil substitution nil) (equal_sub_equiv formula-decl nil substitution nil) (apply_sub_len formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step_unifies_sub formula-decl nil aux_unification nil) nil (unifies?_equal formula-decl nil unification nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) nil (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil))("unification_alg" unification_alg nice_input?_apply_sub 0 (nice_input?_apply_sub-1 nil 3839750241 ("" (skeep) (("" (assert) (("" (prop) (("" (name-replace "sigma1" "cons((X, s), null)") (("" (reveal -1) (("" (lemma "basic_sub_info") (("" (inst?) (("" (assert) (("" (assert) (("" (replace -2) (("" (flatten) (("" (expand "nice_input?" -5) (("" (flatten) (("" (expand "nice_input?" 2) (("" (prop) (("1" (lemma "idempotent_append") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (rewrite "vars_singleton" 1) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (expand "disjoint?" -8) (("1" (expand "empty?" -8) (("1" (inst -8 "x") (("1" (expand ("member" "intersection") 2) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (lemma "apply_sub_elim_var") (("1" (inst?) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t1p") (("2" (prop) (("2" (replace -3) (("2" (lemma "vars_subs_t") (("2" (inst -1 "sigma1" "t1p") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (replace -7) (("1" (rewrite "vars_singleton" -1) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 1) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -11) (("2" (expand "empty?" -11) (("2" (inst -11 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t1p") (("2" (prop) (("2" (inst -15 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (lemma "dom_append") (("3" (inst?) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (hide -2) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (replace -2) (("1" (expand ("member" "singleton") -1) (("1" (replace -1) (("1" (replace -1 :dir rl) (("1" (expand "subset?" -9) (("1" (inst -9 "x") (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "variable(x)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "singleton") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "subset?" 1) (("4" (skeep) (("4" (expand "subset?" -9) (("4" (inst -9 "x") (("4" (assert) (("4" (rewrite "vars_unif_prb") (("4" (skolem -1 "t1") (("4" (prop) (("4" (rewrite "apply_sub_mem" -1) (("4" (skolem -1 "t1p") (("4" (prop) (("4" (replace -2) (("4" (lemma "vars_subs_t") (("4" (inst?) (("4" (expand "subset?" -1) (("4" (inst -1 "x") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (replace -6) (("1" (rewrite "vars_singleton" -1) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (assert) (("2" (inst -14 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (unif_prb type-eq-decl nil unification nil) (unif_pair type-eq-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil) (vars_singleton formula-decl nil term_properties nil) (idempotent_append formula-decl nil substitution nil) (dom_append formula-decl nil substitution nil) (apply_sub def-decl "unif_prb" unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (apply_sub_elim_var formula-decl nil unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (basic_sub_info formula-decl nil substitution nil) (constant type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil)) shostak))("unification_alg" unification_alg nice_input?_apply_ac_step 0 (nice_input?_apply_ac_step-1 nil 3839618418 ("" (skeep) (("" (expand "nice_input?") (("" (flatten) (("" (prop) (("1" (lemma "apply_ac_step_sigma_null") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "ac_sol") (("1" (prop) (("1" (lemma "apply_ac_step_sub_idempotent") (("1" (inst?) (("1" (assert) (("1" (replace -4) (("1" (lemma "idempotent_append") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (hide -3 -4 -5 -6) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (lemma "apply_ac_step_sub_vars_img") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t") (("1" (prop) (("1" (expand "disjoint?" -8) (("1" (expand "empty?" -8) (("1" (inst -8 "x") (("1" (expand ("member" "intersection") 1) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t") (("1" (assert) (("1" (lemma "simplify_mem") (("1" (inst -1 "t" "unif_prb") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_ac_step_sigma_null") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "ac_sol") (("2" (prop) (("2" (replace -2) (("2" (replace -3) (("2" (hide -2 -3 -4 -5) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (lemma "apply_ac_step_disjoint_vars") (("1" (inst?) (("1" (prop) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_null") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "dom_null") (("2" (expand "member" -2) (("2" (expand "emptyset" -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (rewrite "dom_null") (("3" (expand "emptyset" -1) (("3" (expand "member" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "apply_ac_step_vars") (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (rewrite "append_null" -1) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (inst 1 "t1") (("1" (prop) (("1" (use "simplify_mem") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -6) (("2" (inst -6 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "apply_ac_step_sigma_null") (("3" (inst?) (("3" (assert) (("3" (skolem -1 "ac_sol") (("3" (prop) (("3" (replace -3) (("3" (replace -4) (("3" (hide -2 -3 -4 -5) (("3" (lemma "apply_ac_step_vars2avoid") (("3" (inst?) (("3" (assert) (("3" (rewrite "append_null") (("3" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (lemma "dom_append") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -9) (("2" (inst -9 "x") (("2" (assert) (("2" (expand "subset?" -2) (("2" (inst -2 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -6) (("2" (inst -6 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (inst 2 "t1") (("2" (prop) (("2" (use "simplify_mem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "dom_null") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "apply_ac_step_sigma_null") (("4" (inst?) (("4" (assert) (("4" (skolem -1 "ac_sol") (("4" (prop) (("4" (replace -2) (("4" (replace -4) (("4" (hide -2 -3 -4 -5) (("4" (lemma "apply_ac_step_vars2avoid") (("4" (inst?) (("4" (assert) (("4" (prop) (("1" (rewrite "append_null") (("1" (expand "subset?" 1) (("1" (skeep) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t") (("1" (prop) (("1" (inst 3 "t") (("1" (assert) (("1" (lemma "simplify_mem") (("1" (inst -1 "t" "unif_prb") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "dom_null") (("2" (expand "member" -1) (("2" (expand "emptyset" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (dom_null formula-decl nil substitution nil) (apply_ac_step_disjoint_vars formula-decl nil apply_ac_step nil) (apply_ac_step_vars formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (apply_ac_step_sigma_null formula-decl nil apply_ac_step nil) (vars_unif_prb formula-decl nil unification nil) (simplify_mem formula-decl nil apply_ac_step nil) (apply_ac_step_sub_vars_img formula-decl nil apply_ac_step nil) (idempotent_append formula-decl nil substitution nil) (apply_ac_step_sub_idempotent formula-decl nil apply_ac_step nil) (simplify def-decl "unif_prb" apply_ac_step nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (unif_prb type-eq-decl nil unification nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil)) shostak))("unification_alg" unification_alg nice_input?_subterms 0 (nice_input?_subterms-1 nil 3839755188 ("" (skeep) (("" (expand "nice_input?") (("" (prop) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t") (("1" (prop) (("1" (lemma "vars_subterm2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "t1") (("1" (prop) (("1" (expand "subset?" -9) (("1" (inst -9 "t1") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (inst 1 "t1S") (("1" (assert) (("1" (lemma "vars_subterm") (("1" (inst -1 "x" "t1" "t1S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t") (("2" (prop) (("2" (lemma "vars_subterm2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "t1") (("2" (prop) (("2" (expand "subset?" -8) (("2" (inst -8 "t1") (("2" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "t1S") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((variable type-eq-decl nil term_properties nil) (vars_unif_prb formula-decl nil unification nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (constant type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (vars_subterm2 formula-decl nil term_properties nil) (subterms_mem_unif_prb formula-decl nil unification nil) (vars_subterm formula-decl nil term_properties nil)) shostak))("apply_ac_step" apply_ac_step simplify_mem 0 (simplify_mem-1 nil 3837336277 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "member" 1) (("2" (prop) (("2" (expand "simplify" -2) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil)) shostak))("apply_ac_step" apply_ac_step simplify_correct 0 (simplify_correct-1 nil 3839621813 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (prop) (("1" (expand "unifies?" 1) (("1" (prop) (("1" (expand "simplify" -1) (("1" (lift-if) (("1" (prop) (("1" (expand "unifies?" 1) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "unifies?" -1) (("2" (prop) (("2" (assert) (("2" (hide -2 -3 1) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "sigma") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "simplify" 1) (("2" (lift-if) (("2" (prop) (("1" (expand "unifies?" -2) (("1" (prop) (("1" (inst -4 "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "unifies?" (-1 2)) (("2" (prop) (("1" (assert) (("1" (expand "unifies?") (("1" (propax) nil nil)) nil)) nil) ("2" (inst -3 "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subs_equal? formula-decl nil substitution nil) (unifies? const-decl "bool" unification nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (unifies? def-decl "bool" unification nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil)) shostak))("apply_ac_step" apply_ac_step nice_input?_apply_sub 0 (nice_input?_apply_sub-1 nil 3850730950 ("" (skeep) (("" (assert) (("" (prop) (("" (name-replace "sigma1" "cons((X, s), null)") (("" (reveal -1) (("" (lemma "basic_sub_info") (("" (inst?) (("" (assert) (("" (assert) (("" (replace -2) (("" (flatten) (("" (expand "nice_input?" -5) (("" (flatten) (("" (hide -9 -10) (("" (expand "nice_input?" 2) (("" (prop) (("1" (lemma "idempotent_append") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (rewrite "vars_singleton" 1) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (expand "disjoint?" -8) (("1" (expand "empty?" -8) (("1" (inst -8 "x") (("1" (expand ("member" "intersection") 2) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (lemma "apply_sub_elim_var") (("1" (inst?) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t1p") (("2" (prop) (("2" (replace -3) (("2" (lemma "vars_subs_t") (("2" (inst -1 "sigma1" "t1p") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (replace -7) (("1" (rewrite "vars_singleton" -1) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 1) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -11) (("2" (expand "empty?" -11) (("2" (inst -11 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t1p") (("2" (prop) (("2" (inst -15 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (lemma "dom_append") (("3" (inst?) (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (hide -2) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (replace -2) (("1" (expand ("member" "singleton") -1) (("1" (replace -1) (("1" (replace -1 :dir rl) (("1" (expand "subset?" -9) (("1" (inst -9 "x") (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "variable(x)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "singleton") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "subset?" 1) (("4" (skeep) (("4" (expand "subset?" -9) (("4" (inst -9 "x") (("4" (assert) (("4" (rewrite "vars_unif_prb") (("4" (skolem -1 "t1") (("4" (prop) (("4" (rewrite "apply_sub_mem" -1) (("4" (skolem -1 "t1p") (("4" (prop) (("4" (replace -2) (("4" (lemma "vars_subs_t") (("4" (inst?) (("4" (expand "subset?" -1) (("4" (inst -1 "x") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (replace -6) (("1" (rewrite "vars_singleton" -1) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (assert) (("2" (inst -14 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -1) (("5" (rewrite "well_formed_unif_prb" 1) (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "apply_sub_mem" -2) (("5" (skolem -2 "t2") (("5" (flatten) (("5" (replace -3 1) (("5" (use "well_formed_subs") (("5" (assert) (("5" (prop) (("1" (expand "sigma1" 1) (("1" (use "basic_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (rewrite "well_formed_unif_prb" -1) (("1" (inst -1 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -14 "t2") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (reveal -1 -2) (("6" (use "well_formed_append") (("6" (assert) (("6" (replace -6 1 :dir rl) (("6" (lemma "basic_sub_well_formed") (("6" (inst?) (("6" (assert) (("6" (rewrite "well_formed_unif_prb" -1) (("6" (inst -1 "s") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (basic_sub_info formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nice_input? const-decl "bool" apply_ac_step nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (unif_prb type-eq-decl nil unification nil) (unif_pair type-eq-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (vars_singleton formula-decl nil term_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (idempotent_append formula-decl nil substitution nil) (dom_append formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil) (apply_sub def-decl "unif_prb" unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (apply_sub_elim_var formula-decl nil unification nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (singleton const-decl "(singleton?)" sets nil) nil (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (well_formed_unif_prb formula-decl nil unification nil) nil (basic_sub_well_formed formula-decl nil substitution nil) (well_formed_subs formula-decl nil substitution nil) (well_formed_append formula-decl nil substitution nil)) shostak))("apply_ac_step" apply_ac_step nice_input?_subterms 0 (nice_input?_subterms-1 nil 3850731576 ("" (skeep) (("" (expand "nice_input?") (("" (prop) (("1" (hide -5 -6) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t") (("1" (prop) (("1" (lemma "vars_subterm2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "t1") (("1" (prop) (("1" (expand "subset?" -9) (("1" (inst -9 "t1") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (inst 1 "t1S") (("1" (assert) (("1" (lemma "vars_subterm") (("1" (inst -1 "x" "t1" "t1S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -6) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t") (("2" (prop) (("2" (lemma "vars_subterm2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "t1") (("2" (prop) (("2" (expand "subset?" -8) (("2" (inst -8 "t1") (("2" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "t1S") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -6) (("3" (expand "well_formed?" 1) (("3" (skeep) (("3" (split 1) (("1" (expand "subset?" -6) (("1" (inst -6 "t") (("1" (flatten) (("1" (assert) (("1" (expand "well_formed?" -7) (("1" (inst -7 "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "no_pair?" -) (("2" (inst -9 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nice_input? const-decl "bool" apply_ac_step nil) (no_pair? const-decl "bool" unification nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil (empty? const-decl "bool" sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (vars_unif_prb formula-decl nil unification nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (vars_subterm2 formula-decl nil term_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subterms_mem_unif_prb formula-decl nil unification nil) (vars_subterm formula-decl nil term_properties nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil)) shostak))("apply_ac_step" apply_ac_step next_input?_nice_input 0 (next_input?_nice_input-1 nil 3850731813 ("" (skeep) (("" (name-replace "Pu" "input1`1") (("" (name-replace "Ps" "input1`2") (("" (name-replace "sig" "input1`3") (("" (name-replace "V" "input1`4") (("" (reveal -1 -2 -3 -4) (("" (expand "next_input?" -5) (("" (replace -1) (("" (replace -2) (("" (replace -3) (("" (replace -4) (("" (split -5) (("1" (flatten) (("1" (name-replace "t" "car(Pu)`1") (("1" (name-replace "s" "car(Pu)`2") (("1" (hide -4 -5 -6 -7) (("1" (replace -3 2) (("1" (assert) (("1" (hide -3) (("1" (lemma "nice_input_subterms") (("1" (inst -1 "sig" "append(Pu, Ps)" "append(cdr(Pu), Ps)" "V") (("1" (assert) (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (flatten) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "t1S") (("1" (assert) (("1" (expand "append" 1) (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_pair?" 1) (("2" (expand "nice_input?" -3) (("2" (flatten) (("2" (hide -8) (("2" (skolem 1 "t1") (("2" (flatten) (("2" (expand "well_formed?" -9) (("2" (inst -9 "t1") (("2" (flatten) (("2" (hide -9) (("2" (prop) (("2" (expand "append" 1) (("2" (expand "member" 1 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(Pu)`1") (("2" (name-replace "s" "car(Pu)`2") (("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("2" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sig, V1)") (("2" (expand "input_lst" -2) (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (skolem -1 ("P_CI" "del")) (("2" (flatten) (("2" (hide -7) (("2" (hide -7 -8 -9 -10) (("2" (replace -2) (("2" (replace -3) (("2" (replace -4) (("2" (replace -5) (("2" (hide -2 -3 -4 -5) (("2" (expand "ac_results_subs" -1) (("2" (use "instantiate_step_mem2") (("2" (assert) (("2" (skolem -1 "P_C") (("2" (flatten) (("2" (expand "ac_results" -1) (("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (hide -11) (("2" (case "subset?(V, V1)") (("1" (hide 1) (("1" (expand "nice_input?" 2) (("1" (case "idempotent?(del)") (("1" (hide -6 -7) (("1" (prop) (("1" (use "idempotent_append") (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (replace -7 -2) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "P_C") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (prop) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 3) (("1" (expand "append" 3) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (prop) (("1" (hide-all-but (3 -1)) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (prop) (("2" (expand "subset?" -11) (("2" (inst -11 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (flatten) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2 -4) (("1" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -8 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (replace -2 -5) (("2" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2) (("3" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT member(x, vars(img(del)))") (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2 -4) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst?) (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand ("member" "intersection") 3) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -8 :dir rl) (("2" (replace -9 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2 -5) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (lemma "solve_ac_vars") (("2" (hide -11 -12) (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand ("member" "intersection") 3) (("1" (expand "append" 3) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (flatten) (("1" (hide-all-but (-1 3)) (("1" (expand ("t" "s")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V") (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (expand "subset?" -12) (("2" (inst -12 "x") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "vars_unif_prb" 1) (("3" (inst 1 "t2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2 -4) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (expand "disjoint?" -12) (("3" (expand "empty?" -12) (("3" (inst -12 "x") (("3" (expand ("member" "intersection") 3) (("3" (rewrite "vars_unif_prb" 3) (("3" (inst 3 "t2") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (replace -7 -1) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "P_C") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (use "solve_ac_vars") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 2) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand ("t" "s")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V") (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (prop) (("2" (expand "subset?" -11) (("2" (inst -11 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skeep) (("3" (use "dom_append") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (hide -2) (("1" (replace -6 -1) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_first_proj_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(x)") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 1) (("2" (expand "vars" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "subset?" -9) (("2" (inst -9 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "subset?(vars(img(del)), V1)") (("1" (hide -11) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append" -2) (("1" (rewrite "member_unif_prb_append" -2) (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -4) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -4) (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -13) (("2" (inst -13 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb" 4) (("2" (inst 4 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 4 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (replace -8 :dir rl) (("2" (replace -9 :dir rl) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2 -5) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (hide-all-but (-1 1 4)) (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -4) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "subset?" -4) (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -14) (("2" (inst -14 "x") (("2" (assert) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (inst 4 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (replace -6 -1) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "P_C") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (expand "V1" 1) (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand "t" -1) (("2" (expand "s" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (case "well_formed?(del)") (("1" (rewrite "well_formed_unif_prb") (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 1) (("1" (use "well_formed_subs") (("1" (assert) (("1" (rewrite "well_formed_unif_prb") (("1" (inst -13 "t2") (("1" (assert) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 4 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -7 :dir rl) (("2" (replace -8 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -15) (("2" (prop) (("1" (rewrite "well_formed_unif_prb") (("1" (inst -1 "t2") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -14 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (hide-all-but (4 5)) (("2" (expand "t" 2) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -14 "s") (("3" (assert) (("3" (hide-all-but (4 5)) (("3" (rewrite "member_unif_prb_append") (("3" (prop) (("3" (expand "s" 2) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2 1) (("3" (use "well_formed_subs") (("3" (assert) (("3" (rewrite "well_formed_unif_prb") (("3" (inst -13 "t2") (("3" (assert) (("3" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5) (("2" (lemma "instantiate_step_well_formed") (("2" (inst -1 "P_C") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -10) (("2" (hide-all-but (-10 1 4)) (("2" (prop) (("1" (inst -1 "t") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "t" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "s") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "s" 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (reveal -3) (("6" (use "well_formed_append") (("6" (assert) (("6" (lemma "instantiate_step_well_formed") (("6" (inst -1 "P_C") (("6" (assert) (("6" (lemma "solve_ac_well_formed") (("6" (inst?) (("6" (assert) (("6" (hide 2 3 4) (("6" (rewrite "well_formed_unif_prb" -11) (("6" (prop) (("1" (inst -11 "t") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "t" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -11 "s") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "s" 3) (("2" (expand "member" 3 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (replace -4) (("2" (use "instantiate_step_idempotent3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 4 -10) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -3) (("2" (lift-if) (("2" (assert) (("2" (expand "member" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nice_input_subterms formula-decl nil apply_ac_step nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (no_pair? const-decl "bool" unification nil) nil (nice_input? const-decl "bool" apply_ac_step nil) (subset? const-decl "bool" sets nil) nil (subterms_mem_unif_prb formula-decl nil unification nil) (append def-decl "list[T]" list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) nil (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) nil nil (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (member def-decl "bool" list_props nil) (idempotent? const-decl "bool" substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) nil nil (finset2list_mem formula-decl nil list_theory nil) nil nil (solve_ac_vars formula-decl nil aux_unification nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (idempotent_append formula-decl nil substitution nil) (dom_append formula-decl nil substitution nil) (member_unif_prb_append formula-decl nil unification nil) (apply_sub_elim_var_t2 formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (vars_unif_prb formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (vars_subs_t formula-decl nil substitution nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) nil (NOT const-decl "[bool -> bool]" booleans nil) nil (mem_list2set formula-decl nil list_theory nil) nil (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (instantiate_step_well_formed formula-decl nil aux_unification nil) (well_formed_unif_prb formula-decl nil unification nil) (solve_ac_well_formed formula-decl nil aux_unification nil) (well_formed_subs formula-decl nil substitution nil) (well_formed? const-decl "bool" substitution nil) (well_formed_append formula-decl nil substitution nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) nil (instantiate_step_mem2 formula-decl nil aux_unification nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (union const-decl "set" sets nil) nil (next_input? const-decl "bool" apply_ac_step nil) (finite_union application-judgement "finite_set" finite_sets nil)) shostak))("apply_ac_step" apply_ac_step nice_input?_apply_ac_step 0 (nice_input?_apply_ac_step-1 nil 3850732660 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("output" "Ps" "sig" "V")) (("" (prop) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (expand "member" -2) (("1" (replace -2) (("1" (assert) (("1" (expand "append" -4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(Pu)`1") (("1" (name-replace "s" "car(Pu)`2") (("1" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("1" (name-replace "lst_V" "finset2list[variable](cur_V)") (("1" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sig, V1)") (("1" (split -1) (("1" (flatten) (("1" (reveal -10) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (lemma "nice_input_subterms") (("1" (inst?) (("1" (inst -1 "append(Pu, Ps)") (("1" (assert) (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "subterms_append") (("1" (rewrite "subterms_append") (("1" (flatten) (("1" (assert) (("1" (expand "subterms" 1) (("1" (expand ("member" "union") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_pair?" 1) (("2" (expand "nice_input?" -4) (("2" (flatten) (("2" (hide -9) (("2" (expand "well_formed?" -8) (("2" (skolem 1 "t1") (("2" (inst -8 "t1") (("2" (flatten) (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -1 "input") (("2" (flatten) (("2" (expand "input_lst" -1) (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (skolem -1 ("P_CI" "sig1")) (("2" (flatten) (("2" (reveal -11) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst?) (("1" (inst -1 "input`2" "input`3" "input`4") (("1" (assert) (("1" (lemma "next_input_nice_input") (("1" (inst -1 "(Pu, Ps, sig, V)" "input") (("1" (assert) (("1" (hide 2 5) (("1" (reveal 3) (("1" (reveal -6 -7 -8 -9 -10 -11 -12 -13) (("1" (expand "next_input?" 2) (("1" (replace -8) (("1" (replace -7) (("1" (replace -6) (("1" (replace -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "car(Pu)") (("1" (expand "member" -1) (("1" (assert) (("1" (expand "ac_prb?" -1) (("1" (flatten) (("1" (expand "t" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finset2list def-decl "list[T]" list_theory nil) nil nil nil (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (nice_input_subterms formula-decl nil apply_ac_step nil) (subterms_append formula-decl nil unification nil) nil (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) nil nil (no_pair? const-decl "bool" unification nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (well_formed? const-decl "bool" substitution nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (vars const-decl "finite_set[variable]" unification nil) (idempotent? const-decl "bool" substitution nil) (subs const-decl "term" substitution nil) (all_ac_prb? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) nil (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) (next_input? const-decl "bool" apply_ac_step nil) (next_input_nice_input formula-decl nil apply_ac_step nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (union const-decl "set" sets nil) nil (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (nice_input? const-decl "bool" apply_ac_step nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("apply_ac_step" apply_ac_step apply_ac_complete 0 (apply_ac_complete-1 nil 3850733166 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("delta" "Ps" "sigma" "V")) (("" (flatten) (("" (hide -1) (("" (case "null?(Pu)") (("1" (inst 1 "(Ps, sigma, V)" "null") (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "well_formed?" 1) (("4" (skeep) (("4" (expand "subs" 1) (("4" (expand "subs" 1) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "img_null") (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (name-replace "u_pair" "car(Pu)") (("1" (name-replace "t" "u_pair`1") (("1" (name-replace "s" "u_pair`2") (("1" (case "equal?(t, s)") (("1" (reveal -1) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "Ps" "sigma") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "ac_sol" "gamma") (("1" (assert) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (expand "unifies?" -5) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "all_ac_prb?") (("3" (skeep) (("3" (inst -7 "unif_pair") (("3" (assert) (("3" (expand "member" 3) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (lemma "next_input_nice_input") (("4" (inst -1 "(Pu, Ps, sigma, V)" "(cdr(Pu), Ps, sigma, V)") (("4" (assert) (("4" (hide 2) (("4" (expand "next_input?" 1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sigma, V1)") (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9) (("1" (lemma "solve_ac_unify_complete") (("1" (inst -1 "delta" "f" "s" "t" "lst_V") (("1" (assert) (("1" (prop) (("1" (skolem -1 ("P_C" "lambda1" "V2")) (("1" (flatten) (("1" (hide -3 -4 -5 -9 -10 -11 -8) (("1" (hide -3) (("1" (name-replace "i_step_output" "instantiate_step(P_C, null, null)") (("1" (name-replace "P_CI" "i_step_output`1") (("1" (name-replace "lambda2" "i_step_output`2") (("1" (expand "more_general?" -7) (("1" (skolem -7 "delta1") (("1" (lemma "unifies?_equal") (("1" (inst -1 "delta" "append(delta1, sigma)" "append(Pu, Ps)") (("1" (assert) (("1" (hide -7) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "P_C") (("1" (case "equal?(append(lambda1, delta), append(append(lambda1, delta1), sigma))") (("1" (assert) (("1" (hide -1 -8) (("1" (lemma "unifies?_append_disjoint") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step_unifies_sub") (("1" (inst -1 "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (replace -6) (("1" (replace -4) (("1" (assert) (("1" (prop) (("1" (reveal -26) (("1" (inst -1 "apply_sub(lambda2, cdr(Pu))") (("1" (prop) (("1" (inst -1 "append(lambda1, delta)" "append(P_CI, apply_sub(lambda2, Ps))" "append(lambda2, sigma)" "V1") (("1" (prop) (("1" (skolem -1 ("ac_sol" "gamma")) (("1" (flatten) (("1" (inst 2 "ac_sol" "append(gamma, lambda1)") (("1" (prop) (("1" (reveal -18 -19 -20 -21 -22 -23 -24 -25 -26) (("1" (reveal -9) (("1" (expand "apply_ac_step" 1) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but (-1 -10 -11 2)) (("1" (reveal 3) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (replace -10) (("2" (replace -9) (("2" (replace -8) (("2" (replace -7) (("2" (replace -6) (("2" (replace -5) (("2" (split 1) (("1" (flatten) (("1" (hide -10 -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (lemma "instantiate_step_lst_mem") (("1" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil) ("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (reveal -26) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2 1) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ac_results" 1) (("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (hide -12 -13 -14 -15 -16 -17 -18 -19 -21) (("2" (use "input_apply_ac_step_mem2") (("2" (assert) (("2" (hide 2) (("2" (inst 1 "P_CI" "lambda2") (("2" (reveal -9 -10) (("2" (hide -13 -16 -9 -10) (("2" (lemma "instantiate_step_lst_mem") (("2" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -30) (("1" (expand "nice_input?" -1) (("1" (flatten) (("1" (hide -6) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2) (("3" (expand "member" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ac_results" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc") nil nil) ("3" (hide -1 -2 -6 -7 -8 -9 -10 -11 -13) (("3" (reveal -19) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (case "subset?(V1, ac_sol`3)") (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "difference" 1) (("1" (expand "member" -5) (("1" (expand "difference" -5) (("1" (flatten) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand ("member" "difference") -3) (("2" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 2) (("1" (rewrite "vars_lst_lst_vars") (("1" (inst 2 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 2 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1 2 3) (("2" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (hide -3) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -3) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (assert) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -4) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (flatten) (("1" (inst -4 "y") (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t2") (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (lemma "instantiate_step1_mem") (("2" (inst -1 "t1" "P_C") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (reveal -9) (("2" (expand "i_step_output" -1) (("2" (replace -1) (("2" (replace -3) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (expand "subset?" -8) (("1" (inst -8 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 2) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skolem 1 "z") (("3" (prop) (("3" (rewrite "mem_list2set" :dir rl) (("3" (expand "lst_V" 1) (("3" (rewrite "finset2list_mem") (("3" (expand "cur_V" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "vars" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "t" -1) (("3" (expand "s" -1) (("3" (expand "u_pair" -1) (("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -11) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -3) (("2" (inst -3 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "contained?" 1) (("2" (expand "lambda2" 1) (("2" (expand "i_step_output" 1) (("2" (case "subset?(vars(P_C), V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "member" 2 1) (("1" (expand "vars" 2 1) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (expand "subset?" -2) (("2" (flatten) (("2" (inst -3 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (hide -2 -4 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil) ("5" (expand "subset?" 1) (("5" (skeep) (("5" (hide -2 -7 -8 -9) (("5" (use "vars_img_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -17) (("2" (hide -3 -4 -5 -7) (("2" (case "subset?(V1, ac_sol`3)") (("1" (expand "V1" -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "vars_lst_lst_vars" 1) (("1" (inst 1 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1) (("2" (hide -8 2 3 -1 -2) (("2" (reveal -28) (("2" (case "subset?(vars(P_C), V1)") (("1" (case "subset?(V, V1)") (("1" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -8) (("2" (flatten) (("2" (hide -13) (("2" (expand "subset?" -11) (("2" (inst -11 "y") (("2" (rewrite "vars_unif_prb" -11) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (inst 3 "t2") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (assert) (("2" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (replace -12) (("2" (replace -10) (("2" (replace -2 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -6) (("1" (flatten) (("1" (expand "subset?" -7) (("1" (inst -7 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -3) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (hide -11) (("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5 1 :dir rl) (("2" (expand "i_step_output" 1) (("2" (expand "contained?" 1) (("2" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" -4) (("1" (inst -4 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1") (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "unifies?_append") (("2" (case "disjoint?(dom(sigma), vars(img(lambda2)))") (("1" (prop) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "apply_sub(lambda2, cdr(Pu))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc" 1 :dir rl) (("2" (hide -9 2 -5 -6 -7) (("2" (lemma "unifies?_append_disjoint3") (("2" (inst -1 "sigma" "append(lambda1, delta1)" "apply_sub(lambda2, cdr(Pu))") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2 -2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "cdr(Pu)") (("1" (assert) (("1" (prop) (("1" (expand "append" -3 2) (("1" (expand "unifies?" -3) (("1" (flatten) (("1" (rewrite "unifies?_append" -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 1 "t1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_append") (("2" (prop) (("1" (rewrite "unifies?_equiv") (("1" (skolem 1 "up") (("1" (prop) (("1" (expand "P_CI" -1) (("1" (expand "i_step_output" -1) (("1" (lemma "instantiate_step1_mem_unif_pair") (("1" (inst -1 "null" "up" "P_C") (("1" (assert) (("1" (assert) (("1" (skolem -1 "up1") (("1" (rewrite "append_null") (("1" (prop) (("1" (replace -10) (("1" (replace -8) (("1" (replace -2) (("1" (hide -7) (("1" (case "unifies?(append(lambda1, delta), apply_sub(lambda2, cons(up1, null)))") (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-11 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (use "unifies?_append_disjoint3") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (expand "unifies?" 1) (("1" (expand "unifies?" 1 2) (("1" (rewrite "unifies?_equiv" -6) (("1" (inst -6 "up1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x" "P_C") (("2" (reveal -28) (("2" (prop) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (hide -7) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide-all-but (-1 1 3)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil) ("4" (rewrite "vars_unif_prb") (("4" (inst 1 "t2") (("4" (assert) (("4" (rewrite "member_unif_prb_equiv") (("4" (inst 1 "up1") (("4" (assert) (("4" (expand "member" -4) (("4" (expand "member" -4) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -9) (("2" (lemma "unifies?_append_disjoint3") (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (inst -1 "sigma" "append(lambda1, delta1)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "Ps") (("1" (assert) (("1" (prop) (("1" (hide -1) (("1" (rewrite "unifies?_append" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -21) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (flatten) (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -3 "t3") (("2" (prop) (("2" (replace -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "disjoint?" -3) (("2" (expand "empty?" -3) (("2" (inst -3 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t3") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -8) (("2" (reveal -19) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "lambda2" -3) (("2" (expand "i_step_output" -3) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (lemma "solve_ac_vars") (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (assert) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (hide -8) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (1 -1)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (use "apply_sub_all_ac") (("3" (assert) (("3" (reveal -14) (("3" (expand "all_ac_prb?" -1) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "up") (("3" (flatten) (("3" (inst -1 "up") (("3" (assert) (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (reveal -15) (("5" (lemma "next_input_nice_input") (("5" (inst -1 "(Pu, Ps, sigma, V)" "_") (("5" (inst -1 "(apply_sub(lambda2, cdr(Pu)), append(P_CI, apply_sub(lambda2, Ps)), append(lambda2, sigma), V1)") (("5" (assert) (("5" (hide 2) (("5" (hide -1 -2 -3 -4 -8 -9) (("5" (reveal -16 -25 -26 -26 -28 -29 -30 -31 -32 -33) (("5" (expand "next_input?" 1) (("5" (replace -1) (("5" (replace -8) (("5" (replace -9) (("5" (replace -7) (("5" (replace -6) (("5" (replace -5) (("5" (replace -4) (("5" (replace -3) (("5" (reveal 3) (("5" (assert) (("5" (use "input_apply_ac_step_mem2") (("5" (assert) (("5" (hide 3) (("5" (inst 1 "P_CI" "lambda2") (("5" (expand "V1" 1) (("5" (expand "ac_results_subs" 1) (("5" (lemma "instantiate_step_lst_mem") (("5" (reveal -3) (("5" (inst?) (("5" (inst -2 "ac_results") (("5" (assert) (("5" (replace -14 :dir rl) (("5" (replace -12) (("5" (replace -13) (("5" (assert) (("5" (replace -5 1 :dir rl) (("5" (reveal -7) (("5" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -27) (("1" (hide -5 -6 -7 -8 -9 -10) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb" -5) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2 1) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb" -5) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 2) (("3" (prop) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 3 -4 -5 -6) (("6" (reveal -22 -16 -17) (("6" (expand "contained?" 1) (("6" (case "subset?(V, V1)") (("1" (case "subset?(V2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand ("member" "difference") -5) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "vars_lst_lst_vars") (("2" (inst 1 "V2") (("2" (assert) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -6 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (case "equal?(append(append(lambda1, delta1), sigma), append(append(append(lambda1, delta1), lambda2), sigma))") (("1" (expand "more_general?" 1) (("1" (inst 1 "append(lambda1, delta1)") (("1" (lemma "equal_sub_trans") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "append(append(lambda1, delta1), append(lambda2, sigma))") (("1" (assert) (("1" (rewrite "append_assoc" -1) (("1" (lemma "append_assoc[basic_sub]") (("1" (inst -1 "append(lambda1, delta1)" "lambda2" "sigma") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "equal?" 1) (("2" (skeep) (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (name-replace "t2" "subs(sigma)(variable(X))") (("2" (lemma "equal_sub_equiv") (("2" (inst -1 "append(lambda1, delta1)" "append(append(lambda1, delta1), lambda2)" "t2") (("2" (assert) (("2" (rewrite "subs_append2" -1) (("2" (rewrite "subs_append2" -1) (("2" (rewrite "subs_append2" -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1 :dir rl) (("2" (use "instantiate_step_unifies_not_fail") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (reveal -17) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb") (("3" (hide -6) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append") (("3" (flatten) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "solve_ac_vars") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (flatten) (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (reveal -13) (("2" (hide -7 -8 -5 -6) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (expand "u_pair" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skeep) (("2" (inst -1 "X") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_equal?") (("2" (inst -1 "_" "lambda1" "_") (("2" (inst?) (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -2) (("2" (expand "unifies?" -2) (("2" (prop) (("2" (reveal -9 -10) (("2" (assert) (("2" (replace -3) (("2" (replace -1 1 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -6) (("3" (expand "all_ac_prb?" -4) (("3" (expand "t") (("3" (inst -4 "u_pair") (("3" (expand "member" -4) (("3" (expand "ac_prb?" -4) (("3" (flatten) (("3" (expand "is_ac_sym?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (expand "all_ac_prb?" -4) (("4" (inst -4 "u_pair") (("4" (expand "member" -4) (("4" (expand "ac_prb?" -4) (("4" (flatten) (("4" (expand "s" 1) (("4" (expand "is_ac_sym?" 1) (("4" (assert) (("4" (expand "t" -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal 1) (("5" (propax) nil nil)) nil) ("6" (hide 3) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (expand "contained?" -7) (("6" (flatten) (("6" (expand "subset?" -7) (("6" (inst -7 "x") (("6" (assert) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "lst_V") (("6" (rewrite "finset2list_mem") (("6" (expand "cur_V") (("6" (expand ("member" "union") 1) (("6" (expand "member" 1 2) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (expand "subset?" 1) (("7" (skeep) (("7" (expand "contained?" -7) (("7" (flatten) (("7" (expand "subset?" -8) (("7" (inst -8 "x") (("7" (assert) (("7" (rewrite "mem_list2set" :dir rl) (("7" (expand "lst_V") (("7" (rewrite "finset2list_mem") (("7" (expand "cur_V" 1) (("7" (expand ("member" "union") 1) (("7" (expand "member" 1 2) (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 3) (("8" (expand "subset?" 1) (("8" (skeep) (("8" (rewrite "mem_list2set" :dir rl) (("8" (expand "lst_V" 1) (("8" (rewrite "finset2list_mem") (("8" (expand "cur_V" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand "vars" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand ("t" "s")) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 3) (("9" (expand "nice_input?" -5) (("9" (flatten) (("9" (hide -10) (("9" (rewrite "well_formed_unif_prb") (("9" (skolem 1 "t1") (("9" (prop) (("9" (rewrite "well_formed_unif_prb") (("9" (inst -10 "t1") (("9" (assert) (("9" (expand "append" 3) (("9" (expand "member" 3) (("9" (expand "member" -1) (("9" (split -1) (("1" (split) (("1" (assert) (("1" (expand "t" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "s" -1) (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" -7) (("2" (inst -7 "u_pair") (("2" (expand "member" -7) (("2" (assert) (("2" (expand "ac_prb?" -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (all_ac_prb? const-decl "bool" unification nil) (well_formed? const-decl "bool" substitution nil) (nice_input? const-decl "bool" apply_ac_step nil) (contained? const-decl "bool" substitution nil) (more_general? const-decl "bool" substitution nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (subset? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (difference const-decl "set" sets nil) (vars def-decl "finite_set[variable]" term_properties nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (subs const-decl "term" substitution nil) (subs def-decl "term" substitution nil) (subterms def-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" term_properties nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (img_null formula-decl nil substitution nil) (null adt-constructor-decl "(null?)" list_adt nil) (equal? def-decl "bool" equality nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (next_input? const-decl "bool" apply_ac_step nil) (finite_union application-judgement "finite_set" finite_sets nil) (next_input_nice_input formula-decl nil apply_ac_step nil) (vars def-decl "finite_set[variable]" unification nil) (union const-decl "set" sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (solve_ac_unify_complete formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (ac_prb? const-decl "bool" unification nil) (unifies? const-decl "bool" unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (unifies?_append_disjoint formula-decl nil unification nil) (instantiate_step_unifies_not_fail formula-decl nil aux_unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (instantiate_step_lst_mem formula-decl nil aux_unification nil) (ac_results skolem-const-decl "list[unif_prb]" apply_ac_step nil) (solve_ac_well_formed formula-decl nil aux_unification nil) (first_proj_mem formula-decl nil list_theory2 nil) (t skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" apply_ac_step nil) (member def-decl "bool" unification nil) (well_formed_unif_prb formula-decl nil unification nil) (s skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" apply_ac_step nil) (append_assoc formula-decl nil list_props nil) (vars_unif_prb formula-decl nil unification nil) (P_CI skolem-const-decl "unif_prb" apply_ac_step nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (u_pair skolem-const-decl "unif_pair" apply_ac_step nil) (i_step_output skolem-const-decl "[unif_prb, sub, bool]" apply_ac_step nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (member_unif_prb_append formula-decl nil unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (vars def-decl "finite_set[variable]" term_properties nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (lambda2 skolem-const-decl "sub" apply_ac_step nil) (apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (sec_proj_mem formula-decl nil list_theory2 nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) (finset2list_mem formula-decl nil list_theory nil) (cur_V skolem-const-decl "finite_set[variable]" apply_ac_step nil) (lst_V skolem-const-decl "list[nat]" apply_ac_step nil) (V1 skolem-const-decl "finite_set[variable]" apply_ac_step nil) (well_formed_append formula-decl nil substitution nil) (vars_img_append formula-decl nil substitution nil) (unifies?_append formula-decl nil unification nil) (subs_append2 formula-decl nil substitution nil) (subs_equal? formula-decl nil substitution nil) (equal?_sym formula-decl nil equality nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_append_disjoint4 formula-decl nil unification nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (unifies?_append_disjoint3 formula-decl nil unification nil) (instantiate_step1_mem_unif_pair formula-decl nil aux_unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (solve_ac_vars formula-decl nil aux_unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_null formula-decl nil list_props nil) (unifies?_equiv formula-decl nil unification nil) (disjoint? const-decl "bool" sets nil) (apply_sub_all_ac formula-decl nil unification nil) (ac_results_subs skolem-const-decl "list[[unif_prb, sub]]" apply_ac_step nil) (list2set def-decl "set[T]" list2set nil) (equal_sub_trans formula-decl nil substitution nil) (equal_sub_equiv formula-decl nil substitution nil) (apply_sub_len formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step_unifies_sub formula-decl nil aux_unification nil) (equal? const-decl "bool" substitution nil) (unifies?_equal formula-decl nil unification nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (every adt-def-decl "boolean" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak))("unification_alg" unification_alg unify_well_formed 0 (unify_well_formed-1 nil 3850725223 ("" (measure-induct "lex4(card(vars_not_ac(unif_prb)), card(vars_under2more(unif_prb)),
     	card(admissible_subterms(unif_prb)), size(unif_prb))" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 ("del" "sig" "V")) (("" (hide -1) (("" (prop) (("" (expand "unify" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (name-replace "up" "choose_unif_pair(P)`1") (("2" (name-replace "t" "up`1") (("2" (name-replace "s" "up`2") (("2" (name-replace "P1" "choose_unif_pair(P)`2") (("2" (split -1) (("1" (flatten) (("1" (name-replace "sig1" "cons((V(s), t), null)") (("1" (name-replace "new_sig" "append(sig1, sig)") (("1" (name-replace "new_P" "apply_sub(sig1, P1)") (("1" (reveal -8) (("1" (inst -1 "new_P") (("1" (prop) (("1" (inst -1 "del" "new_sig" "V") (("1" (assert) (("1" (expand "new_sig" 1) (("1" (case "well_formed?(sig1)") (("1" (prop) (("1" (use "well_formed_append") (("1" (assert) nil nil)) nil) ("2" (expand "new_P" 1) (("2" (use "well_formed_apply_sub") (("2" (assert) (("2" (rewrite "well_formed_unif_prb") (("2" (hide 2) (("2" (rewrite "well_formed_unif_prb") (("2" (skolem 1 "t1") (("2" (inst -5 "t1") (("2" (flatten) (("2" (assert) (("2" (lemma "choose_unif_pair_mem2_alt") (("2" (inst -1 "t1" "P") (("2" (assert) (("2" (expand "P1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "sig1" 1) (("2" (use "basic_sub_well_formed") (("2" (assert) (("2" (assert) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -4 "t") (("2" (assert) (("2" (use "choose_unif_pair_mem1_alt") (("2" (assert) (("2" (expand "t" 1) (("2" (expand "up" 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC1") (("2" (reveal -1 -2 -3 -4 -5 -6) (("2" (inst -7 "P" "sig") (("2" (assert) (("2" (inst -7 "up" "P1") (("2" (assert) (("2" (expand "up" -7 1) (("2" (inst -7 "t" "s") (("2" (assert) (("2" (inst -7 "sig1" "new_sig" "new_P") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "P1") (("1" (prop) (("1" (inst -1 "del" "sig" "V") (("1" (assert) (("1" (rewrite "well_formed_unif_prb") (("1" (rewrite "well_formed_unif_prb") (("1" (skolem 1 "t1") (("1" (inst -5 "t1") (("1" (flatten) (("1" (assert) (("1" (lemma "choose_unif_pair_mem2_alt") (("1" (inst -1 "t1" "P") (("1" (expand "P1" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC2") (("2" (inst -1 "P") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (reveal -3 -4 -5 -6) (("2" (assert) (("2" (inst -5 "t" "s") (("2" (assert) (("2" (inst -5 "a(t)") (("2" (assert) (("2" (use "term_const_eta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (hide 1) (("1" (split -2) (("1" (flatten) (("1" (assert) (("1" (name-replace "sig1" "cons((V(t), s), null)") (("1" (name-replace "new_sig" "append(sig1, sig)") (("1" (name-replace "new_P" "apply_sub(sig1, P1)") (("1" (reveal -8) (("1" (inst -1 "new_P") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "new_sig" 1) (("1" (expand "new_P") (("1" (case "well_formed?(sig1)") (("1" (prop) (("1" (use "well_formed_append") (("1" (assert) nil nil)) nil) ("2" (rewrite "well_formed_apply_sub") (("2" (hide 2) (("2" (rewrite "well_formed_unif_prb") (("2" (rewrite "well_formed_unif_prb") (("2" (skolem 1 "t1") (("2" (inst -5 "t1") (("2" (flatten) (("2" (assert) (("2" (expand "P1") (("2" (lemma "choose_unif_pair_mem2_alt") (("2" (inst -1 "t1" "P") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "sig1" 1) (("2" (use "basic_sub_well_formed") (("2" (assert) (("2" (assert) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -4 "s") (("2" (assert) (("2" (use "choose_unif_pair_mem1_alt") (("2" (assert) (("2" (expand "s" 1) (("2" (expand "up" 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC3") (("2" (inst -1 "P" "sig") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (reveal -3 -4 -5 -5 -7 -8 -9) (("2" (assert) (("2" (expand "P1" -7) (("2" (inst -7 "t" "s") (("2" (assert) (("2" (reveal 2) (("2" (split -7) (("1" (hide 1) (("1" (inst -1 "V(t)") (("1" (assert) (("1" (split) (("1" (inst -1 "sig1" "new_sig" "new_P") (("1" (assert) (("1" (expand "P1" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (use "term_variable_eta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (reveal -1 -2 -3 -4 -5) (("1" (inst -5 "P1") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (rewrite "well_formed_unif_prb") (("1" (rewrite "well_formed_unif_prb") (("1" (skolem 1 "t1") (("1" (inst -10 "t1") (("1" (flatten) (("1" (assert) (("1" (lemma "choose_unif_pair_mem2_alt") (("1" (inst -1 "t1" "P") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC4") (("2" (inst -1 "P") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (assert) (("2" (inst -1 "t" "s") (("2" (assert) (("2" (split -1) (("1" (inst -1 "V(t)") (("1" (assert) (("1" (use "term_variable_eta") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5 1) (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "singleton") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "P1") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (rewrite "well_formed_unif_prb") (("1" (rewrite "well_formed_unif_prb") (("1" (skolem 1 "t1") (("1" (inst -5 "t1") (("1" (flatten) (("1" (assert) (("1" (lemma "choose_unif_pair_mem2_alt") (("1" (inst -1 "t1" "P") (("1" (assert) (("1" (expand "P1" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC5") (("2" (inst -1 "P") (("2" (assert) (("2" (hide 2 3) (("2" (inst -1 "up" "P1") (("2" (expand "up" -1) (("2" (expand "P1" -1) (("2" (inst -1 "t" "s") (("2" (assert) (("2" (reveal -5 -6 -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("unification_alg" unification_alg unify_alg_subs 0 (unify_alg_subs-2 nil 3850741132 ("" (measure-induct "lex4(card(vars_not_ac(unif_prb)), card(vars_under2more(unif_prb)),
     	card(admissible_subterms(unif_prb)), size(unif_prb))" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 ("del" "sig" "V")) (("" (hide -1) (("" (prop) (("" (expand "unify" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (inst 1 "null") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "up" "choose_unif_pair(P)`1") (("2" (name-replace "t" "up`1") (("2" (name-replace "s" "up`2") (("2" (name-replace "P1" "choose_unif_pair(P)`2") (("2" (split -1) (("1" (flatten) (("1" (name-replace "sig1" "cons((V(s), t), null)") (("1" (name-replace "new_sig" "append(sig1, sig)") (("1" (name-replace "new_P" "apply_sub(sig1, P1)") (("1" (reveal -8) (("1" (inst -1 "new_P") (("1" (prop) (("1" (inst -1 "del" "new_sig" "V") (("1" (assert) (("1" (skolem -1 "sig2") (("1" (expand "new_sig" -1) (("1" (inst 3 "append(sig2, sig1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC1") (("2" (reveal -1 -2 -3 -4 -5 -6) (("2" (inst -7 "P" "sig") (("2" (assert) (("2" (inst -7 "up" "P1") (("2" (assert) (("2" (expand "up" -7 1) (("2" (inst -7 "t" "s") (("2" (assert) (("2" (inst -7 "sig1" "new_sig" "new_P") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "P1") (("1" (prop) (("1" (inst -1 "del" "sig" "V") (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC2") (("2" (inst -1 "P") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (reveal -3 -4 -5 -6) (("2" (assert) (("2" (inst -5 "t" "s") (("2" (assert) (("2" (inst -5 "a(t)") (("2" (assert) (("2" (use "term_const_eta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (hide 1) (("1" (split -2) (("1" (flatten) (("1" (assert) (("1" (name-replace "sig1" "cons((V(t), s), null)") (("1" (name-replace "new_sig" "append(sig1, sig)") (("1" (name-replace "new_P" "apply_sub(sig1, P1)") (("1" (reveal -8) (("1" (inst -1 "new_P") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (skolem -1 "sig2") (("1" (expand "new_sig" -1) (("1" (inst 3 "append(sig2, sig1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC3") (("2" (inst -1 "P" "sig") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (reveal -3 -4 -5 -5 -7 -8 -9) (("2" (assert) (("2" (expand "P1" -7) (("2" (inst -7 "t" "s") (("2" (assert) (("2" (reveal 2) (("2" (split -7) (("1" (hide 1) (("1" (inst -1 "V(t)") (("1" (assert) (("1" (split) (("1" (inst -1 "sig1" "new_sig" "new_P") (("1" (assert) (("1" (expand "P1" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (use "term_variable_eta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (reveal -1 -2 -3 -4 -5) (("1" (inst -5 "P1") (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC4") (("2" (inst -1 "P") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (assert) (("2" (inst -1 "t" "s") (("2" (assert) (("2" (split -1) (("1" (inst -1 "V(t)") (("1" (assert) (("1" (use "term_variable_eta") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5 1) (("2" (assert) (("2" (expand "vars" 1) (("2" (expand ("member" "singleton") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "P1") (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC5") (("2" (inst -1 "P") (("2" (assert) (("2" (hide 2 3) (("2" (inst -1 "up" "P1") (("2" (expand "up" -1) (("2" (expand "P1" -1) (("2" (inst -1 "t" "s") (("2" (assert) (("2" (reveal -5 -6 -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 1 2 3) (("2" (name-replace "P2" "decompose(arg(t), arg(s))") (("2" (name-replace "new_P" "append(P2, P1)") (("2" (name-replace "f" "f_sym(t)") (("2" (reveal -1 -2 -3 -4 -5 -6 -7 -8) (("2" (inst -8 "new_P") (("2" (prop) (("1" (inst -1 "del" "sig" "V") (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC6") (("2" (inst -1 "P") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (assert) (("2" (inst -1 "t" "s") (("2" (assert) (("2" (inst -1 "f" "arg(t)") (("2" (assert) (("2" (prop) (("1" (inst -1 "P2" "new_P") (("1" (assert) nil nil)) nil) ("2" (use "term_app_eta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 1 2 3 4 5) (("2" (rewrite "mem_flatten_map2") (("2" (skolem -3 "input") (("2" (flatten) (("2" (reveal -5) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "del" "input`2" "input`3") (("1" (assert) (("1" (skolem -1 "sig2") (("1" (use "apply_ac_step_sub_decompose") (("1" (assert) (("1" (skolem -1 "sig1") (("1" (replace -1) (("1" (inst 1 "append(sig2, sig1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC7") (("2" (inst -1 "P" "sig" "V") (("2" (assert) (("2" (inst -1 "up" "P1") (("2" (assert) (("2" (reveal -3 -4 -5 -6) (("2" (assert) (("2" (inst -5 "t" "s") (("2" (assert) (("2" (name-replace "f" "ac_sym(t)") (("2" (inst -5 "f" "ac_arg(t)") (("1" (assert) (("1" (prop) (("1" (inst -1 "apply_ac_step(P, null, sig, V)") (("1" (rewrite "every_nth") (("1" (rewrite "member_nth2") (("1" (skolem -8 "i") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ac_app?(t)") (("1" (lemma "term_ac_app_eta") (("1" (inst -1 "t") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (expand "apply_ac_step" -7) (("2" (lift-if) (("2" (split -7) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide -2) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "up") (("2" (expand "ac_prb?" -1) (("2" (assert) (("2" (use "choose_unif_pair_mem1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "apply_ac_step " -7) (("2" (lift-if) (("2" (split -7) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide -2) (("2" (expand "all_ac_prb?" -1) (("2" (inst -1 "up") (("2" (assert) (("2" (expand "ac_prb?" -1) (("2" (use "choose_unif_pair_mem1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (ordstruct type-decl nil ordstruct_adt nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (unif_prb type-eq-decl nil unification nil) (lex4 const-decl "ordinal" lex4 nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (vars_not_ac def-decl "finite_set[variable]" termination_alg nil) (vars_under2more const-decl "finite_set[variable]" termination_alg nil) (admissible_subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" termination_alg nil) (size def-decl "nat" unification nil) (< def-decl "bool" ordinals nil) (well_founded_le formula-decl nil ordinals nil) (append def-decl "list[T]" list_props nil) (unify def-decl "list[sub]" unification_alg nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (choose_unif_pair const-decl "[unif_pair, unif_prb]" aux_unification nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (apply_sub def-decl "unif_prb" unification nil) (unify_TCC1 termination-tcc nil unification_alg nil) (up skolem-const-decl "unif_pair" unification_alg nil) (append_assoc formula-decl nil list_props nil) (new_sig skolem-const-decl "list[[variable, term[constant, variable, f_symbol, ac_symbol]]]" unification_alg nil) (apply_ac_step_sub_decompose formula-decl nil apply_ac_step nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_ac_app_eta formula-decl nil term_adt nil) (choose_unif_pair_mem1 formula-decl nil aux_unification nil) (ac_prb? const-decl "bool" unification nil) (all_ac_prb? const-decl "bool" unification nil) (member_nth2 formula-decl nil list_theory nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (every_nth formula-decl nil list_props nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (t skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" unification_alg nil) (unify_TCC7 termination-tcc nil unification_alg nil) (mem_flatten_map2 formula-decl nil map_theory nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (term_app_eta formula-decl nil term_adt nil) (unify_TCC6 termination-tcc nil unification_alg nil) (f_sym adt-accessor-decl "[(app?) -> f_symbol]" term_adt nil) (decompose def-decl "unif_prb" unification nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (arg adt-accessor-decl "[(app?) -> term]" term_adt nil) (unify_TCC5 termination-tcc nil unification_alg nil) (new_sig skolem-const-decl "list[[variable, term[constant, variable, f_symbol, ac_symbol]]]" unification_alg nil) (term_variable_eta formula-decl nil term_adt nil) (P1 skolem-const-decl "unif_prb" unification_alg nil) (unify_TCC3 termination-tcc nil unification_alg nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (vars def-decl "finite_set[variable]" term_properties nil) (unify_TCC4 termination-tcc nil unification_alg nil) (unify_TCC2 termination-tcc nil unification_alg nil) (a adt-accessor-decl "[(const?) -> constant]" term_adt nil) (const? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_const_eta formula-decl nil term_adt nil)) nil) (unify_alg_subs-1 nil 3838237025 ("" (measure-induct "lex4(card(vars_not_ac(unif_prb)), card(vars_under2more(unif_prb)),
	card(admissible_subterms(unif_prb)), size(unif_prb))" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "unify" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (inst 1 "null") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "unif_pair" "choose_unif_pair(unif_prb)`1") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "unif_prb1" "choose_unif_pair(unif_prb)`2") (("2" (split -1) (("1" (flatten) (("1" (name-replace "sigma1" "cons((V(s), t), null)") (("1" (reveal -6) (("1" (inst -1 "apply_sub(sigma1, unif_prb1)") (("1" (prop) (("1" (inst -1 "delta" "append(sigma1, sigma)" "vars2avoid") (("1" (assert) (("1" (skolem -1 "sigma2") (("1" (inst 3 "append(sigma2, sigma1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC1") (("2" (inst -1 "unif_prb" "sigma") (("2" (assert) (("2" (hide 4) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (inst -1 "sigma1" "append(sigma1, sigma)" "apply_sub(sigma1, unif_prb1)") (("2" (assert) (("2" (expand "sigma1" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "unif_prb1") (("1" (prop) (("1" (inst -1 "delta" "sigma" "vars2avoid") (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC2") (("2" (inst -1 "unif_prb") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (assert) (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (inst -1 "a(t)") (("2" (replace -1) (("2" (lemma "term_const_eta") (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (assert) (("1" (name-replace "sigma1" "cons((V(t), s), null)") (("1" (reveal -6) (("1" (inst -1 "apply_sub(sigma1, unif_prb1)") (("1" (assert) (("1" (prop) (("1" (inst -1 "delta" "append(sigma1, sigma)" "vars2avoid") (("1" (assert) (("1" (skolem -1 "sigma2") (("1" (inst 4 "append(sigma2, sigma1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3 5 -1) (("2" (lemma "unify_TCC3") (("2" (inst -1 "unif_prb" "sigma") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (reveal 3) (("2" (assert) (("2" (split -1) (("1" (inst -1 "V(t)") (("1" (assert) (("1" (prop) (("1" (inst -1 "sigma1" "append(sigma1, sigma)" "apply_sub(sigma1, unif_prb1)") (("1" (expand "sigma1" -1 1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst -2 "sigma1" "append(sigma1, sigma)" "apply_sub(sigma1, unif_prb1)") (("2" (expand "sigma1" -2) (("2" (assert) (("2" (expand "sigma1" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "term_variable_eta") (("3" (inst -1 "t") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "term_variable_eta") (("4" (inst -1 "t") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal -5) (("1" (inst -1 "unif_prb1") (("1" (assert) (("1" (prop) (("1" (inst -1 "delta" "sigma" "vars2avoid") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (lemma "unify_TCC4") (("2" (inst -1 "unif_prb") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (assert) (("2" (reveal 2) (("2" (assert) (("2" (inst -2 "V(t)") (("2" (assert) (("2" (lemma "term_variable_eta") (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (hide 1 2) (("1" (reveal -5) (("1" (inst -1 "unif_prb1") (("1" (assert) (("1" (prop) (("1" (inst -1 "delta" "sigma" "vars2avoid") (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC5") (("2" (inst -1 "unif_prb") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" 1 1) (("2" (expand "s" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1 2 3) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (name-replace "unif_pair1" "(term1(t), term1(s))") (("2" (name-replace "unif_pair2" "(term2(t), term2(s))") (("2" (reveal -7) (("2" (inst -1 "cons(unif_pair1, cons(unif_pair2, unif_prb1))") (("2" (prop) (("1" (inst -1 "delta" "sigma" "vars2avoid") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (lemma "unify_TCC6") (("2" (inst -1 "unif_prb") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (inst -1 "term1(t)" "term2(t)") (("2" (prop) (("1" (inst -1 "unif_pair1" "unif_pair2" "cons(unif_pair1, cons(unif_pair2, unif_prb1))") (("1" (prop) (("1" (expand "unif_pair1" 1) (("1" (propax) nil nil)) nil) ("2" (expand "unif_pair2") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "term_pair_eta") (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (hide 1) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (reveal -5) (("2" (inst -1 "cons((arg(t), arg(s)), unif_prb1)") (("2" (prop) (("1" (inst -1 "delta" "sigma" "vars2avoid") (("1" (assert) nil nil)) nil) ("2" (lemma "unify_TCC7") (("2" (inst -1 "unif_prb") (("2" (assert) (("2" (hide 4) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (inst -1 "f_sym(t)" "arg(t)") (("2" (assert) (("2" (prop) (("1" (inst -1 "(arg(t), arg(s))" "cons((arg(t), arg(s)), unif_prb1)") nil nil) ("2" (lemma "term_app_eta") (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 1 2) (("2" (lemma "mem_flatten_map2[[unif_prb, sub, finite_set[variable]], sub]") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "input") (("2" (prop) (("2" (hide -5) (("2" (reveal -7) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "delta" "input`2" "input`3") (("1" (assert) (("1" (skolem -1 "sigma2") (("1" (lemma "apply_ac_step_sub_decompose") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "sigma1") (("1" (replace -1) (("1" (inst 2 "append(sigma2, sigma1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unify_TCC8") (("2" (inst -1 "unif_prb" "sigma" "vars2avoid") (("2" (assert) (("2" (inst -1 "unif_pair" "unif_prb1") (("2" (expand "unif_pair" -1 1) (("2" (expand "unif_prb1" -1 1) (("2" (inst -1 "t" "s") (("2" (expand "t" -1 1) (("2" (expand "s" -1 1) (("2" (inst -1 "ac_sym(t)" "ac_arg(t)") (("2" (assert) (("2" (prop) (("1" (inst -1 "apply_ac_step(simplify(unif_prb), null, sigma, vars2avoid)") (("1" (assert) (("1" (rewrite "every_nth") (("1" (lemma "member_nth2[ac_sol_simp]") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (skolem -2 "n") (("1" (inst -1 "n") (("1" (replace -2 :dir rl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "term_ac_app_eta") (("2" (inst -1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (size def-decl "nat" unification nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (term_const_eta formula-decl nil term_adt nil) (const? adt-recognizer-decl "[term -> boolean]" term_adt nil) (a adt-accessor-decl "[(const?) -> constant]" term_adt nil) (term_variable_eta formula-decl nil term_adt nil) (simplify def-decl "unif_prb" apply_ac_step nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (term_ac_app_eta formula-decl nil term_adt nil) (member_nth2 formula-decl nil list_theory nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_arg adt-accessor-decl "[(ac_app?) -> term]" term_adt nil) (apply_ac_step_sub_decompose formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (term_app_eta formula-decl nil term_adt nil) (f_sym adt-accessor-decl "[(app?) -> f_symbol]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (arg adt-accessor-decl "[(app?) -> term]" term_adt nil) (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_pair_eta formula-decl nil term_adt nil) (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (apply_sub def-decl "unif_prb" unification nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (choose_unif_pair const-decl "[unif_pair, unif_prb]" aux_unification nil)) shostak))("unification" unification decompose_correct 0 (decompose_correct-1 nil 3850475002 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skolem 1 ("s" "sig")) (("" (hide -1) (("" (iff) (("" (prop) (("1" (expand "decompose" 1 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (rewrite "unifies?_append" 1) (("1" (expand "unifies?" -3) (("1" (reveal -1) (("1" (prop) (("1" (inst -1 "term1(t)") (("1" (prop) (("1" (inst -1 "term1(s)" "sig") (("1" (assert) (("1" (lemma "term_pair_eta") (("1" (inst -1 "t") (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (replace -1 -4 :dir rl) (("1" (rewrite "subs_pair") (("1" (lemma "term_pair_eta") (("1" (inst -1 "s") (("1" (replace -1 -5 :dir rl) (("1" (rewrite "subs_pair") (("1" (expand "equal?" -5) (("1" (flatten) (("1" (expand "unifies?" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -1 "term2(t)") (("2" (prop) (("1" (inst -1 "term2(s)" "sig") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "unifies?" 1) (("1" (lemma "term_pair_eta") (("1" (inst -1 "t") (("1" (replace -1 -4 :dir rl) (("1" (lemma "term_pair_eta") (("1" (inst -1 "s") (("1" (replace -1 -5 :dir rl) (("1" (rewrite "subs_pair") (("1" (rewrite "subs_pair") (("1" (expand "equal?" -5) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "unifies?" 2 1) (("2" (assert) (("2" (expand "unifies?" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "decompose" -1 1) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (lemma "term_pair_eta") (("1" (inst -1 "t") (("1" (lemma "term_pair_eta") (("1" (inst -1 "s") (("1" (replace -2 1 :dir rl) (("1" (replace -1 1 :dir rl) (("1" (expand "unifies?" 1) (("1" (rewrite "subs_pair") (("1" (rewrite "subs_pair") (("1" (expand "equal?" 1) (("1" (rewrite "unifies?_append") (("1" (flatten) (("1" (reveal -2) (("1" (prop) (("1" (inst -1 "term1(t)") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "unifies?" -1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -1 "term2(t)") (("2" (prop) (("1" (inst? -1) (("1" (assert) (("1" (expand "unifies?" -1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "unifies?" -1) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) (unifies?_append formula-decl nil unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (term_pair_eta formula-decl nil term_adt nil) (subs_pair formula-decl nil substitution nil) (decompose def-decl "unif_prb" unification nil) (unifies? def-decl "bool" unification nil) (unif_prb type-eq-decl nil unification nil) (unifies? const-decl "bool" unification nil) (unif_pair type-eq-decl nil unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("unification" unification decompose_correct_app 0 (decompose_correct_app-1 nil 3850475986 ("" (skeep) (("" (iff) (("" (prop) (("1" (expand "unifies?" -1) (("1" (rewrite "subs_app") (("1" (rewrite "subs_app") (("1" (expand "equal?" -1) (("1" (prop) (("1" (use "decompose_correct") (("1" (expand "unifies?" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "unifies?" 1) (("2" (rewrite "subs_app") (("2" (rewrite "subs_app") (("2" (expand "equal?" 1) (("2" (use "decompose_correct") (("2" (assert) (("2" (replace -1 :dir rl) (("2" (expand "unifies?" -2) (("2" (assert) (("2" (hide -1) (("2" (use "equal?_num_arg2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((equal?_num_arg2 formula-decl nil equality nil) nil (unifies? const-decl "bool" unification nil) (decompose_correct formula-decl nil unification nil) nil (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (string type-eq-decl nil strings nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (subs_app formula-decl nil substitution nil)) shostak))("unification" unification decompose_no_pair 0 (decompose_no_pair-1 nil 3850482873 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skolem 1 ("s" "sig")) (("" (prop) (("" (expand "decompose" 1) (("" (split 1) (("1" (flatten) (("1" (expand "unifies?" -5) (("1" (lemma "term_pair_eta") (("1" (inst -1 "t") (("1" (replace -1 -6 :dir rl) (("1" (lemma "term_pair_eta") (("1" (inst -1 "s") (("1" (replace -1 -7 :dir rl) (("1" (rewrite "subs_pair") (("1" (rewrite "subs_pair") (("1" (expand "equal?" -7) (("1" (flatten) (("1" (expand "no_pair?" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (inst -7 "term1(t)") (("1" (prop) (("1" (inst -1 "term1(s)" "sig") (("1" (assert) (("1" (expand "unifies?" -1) (("1" (expand "no_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -7 "term2(t)") (("2" (prop) (("1" (inst -1 "term2(s)" "sig") (("1" (assert) (("1" (expand "unifies?" -1) (("1" (expand "no_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "no_pair?" 2) (("2" (skeep) (("2" (expand "member" -1) (("2" (assert) (("2" (split -1) (("1" (split -1) (("1" (replace -1) (("1" (assert) (("1" (expand "unifies?" -5) (("1" (lemma "term_pair_eta") (("1" (inst -1 "t") (("1" (replace -1 -6 :dir rl) (("1" (rewrite "subs_pair") (("1" (expand "equal?" -6) (("1" (flatten) (("1" (lemma "subs_pair2") (("1" (inst -1 "sig" "s") (("1" (assert) (("1" (expand "well_formed?" -6) (("1" (inst -6 "V(s)") (("1" (assert) (("1" (flatten) (("1" (expand "subs" 2) (("1" (assert) (("1" (lemma "term_variable_eta") (("1" (inst -1 "s") (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand "unifies?" -5) (("2" (lemma "equal?_sym") (("2" (inst -1 "subs(sig)(s)" "subs(sig)(t)") (("2" (assert) (("2" (lemma "term_pair_eta") (("2" (inst -1 "s") (("2" (replace -1 -2 :dir rl) (("2" (rewrite "subs_pair" -2) (("2" (expand "equal?" -2) (("2" (flatten) (("2" (lemma "subs_pair2") (("2" (inst?) (("2" (assert) (("2" (hide -8) (("2" (expand "well_formed?" -8) (("2" (inst -8 "V(t)") (("2" (lemma "term_variable_eta") (("2" (inst -1 "t") (("2" (expand "subs" -9 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subs_pair2 formula-decl nil substitution nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_variable_eta formula-decl nil term_adt nil) (equal?_sym formula-decl nil equality nil) (term_pair_eta formula-decl nil term_adt nil) (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil) (subs_pair formula-decl nil substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member const-decl "bool" sets nil) (subs const-decl "term" substitution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member_unif_prb_append formula-decl nil unification nil) (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) (decompose def-decl "unif_prb" unification nil) (no_pair? const-decl "bool" unification nil) (unif_prb type-eq-decl nil unification nil) (unifies? const-decl "bool" unification nil) (unif_pair type-eq-decl nil unification nil) (well_formed? const-decl "bool" substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("unification" unification decompose_app_well_formed 0 (decompose_app_well_formed-1 nil 3850483735 ("" (skeep) (("" (expand "well_formed?" 1) (("" (skolem 1 "t1") (("" (split 1) (("1" (flatten) (("1" (rewrite "decompose_subterm") (("1" (expand "well_formed?" -5) (("1" (flatten) (("1" (expand "subterms" -1) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "well_formed?" -5) (("1" (inst -5 "t1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "well_formed?" -6) (("2" (inst -6 "t1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "decompose_no_pair") (("2" (inst -1 "s" "sigma" "t") (("2" (assert) (("2" (prop) (("1" (expand "no_pair?" -1) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "unifies?") (("2" (rewrite "subs_app") (("2" (rewrite "subs_app") (("2" (expand "equal?" -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((basic_sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (sub type-eq-decl nil substitution nil) (no_pair? const-decl "bool" unification nil) (subs_app formula-decl nil substitution nil) (string type-eq-decl nil strings nil) (decompose_no_pair formula-decl nil unification nil) (subterms const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" unification nil) (subs const-decl "term" substitution nil) (well_formed? const-decl "bool" substitution nil) (unifies? const-decl "bool" unification nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (decompose_subterm formula-decl nil unification nil)) shostak))