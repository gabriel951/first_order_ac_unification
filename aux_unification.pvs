%
% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: aux_unification.pvs
% Description: auxiliary functions called in the unification algorithm 

%%%%%%%%%%%%%%%%%%%%%%%

aux_unification: THEORY
BEGIN
	IMPORTING substitution, diophantine

sigma: VAR Sub


% a unification pair (t, s) is composed of terms t and s that must be unified
Unif_pair: TYPE = [Term, Term]

% a unification problem is a list of unification pairs
Unif_prb: TYPE = list[Unif_pair]
unif_prb: VAR Unif_prb

% to one particular ac solution there corresponds a pair of sequence of terms
Ac_sol: TYPE = [list[Term], list[Term]]

sym: VAR string

t1, t2: VAR Term
arg_lst: VAR list[Term]

mult_t1, mult_t2, row: VAR list[nat]
bound, i: VAR nat

dio_sol_matrix, dio_matrix: VAR Dio_matrix
submatrix_sol_lst, dio_matrix_lst: VAR list[Dio_matrix]

vars2avoid: VAR set[Variable]

ac_sol: VAR Ac_sol
ac_sol_lst: VAR list[Ac_sol]
ac_sol_simp: VAR [Sub, Ac_sol]
ac_sol_simp_lst: VAR list[[Sub, Ac_sol]]

% this corresponds to function elimcom in Fages paper
elim_com_arg(t1, t2, sym): [list[Term], list[nat], list[nat]] =
    LET 
    % get the arguments of t1 and how many times they appear
    (args_t1, coef_t1) = get_args_coef_ac(t1, sym),
    % get the arguments of t2 and how many times they appear
    (args_t2, coef_t2) = get_args_coef_ac(t2, sym),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t1
    (new_args_t1, new_coef_t1) = select_args(args_t1, coef_t1, args_t2, coef_t2),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t2
    (new_args_t2, new_coef_t2) = select_args(args_t2, coef_t2, args_t1, coef_t1)
    IN (append(new_args_t1, new_args_t2), new_coef_t1, new_coef_t2)


% check if column i is empty (all coeficients equal to 0)
% you must make sure dio_matrix is a matrix and i < num_col_dio_matrix 
empty_col?(dio_matrix)(i): bool =
    LET col_i = get_col_i[nat](dio_matrix, i, 0) IN 
    	IF (member(n, col_i) => n = 0) THEN TRUE
    	ELSE FALSE
    	ENDIF

% Constraint 1: Every column has at least one coefficient greater than 0 
const1?(dio_matrix, arg_lst): bool =
     empty_col_lst = map(empty_col?(dio_matrix), from_min2max(1, length(arg_lst)))
     IF member(FALSE, non_empty_col_lst) THEN FALSE
     ELSE TRUE 
     
% Constraint 2: One coefficient is equal to one, the others are zero 
const2?(col): bool =
    IF count(1, col_i) = 1 AND count(0, col_i) = length(col_i) - 1 THEN TRUE
    ELSE FALSE
    ENDIF

% returns false if column "i" corresponds to a non-variable argument and does not satisfy constraint 2
% returns true otherwise
if_non_var_cons2_col?(dio_matrix, arg_lst)(i): 
    IF i > length(arg_lst) THEN FALSE 
    ELSE LET arg = nth(arg_lst, i-1) IN 
    	     IF var?(arg) THEN TRUE
	     ELSE LET col_i = get_col_i[nat](dio_matrix, i, 0) IN
	     	      const2?(col_i)
	     ENDIF
    ENDIF

% return true if all columns that correspond to a non-variable argument satisfy constraint 2
if_non_var_cons2?(dio_matrix, arg_lst): bool =
     LET lst_non_var_cons2 = map(if_non_var_cons2_col?(dio_matrix, arg_lst),
     	 		     	   from_min2max(1, length(arg_lst))) IN
     IF member(FALSE, lst_non_var_cons2) THEN FALSE
     ELSE TRUE
     ENDIF

% a nice submatrix is one that satisfies constraint 1 and for every column that is not a variable
% satisfies constraint 2
nice_submatrix?(dio_matrix, arg_lst, i): bool =
     const1?(dio_matrix) AND if_non_var_const2?(dio_matrix, arg_lst)

% receives a list of dio matrix
% returns a list of the ones that satisfy the property of being nice
get_nice_submatrices(dio_matrix_lst, arg_lst): RECURSIVE list[Dio_matrix] =
    IF null?(dio_matrix_lst) THEN null
    ELSE LET dio_matrix = car(dio_matrix_lst) IN
    	 IF nice_submatrix?(dio_matrix, arg_lst, length(arg_lst)) THEN
	    cons(dio_matrix, get_nice_submatrices(dio_matrix_lst, arg_lst))
	 ELSE get_nice_submatrices(cdr(dio_matrix_lst), arg_lst)
	 ENDIF
    ENDIF
MEASURE dio_matrix_lst BY << 


% extract the relevant submatrices. Each submatrix corresponds to one ac-solution
% this corresponds to function partit in Fages article
extract_submatrices(dio_sol_matrix, arg_lst): list[Dio_matrix] =
    % check that the dio_sol_matrix is not only a list of lists but also a matrix
    IF nonmatrix?(dio_sol_matrix) THEN null
    ELSE LET all_submatrices = get_all_sublists(dio_sol_matrix) 
    	     IN get_nice_submatrices(all_submatrices, arg_lst)
    ENDIF
    	   
% receives a list of columns and the current column index "i" we are looking
% initially should be called with "cur_col_ind = 1"
% returns a list of the columns that satisfy constraint 2 and their index
get_col_and_ind_cons2(lst_col, i): [list[list[nat]], list[nat]] =
    IF null?(lst_col) THEN (null, null)
    ELSE LET col = car(lst_col)
    	 IN IF const2?(col) THEN
	       (cons(col, get_col_and_ind_cons2(cdr(lst_col), i+1)`1),
	        cons(i, get_col_and_ind_cons2(cdr(lst_col), i+1)`2))
	    ELSE get_col_and_ind_cons2(cdr(lst_col), i+1)
	    ENDIF
    ENDIF

% receives:
%   - a list containing "num_line" entries. Each entry will contain the columns indexes of the
%     	columns which satisfy constraint 2  
%   - a list of columns that satisfy constraint 2
%   - a list of their index
get_col_ind_cons2_per_line(ind_cons2_per_line, lst_col_const2, lst_ind_col_const2): 

% this corresponds to function trans in Fages paper
dio_matrix_to_ac_sol(arg_lst, vars2avoid)(dio_matrix): list[Ac_sol] =
    LET
    num_col = length(arg_lst),
    num_lines = length(dio_matrix)
    
    % get the columns and index_of_columns that satisfy constraint 2
    % obs: "lst_ind_col_const2" corresponds to "J" in Fages paper
    lst_col = map(get_col_i(dio_matrix, 0), from_min2max(1, num_col))
    (lst_col_const2, lst_ind_col_const2) = get_col_and_ind_const2(lst_col, 1) 
    
    % for every line i, get the column indexes that satisfy constraint 2 in this line
    % "ind_col_const2_per_line" corresponds to a list of "phi(i)"
    ind_col_const2_per_line = get_col_ind_cons2_per_line(get_repeat_lst(null, num_lines),
    			  	lst_col_const2, lst_ind_col_const2)

    % for each row, create the appropriate row variable
    lst_row_vars = get_lst_row_vars(ind_col_const2_per_line, vars2avoid)

    %This corresponds to [B_1, ..., Bq] in Fages notation 
    new_arg_lst = get_new_arg_lst(lst_row_vars , lst_ind_col_const2) 

    % Return 
    in get_pair_lst(arg_lst, new_arg_lst)

    
% this corresponds to function "dio" in Fages paper
solve_ac(t1, t2, vars2avoid, sym): list[Ac_sol] =
    LET
%    eliminate common arguments from t1 and t2, obtaining the different arguments on each one
%    and their multiplicity
     (arg_lst, mult_t1, mult_t2) = elim_com_arg(t1, t2, sym),
%    calculate upper bound from which we can solve the diophantine equation
     bound = calculate_upper_bound(mult_t1, mult_t2),
%    solve diophantine equation until the upper bound 
     dio_sol_matrix = dio_solver(mult_t1, mult_t2, bound),
%    extract "nice" submatrices of solutions
     submatrix_sol_lst = extract_submatrices(dio_sol_matrix, arg_lst),
%    for every diophantine submatrix obtain the corresponding unification solution
     ac_sol_lst = null %map(submatrix_sol_lst,)
     IN ac_sol_lst


% this functions corresponds to the homonymous function "elimvar" in Fages paper
elimvar(ac_sol): [Sub, Ac_sol] =
((::), ((::), (::))) 


% apply function elimvar to every ac_sol in ac_sol_lst
% TODO: this can be replaced by a simple "map"
apply_elimvar(ac_sol_lst): RECURSIVE list[[Sub, Ac_sol]] =
    IF null?(ac_sol_lst) THEN (::)
    ELSE LET ac_sol = car(ac_sol_lst),
             ac_sol_simp = elimvar(ac_sol) 
             IN cons(ac_sol_simp, apply_elimvar(cdr(ac_sol_lst)))
    ENDIF
MEASURE ac_sol_lst BY << 


construct_input(ac_sol_simp, unif_prb, sigma, vars2avoid): [Unif_prb, Sub, set[Variable]] =
((::), (::), (::))

% construct a list of inputs that will be passed to unify
construct_input_lst(ac_sol_simp_lst, unif_prb, sigma, vars2avoid): RECURSIVE list[[Unif_prb, Sub, set[Variable]]] =
    IF null?(ac_sol_simp_lst) THEN (::)
    ELSE LET input = construct_input(car(ac_sol_simp_lst), unif_prb, sigma, vars2avoid)
    	     IN cons(input, construct_input_lst(cdr(ac_sol_simp_lst), unif_prb, sigma, vars2avoid))
    ENDIF
MEASURE ac_sol_simp_lst BY << 


END aux_unification 
