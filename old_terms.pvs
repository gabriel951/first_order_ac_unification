% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: Terms.pvs
% Description: Definition of a first order term and properties related to them

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% definition of a term
term[constant:TYPE, variable:TYPE+, f_symbol:TYPE, ac_symbol:TYPE]: DATATYPE
    BEGIN
	const (a: constant): const?
	variable (V: variable): var?
	unit: unit?
	pair (term1: term, term2: term): pair?
	app (f_sym: f_symbol, arg: term): app?
	ac_app (ac_sym: ac_symbol, ac_arg: term): ac_app? 
    END term


%%%%%%%%%%%%%%%%%%%%%%%%%%
term_properties: THEORY
BEGIN

% definition of variable, constant and syntactic and AC function symbols 
variable: TYPE = nat
constant: TYPE = nat
f_symbol: TYPE = string
ac_symbol: TYPE = string

IMPORTING basic_notions,
	  term[constant, variable, f_symbol, ac_symbol],
	  list_theory[term]

sym, f: VAR string
n, i, j: VAR nat

t, s: VAR term

args: TYPE = list[term]
args: VAR args

% the size of a term 
size(t): RECURSIVE nat =
    CASES t OF
        const(a): 1,
	variable(X): 1, 
	unit: 1, 
	pair(t1, t2): 1 + size(term1(t)) + size(term2(t)),
	app(sym, arg): 1  + size(arg),
	ac_app(sym, arg): 1  + size(arg)
    ENDCASES
MEASURE t BY << 

% test if t is an AC function symbol headed by sym
is_ac_sym?(t, sym): bool = ac_app?(t) AND sym = ac_sym(t)

% test if t and s are AC function symbols headed by "sym"
are_ac?(t, s, sym): bool = ac_app?(t) AND ac_app?(s) AND sym = ac_sym(t) AND sym = ac_sym(s) 

% get the number of arguments of a term "t"
% if it encounters an ac function whose root is "sym" it goes inside the function
num_arg(sym, t): RECURSIVE nat =
    IF pair?(t) THEN num_arg(sym, term1(t)) + num_arg(sym, term2(t))
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN num_arg(sym, ac_arg(t))
    ELSE 1
    ENDIF
MEASURE t BY << 


% select the nth (index start at one) argument of an a term.
% if it encounters an ac function whose root is "sym" it goes inside the function
select(sym, t)(n): RECURSIVE term =
    IF pair?(t) THEN
        LET n1 = num_arg(sym, term1(t)) IN
        IF n <= n1 THEN select(sym, term1(t))(n)
        ELSE select(sym, term2(t))(n-n1)
        ENDIF
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN select(sym, ac_arg(t))(n)
    ELSE t
    ENDIF 
MEASURE t BY <<

% delete the nth (index start at one) argument of a term
% if it encounters an ac function whose root is "sym" it goes inside the function
delete(sym, t)(n): RECURSIVE term =
   IF pair?(t) THEN LET
       num_arg1 = num_arg(sym, term1(t)),
       num_arg2 = num_arg(sym, term2(t)) IN
       IF n <= num_arg1 THEN
	  IF num_arg1 = 1 THEN term2(t)
	  ELSE pair(delete(sym, term1(t))(n), term2(t))
	  ENDIF
       ELSE
	  IF num_arg2 = 1 THEN term1(t)
	  ELSE pair(term1(t), delete(sym, term2(t))(n - num_arg1))
	  ENDIF
       ENDIF
   ELSIF ac_app?(t) AND ac_sym(t) = sym THEN
       IF num_arg(sym, t) = 1 THEN unit
       ELSE ac_app(ac_sym(t), delete(sym, ac_arg(t))(n))
       ENDIF 
   ELSE unit 
   ENDIF
MEASURE t by <<

% return the predecessor of "i", considering that a term has "n" arguments
% when you apply "select" and "delete" and the number passed "i" is greater than the "n"
% the functions "select" and "delete" act like it the number passed is "n"
% this function takes that into account and return the predecessor of "i"
% the predecessor of 0 does not make sense and is defined arbitrarily as 0 itself
predecessor(i, n): nat =
    IF i = 0 THEN 0 
    ELSIF i >= n THEN n - 1
    ELSE i - 1
    ENDIF

% return the successor of "i", considering that a term has "n" arguments.
% when you apply "select" and "delete" and the number passed "i" is 0
% the functions "select" and "delete" act like the number passed was 1
% this function takes that into account and return the successor of "i" (2 when i = 0) 
successor(i): nat =
    IF i = 0 THEN 2 
    ELSE i + 1
    ENDIF


% i = j in a sense described by the lemma of correctness of this function 
eq_ind_term?(i, j, sym, t): bool =
   LET n = num_arg(sym, t) IN
   IF n = 1 THEN TRUE  
   ELSE (i = j) OR (i = 0 AND j = 1) OR (i = 1 AND j = 0) OR (i >= n AND j >= n) 
   ENDIF 

% i > j in the sense of eq_ind_term?
gt_ind_term?(i, j, sym, t): bool =
   NOT eq_ind_term?(i, j, sym, t) AND i > j 

% i < j, in the sense of lt_ind_term?
lt_ind_term?(i, j, sym, t): bool = 
   NOT eq_ind_term?(i, j, sym, t) AND i < j

% get the arguments of a term t.
% if it encounters an ac function whose root is "sym" it goes inside the function
get_args(sym)(t): args =
    LET n = num_arg(sym, t), lst_until_n = from_min2max(1, n) IN 
    	map(select(sym, t))(lst_until_n)
    
% get a list of arguments of an AC_term t (whose function symbol is sym)
% and how many times they appear as arguments
get_args_coef_ac(t, sym): [args, list[nat]] =
    LET args = get_args(sym)(t) IN
    count_elem(null, null, args)

% obtain a term to represent a whole list of terms
get_term_from_args(args): RECURSIVE term =
    IF null?(args) THEN unit
    ELSIF length(args) = 1 THEN car(args)
    ELSE pair(car(args), get_term_from_args(cdr(args)))
    ENDIF
MEASURE args BY << 

get_ac_from_args(sym)(args): term = ac_app(sym, get_term_from_args(args))

simple_term?(f, t): bool = 
   cons(t, null) = get_args(f)(t)

simple_args?(f, args): RECURSIVE bool =
    IF null?(args) THEN TRUE
    ELSE LET t = car(args) IN
         simple_term?(f, t) AND simple_args?(f, cdr(args))
    ENDIF
MEASURE args BY << 

%%%%%%%%%%%%%%%
size_ge1: LEMMA
    size(t) >= 1
    
% num_arg
num_arg_ge1: LEMMA
    num_arg(f, t) > 0 

num_arg_ge1_type_t: LEMMA
    num_arg(f, t) > 1 IMPLIES (pair?(t) OR is_ac_sym?(t, f))

% select
select_num_arg: LEMMA
    num_arg(f, select(f, t)(i)) = 1

select_le1: LEMMA
    n <= 1 IMPLIES select(f, t)(n) = select(f, t)(1)

select_ge_num_arg: LEMMA
    LET n = num_arg(f, t) IN 
    i >= n IMPLIES select(f, t)(i) = select(f, t)(n) 

select_size: LEMMA
    size(select(f, t)(n)) <= size(t) 

ac_select_size: LEMMA
    is_ac_sym?(t, f) IMPLIES size(select(f, t)(n)) < size(t) 

% delete
delete_size: LEMMA
    size(delete(f, t)(n)) <= size(t)

num_arg_delete: LEMMA
    num_arg(f, delete(f, t)(n)) <= num_arg(f, t)

num_arg_delete_ge1: LEMMA
    num_arg(f, t) > 1 IMPLIES num_arg(f, delete(f, t)(n)) = num_arg(f, t) - 1
    
num_arg_delete_size: LEMMA
    num_arg(f, t) > 1 IMPLIES size(delete(f, t)(n)) < size(t) 

num_arg1_delete: LEMMA
    num_arg(f, t) = 1 IMPLIES delete(f, t)(n) = unit

delete_num_arg: LEMMA 
    is_ac_sym?(t, f) AND delete(f, t)(n) = unit IMPLIES num_arg(f, t) = 1

ac_delete_size: LEMMA
    ac_app?(t) IMPLIES size(delete(f, t)(n)) < size(t) 

delete_le1: LEMMA
    n <= 1 IMPLIES delete(f, t)(n) = delete(f, t)(1) 

delete_ge_num_arg: LEMMA
    LET n = num_arg(f, t) IN 
    i >= n IMPLIES delete(f, t)(i) = delete(f, t)(n) 

delete_ac_num_arg_gt1: LEMMA 
    is_ac_sym?(t, f) AND num_arg(f, t) > 1
    IMPLIES is_ac_sym?(delete(f, t)(n), f)

is_ac_sym?_delete: LEMMA
    is_ac_sym?(t, f) IMPLIES
    is_ac_sym?(delete(f, t)(n), f) = is_ac_sym?(delete(f, t)(i), f) 

num_arg_select_delete: LEMMA
    num_arg(f, t) > 1 IMPLIES
    num_arg(f, t) = num_arg(f, select(f, t)(i)) + num_arg(f, delete(f, t)(i)) 

% eq_ind_term?, gt_ind_term?
eq_ind_term?_correctness: LEMMA
    eq_ind_term?(i, n, f, t) IMPLIES
    select(f, t)(i) = select(f, t)(n) AND delete(f, t)(i) = delete(f, t)(n) 

gt_ind_term?_select_delete: LEMMA
    gt_ind_term?(i, n, f, t) IMPLIES
    select(f, delete(f, t)(i))(n) = select(f, t)(n) 

gt_ind_term?_select_delete_pred: LEMMA
    gt_ind_term?(i, n, f, t) IMPLIES
    select(f, delete(f, t)(n))(predecessor(i, num_arg(f, t))) = select(f, t)(i)

gt_ind_term?_delete_delete_pred: LEMMA 
    gt_ind_term?(i, n, f, t) IMPLIES
    delete(f, delete(f, t)(n))(predecessor(i, num_arg(f, t))) =
    delete(f, delete(f, t)(i))(n)

not_gt_ind_term?_select_delete_suc: CONJECTURE
    NOT gt_ind_term?(i, n, f, t) AND num_arg(f, t) > 1 IMPLIES 
    select(f, delete(f, t)(i))(n) = select(f, t)(successor(n))

% TODO: maybe I won't need it 
lt_ind_term?_select_delete: LEMMA
    lt_ind_term?(i, n, f, t) IMPLIES
    select(f, delete(f, t)(i))(n) = select(f, t)(n+1)

% get args
get_args_len: LEMMA
    length(get_args(f)(t)) = num_arg(f, t) 

get_args_ac: LEMMA
    get_args(f)(ac_app(f, t)) = get_args(f)(t)

get_args_pair: LEMMA
    get_args(f)(pair(t, s)) = append(get_args(f)(t), get_args(f)(s))

% TODO: Am i using this?
% TODO: I think not, check later
get_ac_from_args_cor: CONJECTURE
    simple_args?(f, args) AND NOT null?(args) IMPLIES 
    get_args(f)(get_ac_from_args(f)(args)) = args


END term_properties
