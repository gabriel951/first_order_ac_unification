%
% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: unification_alg.pvs
% Description: Definition of the first order unification algorithm 

% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

unification_alg: THEORY
BEGIN
	IMPORTING apply_ac_step, list_theory[sub], termination_alg,
	          map_theory[[unif_prb, sub, finite_set[variable]], sub]

X: VAR variable
t, s: VAR term
sigma, sigma1, delta, gamma: VAR sub
vars2avoid: VAR finite_set[variable]
unif_prb: VAR unif_prb
unif_prb1: VAR unif_prb
id: VAR sub

nice_input: TYPE = {input: [unif_prb, sub, finite_set[variable]] | nice_input?(input)}
input: VAR nice_input

% the AC-unification algorithm 
unify(input): RECURSIVE list[sub] =
  LET (unif_prb, sigma, vars2avoid) = input IN 
  IF null?(unif_prb) THEN cons(sigma, null)
  ELSE LET
     (unif_pair, unif_prb1) = choose_unif_pair(unif_prb), 
     (t, s) = unif_pair IN 
     IF var?(s) AND (NOT member(V(s), vars(t))) THEN LET
     	sigma1 = cons((V(s), t), null), 
	new_sigma = append(sigma1, sigma), 
	new_unif_prb = apply_sub(sigma1, unif_prb1) IN
	unify(new_unif_prb, new_sigma, vars2avoid) 

     ELSE CASES t OF
        const(a):
	  IF s = const(a) THEN unify(unif_prb1, sigma, vars2avoid)
	  ELSE null
	  ENDIF,

	variable(X):
	  IF (NOT member(X, vars(s))) THEN LET
	    sigma1 = cons((X, s), null), 
	    new_sigma = append(sigma1, sigma), 
	    new_unif_prb = apply_sub(sigma1, unif_prb1) IN
	    unify(new_unif_prb, new_sigma, vars2avoid)
	  ELSIF s = variable(X) THEN unify(unif_prb1, sigma, vars2avoid) 
	  ELSE null
	  ENDIF,

	unit:
	  IF s = unit THEN unify(unif_prb1, sigma, vars2avoid)  
	  ELSE null 
	  ENDIF,

	app(f, arg):
	  IF NOT app?(s) OR f /= f_sym(s) OR decompose(arg, arg(s))`2 THEN null 
	  ELSE LET dec_unif_prb = decompose(arg, arg(s))`1,
	       	   new_unif_prb = append(dec_unif_prb, unif_prb1) IN
		   unify(new_unif_prb, sigma, vars2avoid)
	  ENDIF,

	ac_app(f, ac_arg):
	  IF NOT ac_app?(s) OR f /= ac_sym(s) THEN null
	  ELSE LET
	     input_lst = apply_ac_step(unif_prb, null, sigma, vars2avoid), 
	     lst_results = map(unify)(input_lst) IN 
	     flatten(lst_results) 
	  ENDIF
        ENDCASES
    ENDIF
  ENDIF
MEASURE lex4(card(vars_not_ac(input`1)), card(vars_under2more(input`1)),
	card(admissible_subterms(input`1)), size(input`1))


%%%%%%%%%%%% LEMMAS
% Theorem of Correctness
unify_subs: CONJECTURE     
   LET (unif_prb, sigma, vars2avoid) = input IN 
   member(delta, unify(unif_prb, sigma, vars2avoid)) IMPLIES
   EXISTS sigma1:
      delta = append(sigma1, sigma)

unify_subs1: CONJECTURE   
   LET (unif_prb, sigma, vars2avoid) = input IN 
   member(delta, unify(unif_prb, sigma, vars2avoid)) IMPLIES
   EXISTS sigma1:
      delta = append(sigma1, sigma)

unify_alg_correct: CONJECTURE 
    LET (unif_prb, sigma, vars2avoid) = input IN 
    member(delta, unify(unif_prb, sigma, vars2avoid))
    IMPLIES unifies?(delta, unif_prb)

unify_correct: CONJECTURE 
    member(delta, unify(unif_prb, sigma, vars2avoid)) AND nice_input?(unif_prb, sigma, vars2avoid) 
    IMPLIES unifies?(delta, unif_prb)

unify_correct1: CONJECTURE 
    member(delta, unify(unif_prb, sigma, vars2avoid)) AND nice_input?(unif_prb, sigma, vars2avoid) 
    IMPLIES unifies?(delta, unif_prb)

unify_alg_correct_cor: LEMMA
    member(delta, unify(cons((t, s), null), null, vars(t, s))) 
    IMPLIES unifies?(delta, (t, s))

% Theorem of Completeness
unify_alg_complete: CONJECTURE
    nice_input?(unif_prb, sigma, vars2avoid) AND 
    more_general?(sigma, delta) AND subset?(dom(delta), vars2avoid)
    AND unifies?(delta, unif_prb) AND well_formed?(unif_prb) IMPLIES 
    EXISTS gamma:
       member(gamma, unify(unif_prb, sigma, vars2avoid)) AND 
       more_general?(gamma, delta, vars2avoid)

END unification_alg 
