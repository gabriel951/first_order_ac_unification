% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: diophantine.pvs
% Description: functions related to solving diophantine equations
%%%%%%%%%%%%%%%%%%%%%%%

diophantine: THEORY
BEGIN
	IMPORTING list_theory[nat], list_theory[posnat], list_theory[list[nat]], min_nat[posnat]

% a diophantine matrix is a list of list of naturals
Dio_matrix: TYPE = list[list[nat]]
dio_matrix: VAR Dio_matrix
lst_dio_matrix: VAR list[Dio_matrix]

% the variables mult_t are used to indicate the multiplicity of the term t. They are a vector [a1, ..., an]
mult_t, mult_t1, mult_t2: VAR list[posnat]

value_lst: VAR list[nat]

a1, a2: VAR posnat

X1, n, n1, n2, k, new_k, bound, value: VAR nat


% defines least common multiple
lcm(a1, a2): posnat = min({k: posnat | divides(a1, k) AND divides(a2, k)})

% defines the maximum of possible pairs lcm(a_i, b_j)
max_lcm(mult_t1, mult_t2): nat =
    IF null?(mult_t1) OR null?(mult_t2) THEN 0
    ELSE LET lcm_seq = map(lcm, cartesian_product(mult_t1, mult_t2)) IN 
             select_greater[nat](lcm_seq, 0)
    ENDIF
    
% calculate the upper bound of solutions, where we can stop
calculate_upper_bound(mult_t1, mult_t2): nat =
    max(length(mult_t1), length(mult_t2)) * max_lcm(mult_t1, mult_t2)

% receives a value k, a coef "a1" and a list [x1, ..., xn]
% if k >= a1 * x_i, put y_i = k-ai*xi
% if k < a1 * x_i, put y_i in the ith entry
% returns [y1, ..., yn]
get_new_value_lst(k, a1, value_lst): RECURSIVE list[nat] =
    IF null?(value_lst) THEN null
    ELSE LET y = k - a1 * car(value_lst) IN
    	 IF y > 0 THEN cons(y, get_new_value_lst(k, a1, cdr(value_lst)))
	 ELSE cons(0, get_new_value_lst(k, a1, cdr(value_lst)))
	 ENDIF
    ENDIF
MEASURE value_lst BY <<

% iterates over value_lst and lst_dio_matrix simultaneously
% Let X_i be the value in values_lst in the ith iteration
% Let Dio_i be the value in lst_dio_matrix in the ith iteration
% Put X_i as the FIRST column of Dio_i. Do that for every i.
get_lst_dio_matrix(value_lst, lst_dio_matrix): RECURSIVE list[Dio_matrix] =
    IF null?(value_lst) OR null?(lst_dio_matrix) THEN null
    ELSE LET X = car(value_lst), dio_matrix = car(lst_dio_matrix),
    	     new_dio_matrix = put_in_head[nat](dio_matrix, X)
    	     IN cons(new_dio_matrix, get_lst_dio_matrix(cdr(value_lst), cdr(lst_dio_matrix)))
    ENDIF
MEASURE value_lst BY <<

% receives mult_t = [a1, ..., an] and a value k
% returns a Dio_matrix whose lines are vectors [X1, ..., Xn] such that
% a1*X1 + ... + an*Xn = k
find_vectors(mult_t)(k): RECURSIVE Dio_matrix =
    IF null?(mult_t) THEN null
    ELSIF length(mult_t) = 1 THEN LET a1 = car(mult_t) IN 
    	 IF divides(a1, k) THEN
	    LET X1 = k/a1,
	    	line1 = cons(X1, null)
	    	IN cons(line1, null)
	 ELSE (::) 
	 ENDIF
    ELSE LET
    	 a1 = car(mult_t),
	 % list all possible values for X1: [0, 1, ..., floor(k/a1)]
	 X1_values = from_min2max[nat](0, floor(k/a1)),
	 % new_k_lst is a list of new_k = (k - a1*X1) for every value of X1
	 new_k_lst = get_new_value_lst(k, a1, X1_values),
	 % apply find_vectors recursively to solve a2*X2 + ... + an*Xn = new_k
	 % for every new_k in new_k_lst
	 lst_smaller_dio_matrix = map(find_vectors(cdr(mult_t)), new_k_lst),
	 % to every value of X1 in X1_values corresponds a smaller diophantine matrix
	 % in lst_smaller_dio_matrix.
	 % Obtain list of diophantine matrix, where each dio matrix has all solutions of
	 % a1 * X1 + ... + an * Xn = k for a fixed value of X1
	 lst_dio_matrix = get_lst_dio_matrix(X1_values, lst_smaller_dio_matrix),
	 % flatten all solutions of a1*X1 + ... + an*Xn = k in a single
	 % diophantine matix
	 result = flatten(lst_dio_matrix)
	 IN result
    ENDIF
MEASURE mult_t BY << 

% solve diophantine equation with both sides being equal to k
dio_solver_n(mult_t1, mult_t2, k): Dio_matrix =
    LET
	% list all solutions [X1, ..., Xn] such that a1*X1 + ... + an*Xn = k
	vector_lst1 = find_vectors(mult_t1)(k),
	% list all solutions [Y1, ..., Ym] such that b1*Y1 + ... + bm*Ym = k
    	vector_lst2 = find_vectors(mult_t2)(k),
	% combine every solution in vector_lst1 with every solution in vector_lst2
	all_combinations = cartesian_product[list[nat]](vector_lst1, vector_lst2),
	% when we apply append_pair to one particular combination in all_combinations
	% we obtain a row of the diophatine matrix
	dio_matrix = map(append_pair, all_combinations)
    IN  dio_matrix

% solve diophatine equation a1*X1 + ... + an*Xn = b1*Y1 + ... + bm*Ym
% until upper bound 
% this corresponds to function dioph in Fages paper 
dio_solver(mult_t1, mult_t2, bound): RECURSIVE Dio_matrix =
    IF bound = 0 THEN
       LET line_dio_matrix = get_repeat_lst[nat](0, length(mult_t1) + length(mult_t2))
       	   IN cons(line_dio_matrix, null)
    ELSE append(dio_solver_n(mult_t1, mult_t2, bound), dio_solver(mult_t1, mult_t2, bound - 1))
    ENDIF
MEASURE bound  

END diophantine
