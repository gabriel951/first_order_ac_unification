%
% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: aux_unification.pvs
% Description: auxiliary functions called in the unification algorithm 

%%%%%%%%%%%%%%%%%%%%%%%

aux_unification: THEORY
BEGIN
	IMPORTING substitution, diophantine

sigma: VAR Sub


% a unification pair (t, s) is composed of terms t and s that must be unified
Unif_pair: TYPE = [Term, Term]

% a unification problem is a list of unification pairs
Unif_prb: TYPE = list[Unif_pair]
unif_prb: VAR Unif_prb

% to one particular ac solution there corresponds a pair of sequence of terms
Ac_sol: TYPE = [list[Term], list[Term]]

sym: VAR string

t1, t2: VAR Term
arg_lst: VAR list[Term]

mult_t1, mult_t2, row: VAR list[nat]
bound: VAR nat

dio_sol_matrix, dio_matrix: VAR Dio_matrix
submatrix_sol_lst, dio_matrix_lst: VAR list[Dio_matrix]

vars2avoid: VAR set[Variable]

ac_sol: VAR Ac_sol
ac_sol_lst: VAR list[Ac_sol]
ac_sol_simp: VAR [Sub, Ac_sol]
ac_sol_simp_lst: VAR list[[Sub, Ac_sol]]

% this corresponds to function elimcom in Fages paper
elim_com_arg(t1, t2, sym): [list[Term], list[nat], list[nat]] =
    LET 
    % get the arguments of t1 and how many times they appear
    (args_t1, coef_t1) = get_args_coef_ac(t1, sym),
    % get the arguments of t2 and how many times they appear
    (args_t2, coef_t2) = get_args_coef_ac(t2, sym),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t1
    (new_args_t1, new_coef_t1) = select_args(args_t1, coef_t1, args_t2, coef_t2),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t2
    (new_args_t2, new_coef_t2) = select_args(args_t2, coef_t2, args_t1, coef_t1)
    IN (append(new_args_t1, new_args_t2), new_coef_t1, new_coef_t2)


% check if column i has at least one coefficient greater than zero
% you must make sure dio_matrix is a matrix and i < num_col_dio_matrix 
non_empty_col?(dio_matrix, i): bool =
    LET col_i = get_col_i(dio_matrix, i, 0) IN 
    	IF count(0, col_i) = length(col_i) THEN FALSE
    	ELSE TRUE
    	ENDIF

% check that if column i corresponds to a non-variable, exactly one coefficient is 1 and the rests are zero
% if column i is not a non-variable, then return true
% you must make sure dio_matrix is a matrix and i < num_col_dio_matrix
non_var_col_exact1?(dio_matrix, i, arg_lst): bool = 
    IF i > length(arg_lst) THEN FALSE
    ELSE LET arg = nth(arg_lst, i-1) IN
    	     IF var?(arg) THEN TRUE
	     ELSE LET col_i = get_col_i(dio_matrix, i, 0) IN
	     	  IF count(1, col_i) = 1 AND count(0, col_i) = length(col_i) - 1 THEN TRUE
		  ELSE FALSE
		  ENDIF
	     ENDIF
    ENDIF 

% test if the columns until i satisfy the nice properties to be a diophantine solution
nice_submatrix?(dio_matrix, arg_lst, i): RECURSIVE bool =
    % dio_matrix must be a matrix with column amount equal to length(arg_lst).
    % if it's not we fail
    IF NOT all_lsts_length?(dio_matrix, length(arg_lst)) OR null?(dio_matrix) THEN FALSE
    ELSIF i > length(arg_lst) THEN nice_submatrix?(dio_matrix, arg_lst, length(arg_lst))
    ELSE IF i = 0 THEN TRUE
    	 ELSE LET
	     bool1 = non_empty_col?(dio_matrix, i),
    	     bool2 = non_var_col_exact1?(dio_matrix, i, arg_lst) IN
	     (bool1 AND bool2 AND nice_submatrix?(dio_matrix, arg_lst, i-1))
	 ENDIF
    ENDIF 
MEASURE i

% receives a list of dio matrix
% returns a list of the ones that satisfy the property of being nice
get_nice_submatrices(dio_matrix_lst, arg_lst): RECURSIVE list[Dio_matrix] =
    IF null?(all_submatrices) THEN null
    ELSE LET dio_matrix = car(dio_matrix_lst) IN
    	 IF nice_submatrix?(dio_matrix, arg_lst, length(arg_lst)) THEN
	    cons(dio_matrix, get_nice_submatrices(dio_matrix_lst))
	 ELSE get_nice_submatrix(cdr(dio_matrix_lst))
	 ENDIF
    ENDIF
MEASURE dio_matrix_lst BY << 


% extract the relevant submatrices. Each submatrix corresponds to one ac-solution
% this corresponds to function partit in Fages article
extract_submatrices(dio_sol_matrix, arg_lst): list[Dio_matrix] =
    % check that the dio_sol_matrix is not only a list of lists but also a matrix
    IF nonmatrix?(dio_sol_matrix) THEN null
    ELSE LET all_submatrices = get_all_sublists(dio_sol_matrix) 
    	     IN get_nice_submatrices(all_submatrices, arg_lst)
    ENDIF
    	   

% this corresponds to function trans in Fages paper
dio_matrix_to_ac_sol(arg_lst, vars2avoid)(dio_matrix): list[Ac_sol] =
    LET
    num_col = length(arg_lst),
    num_lines = length(dio_matrix)
    
    % get the columns and index_of_columns that satisfy constraint 2
    % obs: "lst_ind_col_const2" corresponds to "J" in Fages paper
    lst_col = map(get_col_i(dio_matrix, 0), from_min2max(1, num_col))
    (lst_col_const2, lst_ind_col_const2) = get_col_and_ind_const2(lst_col, const2?) 
    
    % for every line i, get the column indexes that satisfy constraint 2 in this line
    % "col_const2_per_line" corresponds to a list of "phi(i)"
    ind_col_const2_per_line = get_col_ind_cons2_per_line(get_repeat_lst(null, num_lines),
    			  	lst_col_const2, lst_ind_col_const2)
    
    % get a list of the indexes of columns that satisfy constraint 2 in line i minimally
    lst_min_ind_col_cons2 = get_lst_min_ind_col_cons2(lst_ind_)


    
% this corresponds to function "dio" in Fages paper
solve_ac(t1, t2, vars2avoid, sym): list[Ac_sol] =
    LET
%    eliminate common arguments from t1 and t2, obtaining the different arguments on each one
%    and their multiplicity
     (arg_lst, mult_t1, mult_t2) = elim_com_arg(t1, t2, sym),
%    calculate upper bound from which we can solve the diophantine equation
     bound = calculate_upper_bound(mult_t1, mult_t2),
%    solve diophantine equation until the upper bound 
     dio_sol_matrix = dio_solver(mult_t1, mult_t2, bound),
%    extract "nice" submatrices of solutions
     submatrix_sol_lst = extract_submatrices(dio_sol_matrix, arg_lst),
%    for every diophantine submatrix obtain the corresponding unification solution
     ac_sol_lst = null %map(submatrix_sol_lst,)
     IN ac_sol_lst


% this functions corresponds to the homonymous function "elimvar" in Fages paper
elimvar(ac_sol): [Sub, Ac_sol] =
((::), ((::), (::))) 


% apply function elimvar to every ac_sol in ac_sol_lst
% TODO: this can be replaced by a simple "map"
apply_elimvar(ac_sol_lst): RECURSIVE list[[Sub, Ac_sol]] =
    IF null?(ac_sol_lst) THEN (::)
    ELSE LET ac_sol = car(ac_sol_lst),
             ac_sol_simp = elimvar(ac_sol) 
             IN cons(ac_sol_simp, apply_elimvar(cdr(ac_sol_lst)))
    ENDIF
MEASURE ac_sol_lst BY << 


construct_input(ac_sol_simp, unif_prb, sigma, vars2avoid): [Unif_prb, Sub, set[Variable]] =
((::), (::), (::))

% construct a list of inputs that will be passed to unify
construct_input_lst(ac_sol_simp_lst, unif_prb, sigma, vars2avoid): RECURSIVE list[[Unif_prb, Sub, set[Variable]]] =
    IF null?(ac_sol_simp_lst) THEN (::)
    ELSE LET input = construct_input(car(ac_sol_simp_lst), unif_prb, sigma, vars2avoid)
    	     IN cons(input, construct_input_lst(cdr(ac_sol_simp_lst), unif_prb, sigma, vars2avoid))
    ENDIF
MEASURE ac_sol_simp_lst BY << 


END aux_unification 
