("aux_unification" aux_unification instantiate_step_unifies_equiv 0 (instantiate_step_unifies_equiv-1 nil 3851195315 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 "sig") (("" (prop) (("" (name-replace "delta" "instantiate_step(P, null, null)`2") (("" (reveal -1) (("" (expand "instantiate_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "del1" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lemma "instantiate_step2_no_effect") (("1" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("1" (replace -1) (("1" (inst -4 "cdr(P)") (("1" (prop) (("1" (inst -1 "sig") (("1" (assert) (("1" (expand "unifies?" -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "append_null") (("2" (expand "apply_sub" -1 2) (("2" (expand "unifies?" -3) (("2" (assert) (("2" (flatten) (("2" (reveal -1 -2 -3 -4 -5) (("2" (case "equal?(sig, append(sig, del1))") (("1" (lemma "instantiate_step_sub_append") (("1" (inst -1 "null" "del1" "apply_sub(del1, cdr(P))") (("1" (assert) (("1" (hide 1 2) (("1" (replace -6) (("1" (inst -7 "apply_sub(del1, cdr(P))") (("1" (prop) (("1" (inst -1 "sig") (("1" (prop) (("1" (name-replace "del2" "instantiate_step(apply_sub(del1, cdr(P)), null, null)`2") (("1" (case "equal?(append(sig, del1), append(append(sig, del2), del1))") (("1" (rewrite "append_assoc") (("1" (replace -3) (("1" (lemma "equal_sub_trans") (("1" (replace -4 :dir rl) (("1" (inst -1 "sig" "append(sig, del1)" "append(sig, delta)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but (-1 1)) (("2" (lemma "equal_sub_equiv") (("2" (expand "equal?" 1) (("2" (skolem 1 "x") (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (inst -1 "sig" "append(sig, del2)" "subs(del1)(variable(x))") (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_unifies") (("2" (lemma "unifies?_equal") (("2" (inst -1 "sig" "append(sig, del1)" "cdr(P)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5 -7) (("2" (expand "instantiate_step" -3) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sig" "t") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) (("1" (expand "unifies?" -6) (("1" (replace -3) (("1" (replace -4) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sig)(s)" "subs(sig)(t)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sig" "s") (("1" (beta -1) (("1" (replace -2) (("1" (assert) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (expand "unifies?" -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) nil (append def-decl "list[T]" list_props nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (instantiate_step2_no_effect formula-decl nil aux_unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_equal formula-decl nil unification nil) (equal_sub_equiv formula-decl nil substitution nil) (subs_append2 formula-decl nil substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) nil (subs const-decl "term" substitution nil) (append_assoc formula-decl nil list_props nil) (equal_sub_trans formula-decl nil substitution nil) (instantiate_step_sub_append formula-decl nil aux_unification nil) (subs_inst formula-decl nil substitution nil) (term_variable_eta formula-decl nil term_adt nil) (equal?_sym formula-decl nil equality nil) (unifies? const-decl "bool" unification nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step const-decl "[sub, bool, bool]" aux_unification nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append_null formula-decl nil list_props nil) (equal_sub_ref formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak))("aux_unification" aux_unification instantiate_step_unifies_equal 0 (instantiate_step_unifies_equal-1 nil 3851197746 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 "sig") (("" (prop) (("" (name-replace "delta" "instantiate_step(P, null, null)`2") (("" (reveal -1) (("" (expand "instantiate_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "del1" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lemma "instantiate_step2_no_effect") (("1" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("1" (replace -1) (("1" (inst -4 "cdr(P)") (("1" (prop) (("1" (inst -1 "sig") (("1" (assert) (("1" (expand "unifies?" -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "append_null") (("2" (expand "apply_sub" -1 2) (("2" (expand "unifies?" -3) (("2" (assert) (("2" (flatten) (("2" (reveal -1 -2 -3 -4 -5) (("2" (case "equal?(sig, append(sig, del1))") (("1" (lemma "instantiate_step_sub_append") (("1" (inst -1 "null" "del1" "apply_sub(del1, cdr(P))") (("1" (assert) (("1" (hide 1 2) (("1" (replace -6) (("1" (inst -7 "apply_sub(del1, cdr(P))") (("1" (prop) (("1" (inst -1 "sig") (("1" (prop) (("1" (name-replace "del2" "instantiate_step(apply_sub(del1, cdr(P)), null, null)`2") (("1" (case "equal?(append(sig, del1), append(append(sig, del2), del1))") (("1" (rewrite "append_assoc") (("1" (replace -3) (("1" (lemma "equal_sub_trans") (("1" (replace -4 :dir rl) (("1" (inst -1 "sig" "append(sig, del1)" "append(sig, delta)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but (-1 1)) (("2" (lemma "equal_sub_equiv") (("2" (expand "equal?" 1) (("2" (skolem 1 "x") (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (inst -1 "sig" "append(sig, del2)" "subs(del1)(variable(x))") (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_unifies") (("2" (lemma "unifies?_equal") (("2" (inst -1 "sig" "append(sig, del1)" "cdr(P)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5 -7) (("2" (expand "instantiate_step" -3) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sig" "t") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) (("1" (expand "unifies?" -6) (("1" (replace -3) (("1" (replace -4) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sig)(s)" "subs(sig)(t)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sig" "s") (("1" (beta -1) (("1" (replace -2) (("1" (assert) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (expand "unifies?" -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (equal? const-decl "bool" substitution nil) (append def-decl "list[T]" list_props nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (instantiate_step2_no_effect formula-decl nil aux_unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_equal formula-decl nil unification nil) (equal_sub_equiv formula-decl nil substitution nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subs_append2 formula-decl nil substitution nil) (subs def-decl "term" substitution nil) (subs const-decl "term" substitution nil) (append_assoc formula-decl nil list_props nil) (equal_sub_trans formula-decl nil substitution nil) (instantiate_step_sub_append formula-decl nil aux_unification nil) (subs_inst formula-decl nil substitution nil) (term_variable_eta formula-decl nil term_adt nil) (equal?_sym formula-decl nil equality nil) (unifies? const-decl "bool" unification nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step const-decl "[sub, bool, bool]" aux_unification nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append_null formula-decl nil list_props nil) (equal_sub_ref formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil))("apply_ac_step" apply_ac_step apply_ac_step_complete1 0 (apply_ac_step_complete1-1 nil 3851201713 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("delta" "Ps" "sigma" "V")) (("" (flatten) (("" (hide -1) (("" (case "null?(Pu)") (("1" (inst 1 "(Ps, sigma, V)" "null") (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "well_formed?" 1) (("4" (skeep) (("4" (expand "subs" 1) (("4" (expand "subs" 1) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "img_null") (("5" (grind) nil nil)) nil) ("6" (expand "append" 1) (("6" (propax) nil nil)) nil)) nil)) nil) ("2" (name-replace "u_pair" "car(Pu)") (("1" (name-replace "t" "u_pair`1") (("1" (name-replace "s" "u_pair`2") (("1" (case "equal?(t, s)") (("1" (reveal -1) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "Ps" "sigma") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "ac_sol" "gamma") (("1" (assert) (("1" (delete -6) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (expand "unifies?" -5) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "all_ac_prb?") (("3" (skeep) (("3" (inst -7 "unif_pair") (("3" (assert) (("3" (expand "member" 3) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "nice_input_cdr") (("4" (hide 3) (("4" (inst -1 "sigma" "append(Pu, Ps)" "V") (("4" (expand "append" -1 1) (("4" (expand "append" -1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sigma, V1)") (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9) (("1" (lemma "solve_ac_unify_complete") (("1" (inst -1 "delta" "f" "s" "t" "lst_V") (("1" (assert) (("1" (prop) (("1" (skolem -1 ("P_C" "lambda1" "V2")) (("1" (flatten) (("1" (hide -3 -4 -5 -9 -10 -11 -8) (("1" (hide -3) (("1" (name-replace "i_step_output" "instantiate_step(P_C, null, null)") (("1" (name-replace "P_CI" "i_step_output`1") (("1" (name-replace "lambda2" "i_step_output`2") (("1" (expand "more_general?" -7) (("1" (skolem -7 "delta1") (("1" (lemma "unifies?_equal") (("1" (inst -1 "delta" "append(delta1, sigma)" "append(Pu, Ps)") (("1" (assert) (("1" (hide -7) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "P_C") (("1" (case "equal?(append(lambda1, delta), append(append(lambda1, delta1), sigma))") (("1" (assert) (("1" (hide -1 -8) (("1" (lemma "unifies?_append_disjoint") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step_unifies_sub") (("1" (inst -1 "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (replace -6) (("1" (replace -4) (("1" (assert) (("1" (prop) (("1" (reveal -26) (("1" (inst -1 "apply_sub(lambda2, cdr(Pu))") (("1" (prop) (("1" (inst -1 "append(lambda1, delta)" "append(P_CI, apply_sub(lambda2, Ps))" "append(lambda2, sigma)" "V1") (("1" (prop) (("1" (skolem -1 ("ac_sol" "gamma")) (("1" (flatten) (("1" (inst 2 "ac_sol" "append(gamma, lambda1)") (("1" (prop) (("1" (delete -6) (("1" (reveal -18 -19 -20 -21 -22 -23 -24 -25 -26) (("1" (reveal -9) (("1" (expand "apply_ac_step" 1) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but (-1 -10 -11 2)) (("1" (reveal 3) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (replace -10) (("2" (replace -9) (("2" (replace -8) (("2" (replace -7) (("2" (replace -6) (("2" (replace -5) (("2" (split 1) (("1" (flatten) (("1" (hide -10 -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (lemma "instantiate_step_lst_mem") (("1" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil) ("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (reveal -26) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2 1) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ac_results" 1) (("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (hide -12 -13 -14 -15 -16 -17 -18 -19 -21) (("2" (use "input_apply_ac_step_mem2") (("2" (assert) (("2" (hide 2) (("2" (inst 1 "P_CI" "lambda2") (("2" (reveal -9 -10) (("2" (hide -13 -16 -9 -10) (("2" (lemma "instantiate_step_lst_mem") (("2" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -30) (("1" (expand "nice_input?" -1) (("1" (flatten) (("1" (hide -6) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2) (("3" (expand "member" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ac_results" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc") nil nil) ("3" (delete -6) (("3" (hide -1 -2 -6 -7 -8 -9 -10 -11 -13) (("3" (reveal -19) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (case "subset?(V1, ac_sol`3)") (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "difference" 1) (("1" (expand "member" -5) (("1" (expand "difference" -5) (("1" (flatten) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand ("member" "difference") -3) (("2" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 2) (("1" (rewrite "vars_lst_lst_vars") (("1" (inst 2 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 2 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1 2 3) (("2" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (hide -3) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -3) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (assert) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -4) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (flatten) (("1" (inst -4 "y") (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t2") (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (lemma "instantiate_step1_mem") (("2" (inst -1 "t1" "P_C") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (reveal -9) (("2" (expand "i_step_output" -1) (("2" (replace -1) (("2" (replace -3) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (expand "subset?" -8) (("1" (inst -8 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 2) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skolem 1 "z") (("3" (prop) (("3" (rewrite "mem_list2set" :dir rl) (("3" (expand "lst_V" 1) (("3" (rewrite "finset2list_mem") (("3" (expand "cur_V" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "vars" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "t" -1) (("3" (expand "s" -1) (("3" (expand "u_pair" -1) (("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -11) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -3) (("2" (inst -3 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "contained?" 1) (("2" (expand "lambda2" 1) (("2" (expand "i_step_output" 1) (("2" (case "subset?(vars(P_C), V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "member" 2 1) (("1" (expand "vars" 2 1) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (expand "subset?" -2) (("2" (flatten) (("2" (inst -3 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (hide -2 -4 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil) ("5" (delete -6) (("5" (expand "subset?" 1) (("5" (skeep) (("5" (hide -2 -7 -8 -9) (("5" (use "vars_img_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -17) (("2" (hide -3 -4 -5 -7) (("2" (case "subset?(V1, ac_sol`3)") (("1" (expand "V1" -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "vars_lst_lst_vars" 1) (("1" (inst 1 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1) (("2" (hide -8 2 3 -1 -2) (("2" (reveal -28) (("2" (case "subset?(vars(P_C), V1)") (("1" (case "subset?(V, V1)") (("1" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -8) (("2" (flatten) (("2" (hide -13) (("2" (expand "subset?" -11) (("2" (inst -11 "y") (("2" (rewrite "vars_unif_prb" -11) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (inst 3 "t2") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (assert) (("2" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (replace -12) (("2" (replace -10) (("2" (replace -2 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -6) (("1" (flatten) (("1" (expand "subset?" -7) (("1" (inst -7 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -3) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (hide -11) (("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5 1 :dir rl) (("2" (expand "i_step_output" 1) (("2" (expand "contained?" 1) (("2" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" -4) (("1" (inst -4 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1") (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "unifies?_append") (("2" (case "disjoint?(dom(sigma), vars(img(lambda2)))") (("1" (prop) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "apply_sub(lambda2, cdr(Pu))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc" 1 :dir rl) (("2" (hide -9 2 -5 -6 -7) (("2" (lemma "unifies?_append_disjoint3") (("2" (inst -1 "sigma" "append(lambda1, delta1)" "apply_sub(lambda2, cdr(Pu))") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2 -2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "cdr(Pu)") (("1" (assert) (("1" (prop) (("1" (expand "append" -3 2) (("1" (expand "unifies?" -3) (("1" (flatten) (("1" (rewrite "unifies?_append" -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 1 "t1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_append") (("2" (prop) (("1" (rewrite "unifies?_equiv") (("1" (skolem 1 "up") (("1" (prop) (("1" (expand "P_CI" -1) (("1" (expand "i_step_output" -1) (("1" (lemma "instantiate_step1_mem_unif_pair") (("1" (inst -1 "null" "up" "P_C") (("1" (assert) (("1" (assert) (("1" (skolem -1 "up1") (("1" (rewrite "append_null") (("1" (prop) (("1" (replace -10) (("1" (replace -8) (("1" (replace -2) (("1" (hide -7) (("1" (case "unifies?(append(lambda1, delta), apply_sub(lambda2, cons(up1, null)))") (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-11 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (use "unifies?_append_disjoint3") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (expand "unifies?" 1) (("1" (expand "unifies?" 1 2) (("1" (rewrite "unifies?_equiv" -6) (("1" (inst -6 "up1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x" "P_C") (("2" (reveal -28) (("2" (prop) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (hide -7) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide-all-but (-1 1 3)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil) ("4" (rewrite "vars_unif_prb") (("4" (inst 1 "t2") (("4" (assert) (("4" (rewrite "member_unif_prb_equiv") (("4" (inst 1 "up1") (("4" (assert) (("4" (expand "member" -4) (("4" (expand "member" -4) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -9) (("2" (lemma "unifies?_append_disjoint3") (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (inst -1 "sigma" "append(lambda1, delta1)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "Ps") (("1" (assert) (("1" (prop) (("1" (hide -1) (("1" (rewrite "unifies?_append" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -21) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (flatten) (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -3 "t3") (("2" (prop) (("2" (replace -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "disjoint?" -3) (("2" (expand "empty?" -3) (("2" (inst -3 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t3") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -8) (("2" (reveal -19) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "lambda2" -3) (("2" (expand "i_step_output" -3) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (lemma "solve_ac_vars") (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (assert) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (hide -8) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (1 -1)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (use "apply_sub_all_ac") (("3" (assert) (("3" (reveal -14) (("3" (expand "all_ac_prb?" -1) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "up") (("3" (flatten) (("3" (inst -1 "up") (("3" (assert) (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (reveal -15) (("5" (lemma "next_input_nice_input") (("5" (inst -1 "(Pu, Ps, sigma, V)" "_") (("5" (inst -1 "(apply_sub(lambda2, cdr(Pu)), append(P_CI, apply_sub(lambda2, Ps)), append(lambda2, sigma), V1)") (("5" (assert) (("5" (hide 2) (("5" (hide -1 -2 -3 -4 -8 -9) (("5" (reveal -16 -25 -26 -26 -28 -29 -30 -31 -32 -33) (("5" (expand "next_input?" 1) (("5" (replace -1) (("5" (replace -8) (("5" (replace -9) (("5" (replace -7) (("5" (replace -6) (("5" (replace -5) (("5" (replace -4) (("5" (replace -3) (("5" (reveal 3) (("5" (assert) (("5" (use "input_apply_ac_step_mem2") (("5" (assert) (("5" (hide 3) (("5" (inst 1 "P_CI" "lambda2") (("5" (expand "V1" 1) (("5" (expand "ac_results_subs" 1) (("5" (lemma "instantiate_step_lst_mem") (("5" (reveal -3) (("5" (inst?) (("5" (inst -2 "ac_results") (("5" (assert) (("5" (replace -14 :dir rl) (("5" (replace -12) (("5" (replace -13) (("5" (assert) (("5" (replace -5 1 :dir rl) (("5" (reveal -7) (("5" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -27) (("1" (hide -5 -6 -7 -8 -9 -10) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb" -5) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2 1) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb" -5) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 2) (("3" (prop) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 3 -4 -5 -6) (("6" (reveal -22 -16 -17) (("6" (expand "contained?" 1) (("6" (case "subset?(V, V1)") (("1" (case "subset?(V2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand ("member" "difference") -5) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "vars_lst_lst_vars") (("2" (inst 1 "V2") (("2" (assert) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -6 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lemma "more_general_equal") (("7" (inst -1 "append(lambda2, sigma)" "append(lambda1, delta)" "append(lambda1, append(delta1, sigma))") (("7" (hide 3) (("7" (assert) (("7" (split -1) (("1" (rewrite "append_assoc") (("1" (rewrite "append_assoc" :dir rl) (("1" (hide 2) (("1" (use "more_general_append") (("1" (assert) (("1" (hide 2) (("1" (expand "more_general?" 1) (("1" (inst 1 "append(lambda1, delta1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skolem 1 "x") (("2" (inst -1 "x") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (use "subs_equal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1 :dir rl) (("2" (use "instantiate_step_unifies_not_fail") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (reveal -17) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb") (("3" (hide -6) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append") (("3" (flatten) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "solve_ac_vars") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (flatten) (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (reveal -13) (("2" (hide -7 -8 -5 -6) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (expand "u_pair" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skeep) (("2" (inst -1 "X") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_equal?") (("2" (inst -1 "_" "lambda1" "_") (("2" (inst?) (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -2) (("2" (expand "unifies?" -2) (("2" (prop) (("2" (reveal -9 -10) (("2" (assert) (("2" (replace -3) (("2" (replace -1 1 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -6) (("3" (expand "all_ac_prb?" -4) (("3" (expand "t") (("3" (inst -4 "u_pair") (("3" (expand "member" -4) (("3" (expand "ac_prb?" -4) (("3" (flatten) (("3" (expand "is_ac_sym?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (expand "all_ac_prb?" -4) (("4" (inst -4 "u_pair") (("4" (expand "member" -4) (("4" (expand "ac_prb?" -4) (("4" (flatten) (("4" (expand "s" 1) (("4" (expand "is_ac_sym?" 1) (("4" (assert) (("4" (expand "t" -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal 1) (("5" (propax) nil nil)) nil) ("6" (hide 3) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (expand "contained?" -7) (("6" (flatten) (("6" (expand "subset?" -7) (("6" (inst -7 "x") (("6" (assert) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "lst_V") (("6" (rewrite "finset2list_mem") (("6" (expand "cur_V") (("6" (expand ("member" "union") 1) (("6" (expand "member" 1 2) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (expand "subset?" 1) (("7" (skeep) (("7" (expand "contained?" -7) (("7" (flatten) (("7" (expand "subset?" -8) (("7" (inst -8 "x") (("7" (assert) (("7" (rewrite "mem_list2set" :dir rl) (("7" (expand "lst_V") (("7" (rewrite "finset2list_mem") (("7" (expand "cur_V" 1) (("7" (expand ("member" "union") 1) (("7" (expand "member" 1 2) (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 3) (("8" (expand "subset?" 1) (("8" (skeep) (("8" (rewrite "mem_list2set" :dir rl) (("8" (expand "lst_V" 1) (("8" (rewrite "finset2list_mem") (("8" (expand "cur_V" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand "vars" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand ("t" "s")) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 3) (("9" (expand "nice_input?" -5) (("9" (flatten) (("9" (hide -10) (("9" (rewrite "well_formed_unif_prb") (("9" (skolem 1 "t1") (("9" (prop) (("9" (rewrite "well_formed_unif_prb") (("9" (inst -10 "t1") (("9" (assert) (("9" (expand "append" 3) (("9" (expand "member" 3) (("9" (expand "member" -1) (("9" (split -1) (("1" (split) (("1" (assert) (("1" (expand "t" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "s" -1) (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" -7) (("2" (inst -7 "u_pair") (("2" (expand "member" -7) (("2" (assert) (("2" (expand "ac_prb?" -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (all_ac_prb? const-decl "bool" unification nil) (well_formed? const-decl "bool" substitution nil) (nice_input? const-decl "bool" apply_ac_step nil) (contained? const-decl "bool" substitution nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (subset? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (difference const-decl "set" sets nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (subs const-decl "term" substitution nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (img_null formula-decl nil substitution nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nice_input_cdr formula-decl nil apply_ac_step nil) (union const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (solve_ac_unify_complete formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (ac_prb? const-decl "bool" unification nil) (unifies? const-decl "bool" unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (unifies?_append_disjoint formula-decl nil unification nil) (instantiate_step_unifies_not_fail formula-decl nil aux_unification nil) (well_formed_unif_prb formula-decl nil unification nil) (first_proj_mem formula-decl nil list_theory2 nil) (solve_ac_well_formed formula-decl nil aux_unification nil) (instantiate_step_lst_mem formula-decl nil aux_unification nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (append_assoc formula-decl nil list_props nil) (finset2list_mem formula-decl nil list_theory nil) (mem_list2set formula-decl nil list_theory nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (sec_proj_mem formula-decl nil list_theory2 nil) (dom_append formula-decl nil substitution nil) (apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (member_unif_prb_append formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (vars_unif_prb formula-decl nil unification nil) (well_formed_append formula-decl nil substitution nil) (vars_img_append formula-decl nil substitution nil) (unifies?_append formula-decl nil unification nil) (subs_append2 formula-decl nil substitution nil) (subs_equal? formula-decl nil substitution nil) (equal?_sym formula-decl nil equality nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_append_disjoint4 formula-decl nil unification nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (unifies?_append_disjoint3 formula-decl nil unification nil) (instantiate_step1_mem_unif_pair formula-decl nil aux_unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (solve_ac_vars formula-decl nil aux_unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_null formula-decl nil list_props nil) (unifies?_equiv formula-decl nil unification nil) (disjoint? const-decl "bool" sets nil) (apply_sub_all_ac formula-decl nil unification nil) (next_input? const-decl "bool" apply_ac_step nil) (next_input_nice_input formula-decl nil apply_ac_step nil) (list2set def-decl "set[T]" list2set nil) (more_general_append formula-decl nil substitution nil) (more_general_equal formula-decl nil substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step_unifies_sub formula-decl nil aux_unification nil) (unifies?_equal formula-decl nil unification nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak))("termination_alg" termination_alg simp_vars_not_ac 0 (simp_vars_not_ac-1 nil 3837336733 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((vars_not_ac const-decl "finite_set[variable]" termination_alg nil) (union const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil)) shostak))("termination_alg" termination_alg simp_vars_not_ac_car 0 (simp_vars_not_ac_car-1 nil 3837336813 ("" (skeep) (("" (lemma "simp_vars_not_ac") (("" (inst?) (("" (lemma "card_subset[variable]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_vars_not_ac formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("termination_alg" termination_alg simp_vars_under2more_subset 0 (simp_vars_under2more_subset-1 nil 3837337207 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (expand "vars_under2more" -1) (("" (expand "member" -1 1) (("" (skolem -1 ("t" "s")) (("" (flatten) (("" (rewrite "subterms_mem_unif_prb") (("" (skolem -4 "tS") (("" (prop) (("" (rewrite "subterms_mem_unif_prb") (("" (skolem -6 "sS") (("" (prop) (("" (expand "member" 1) (("" (expand "vars_under2more" 1) (("" (inst 1 "t" "s") (("" (assert) (("" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "tS") (("1" (assert) (("1" (lemma "simplify_mem") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "simplify_mem") (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "sS") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (subterms_mem_unif_prb formula-decl nil unification nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (member const-decl "bool" sets nil)) shostak))("termination_alg" termination_alg simp_vars_under2more 0 (simp_vars_under2more-1 nil 3837337671 ("" (skeep) (("" (lemma "simp_vars_under2more_subset") (("" (inst?) (("" (lemma "card_subset[variable]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_vars_under2more_subset formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("termination_alg" termination_alg simp_adm_subterms_subset 0 (simp_adm_subterms_subset-1 nil 3837337830 ("" (skeep) (("" (expand "subset?" 1) (("" (skolem 1 "t") (("" (prop) (("" (expand "admissible_subterms") (("" (expand "member" -1 1) (("" (skolem -1 "tS") (("" (prop) (("" (expand "member" 1 1) (("" (inst 1 "tS") (("" (prop) (("" (lemma "simplify_mem") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil)) shostak))("termination_alg" termination_alg simp_adm_subterms 0 (simp_adm_subterms-1 nil 3837338021 ("" (skeep) (("" (lemma "simp_adm_subterms_subset") (("" (inst?) (("" (lemma "card_subset[term]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_adm_subterms_subset formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))