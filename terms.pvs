% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: Terms.pvs
% Description: Definition of a first order term and properties related to them

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% definition of a term
term[constant:TYPE, variable:TYPE+, f_symbol:TYPE, ac_symbol:TYPE]: DATATYPE
    BEGIN
	const (a: constant): const?
	variable (V: variable): var?
	unit: unit?
	pair (term1: term, term2: term): pair?
	app (f_sym: f_symbol, arg: term): app?
	ac_app (ac_sym: ac_symbol, ac_arg: term): ac_app? 
    END term


%%%%%%%%%%%%%%%%%%%%%%%%%%
term_properties: THEORY
BEGIN

% definition of variable, constant and syntactic and AC function symbols 
variable: TYPE = nat
constant: TYPE = nat
f_symbol: TYPE = string
ac_symbol: TYPE = string

IMPORTING basic_notions,
	  term[constant, variable, f_symbol, ac_symbol],
	  list_theory[term]

sym, f: VAR string
n, i, j: VAR nat

t, s: VAR term

args: TYPE = list[term]
args: VAR args

% the size of a term 
size(t): RECURSIVE nat =
    CASES t OF
        const(a): 1,
	variable(X): 1, 
	unit: 1, 
	pair(t1, t2): 1 + size(term1(t)) + size(term2(t)),
	app(sym, arg): 1  + size(arg),
	ac_app(sym, arg): 1  + size(arg)
    ENDCASES
MEASURE t BY << 

% test if t is an AC function symbol headed by sym
is_ac_sym?(t, sym): bool = ac_app?(t) AND sym = ac_sym(t)

% test if t and s are AC function symbols headed by "sym"
are_ac?(t, s, sym): bool = ac_app?(t) AND ac_app?(s) AND sym = ac_sym(t) AND sym = ac_sym(s) 

% get the number of arguments of a term "t"
% if it encounters an ac function whose root is "sym" it goes inside the function
num_arg(sym, t): RECURSIVE nat =
    IF pair?(t) THEN num_arg(sym, term1(t)) + num_arg(sym, term2(t))
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN num_arg(sym, ac_arg(t))
    ELSE 1
    ENDIF
MEASURE t BY << 

% i = j in a sense described by the lemma of correctness of this function 
eq_ind_term?(i, j, sym, t): bool =
   LET n = num_arg(sym, t) IN
   (i = j) OR (i = 0 AND j = 1) OR (i = 1 AND j = 0) OR (i >= n AND j >= n) 

% i > j in the sense of eq_ind_term?
gt_ind_term?(i, j, sym, t): bool =
   NOT eq_ind_term?(i, j, sym, t) AND i > j 

% i < j, in the sense of lt_ind_term?
lt_ind_term?(i, j, sym, t): bool = 
   NOT eq_ind_term?(i, j, sym, t) AND i < j

% select the nth (index start at one) argument of an a term.
% if it encounters an ac function whose root is "sym" it goes inside the function
select(sym, t)(n): RECURSIVE term =
    IF pair?(t) THEN
        LET n1 = num_arg(sym, term1(t)) IN
        IF n <= n1 THEN select(sym, term1(t))(n)
        ELSE select(sym, term2(t))(n-n1)
        ENDIF
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN select(sym, ac_arg(t))(n)
    ELSE t
    ENDIF 
MEASURE t BY <<

% delete the nth (index start at one) argument of a term
% if it encounters an ac function whose root is "sym" it goes inside the function
delete(sym, t)(n): RECURSIVE term =
   IF pair?(t) THEN LET
       num_arg1 = num_arg(sym, term1(t)),
       num_arg2 = num_arg(sym, term2(t)) IN
       IF n <= num_arg1 THEN
	  IF num_arg1 = 1 THEN term2(t)
	  ELSE pair(delete(sym, term1(t))(n), term2(t))
	  ENDIF
       ELSE
	  IF num_arg2 = 1 THEN term1(t)
	  ELSE pair(term1(t), delete(sym, term2(t))(n))
	  ENDIF
       ENDIF
   ELSIF ac_app?(t) AND ac_sym(t) = sym THEN
       IF num_arg(sym, t) = 1 THEN unit
       ELSE ac_app(ac_sym(t), delete(sym, ac_arg(t))(n))
       ENDIF 
   ELSE unit 
   ENDIF
MEASURE t by <<

% get the arguments of a term t.
% if it encounters an ac function whose root is "sym" it goes inside the function
get_args(sym)(t): args =
    LET n = num_arg(sym, t), lst_until_n = from_min2max(1, n) IN 
    	map(select(sym, t))(lst_until_n)
    
% get a list of arguments of an AC_term t (whose function symbol is sym)
% and how many times they appear as arguments
get_args_coef_ac(t, sym): [args, list[nat]] =
    LET args = get_args(sym)(t) IN
    count_elem(null, null, args)

% obtain a term to represent a whole list of terms
get_term_from_args(args): RECURSIVE term =
    IF null?(args) THEN unit
    ELSIF length(args) = 1 THEN car(args)
    ELSE pair(car(args), get_term_from_args(cdr(args)))
    ENDIF
MEASURE args BY << 

get_ac_from_args(sym)(args): term = ac_app(sym, get_term_from_args(args))

simple_term?(f, t): bool = 
   cons(t, null) = get_args(f)(t)

simple_args?(f, args): RECURSIVE bool =
    IF null?(args) THEN TRUE
    ELSE LET t = car(args) IN
         simple_term?(f, t) AND simple_args?(f, cdr(args))
    ENDIF
MEASURE args BY << 

%%%%%%%%%%%%%%%
size_ge1: LEMMA
    size(t) >= 1
    
num_arg_ge1: LEMMA
    num_arg(f, t) > 0 

num_arg_ge1_type_t: LEMMA
    num_arg(f, t) > 1 IMPLIES (pair?(t) OR is_ac_sym?(t, f))

select_le1: LEMMA
    n <= 1 IMPLIES select(f, t)(n) = select(f, t)(1)

select_size: LEMMA
    size(select(f, t)(n)) <= size(t) 

ac_select_size: LEMMA
    is_ac_sym?(t, f) IMPLIES size(select(f, t)(n)) < size(t) 

delete_size: LEMMA
    size(delete(f, t)(n)) <= size(t)

num_arg_delete_size: LEMMA
    num_arg(f, t) > 1 IMPLIES size(delete(f, t)(n)) < size(t) 

ac_delete_size: LEMMA
    ac_app?(t) IMPLIES size(delete(f, t)(n)) < size(t) 

delete_le1: LEMMA
    n <= 1 IMPLIES delete(f, t)(n) = delete(f, t)(1) 

delete_ac_num_arg_gt1: LEMMA 
    is_ac_sym?(t, f) AND num_arg(f, t) > 1
    IMPLIES is_ac_sym?(delete(f, t)(n), f)

select_delete: CONJECTURE
    is_ac_sym?(t, f) AND j > i AND i < num_arg(f, t) IMPLIES
    select(f, t)(i) = select(f, delete(f, t)(j))(i) 

get_args_len: LEMMA
    length(get_args(f)(t)) = num_arg(f, t) 

get_args_ac: LEMMA
    get_args(f)(ac_app(f, t)) = get_args(f)(t)

get_args_pair: LEMMA
    get_args(f)(pair(t, s)) = append(get_args(f)(t), get_args(f)(s))

% TODO: Am i using this?
% TODO: I think not, check later
get_ac_from_args_cor: CONJECTURE
    simple_args?(f, args) AND NOT null?(args) IMPLIES 
    get_args(f)(get_ac_from_args(f)(args)) = args


END term_properties
