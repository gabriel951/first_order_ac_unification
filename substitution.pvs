%
% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: substitution.pvs
% Description: Definition of a substitution and related properties

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

substitution: THEORY
BEGIN
	IMPORTING equality, map_theory[term, term], map_theory[term, args]
	
a, i: VAR nat
X, Y: VAR variable
t, s, arg: VAR term
args, args1, args2: VAR args

f: VAR ac_symbol
coef: VAR list[nat]

% a basic substitution is one of the form {variable->term}, as in X->s
basic_sub: TYPE = [variable, term]
sigma_basic: VAR basic_sub

% applies the substitution X -> s in the term t
subs(sigma_basic, t): RECURSIVE term =
    LET X = sigma_basic`1,
    	s = sigma_basic`2
	IN CASES t OF
           const(a): const(a),
	   variable(Y): IF X = Y THEN s
		     	ELSE variable(Y)
		     	ENDIF,
	   unit: unit,
	   pair(t1, t2): pair(subs(sigma_basic, t1), subs(sigma_basic, t2)),
	   app(f, arg): app(f, subs(sigma_basic, arg)),
	   ac_app(f, arg): ac_app(f, subs(sigma_basic, arg))
    ENDCASES
MEASURE t by <<

% A substitution is represented as a list of basic substitutions
% This way the composition of substitutions sigma and delta, represented in math as
% "(sigma o delta)" can be implemented as "append(sigma, delta)".
sub: TYPE = list[basic_sub]

sigma, delta, delta2: VAR sub

% action of a substitution sigma on a term t.
% notice that in "(sigma o delta)(t) = sigma(delta(t))" we apply the substitution delta first,
% and the substitution sigma after. Since "(sigma o delta)(t)" is represented as
% "append(sigma, delta)", we must apply first the basic substitution in the tail of the list
subs(sigma)(t): RECURSIVE term =
    CASES sigma OF
    	  null: t,
	  cons(head, tail): subs(head, subs(tail)(t))
    ENDCASES
MEASURE sigma BY << 

% action of a substitution on a variable
subs(sigma)(X): term = subs(sigma)(variable(X))

% apply substitution to a list of terms
subs(sigma)(args): RECURSIVE args =
    IF null?(args) THEN null
    ELSE LET t = car(args) IN cons(subs(sigma)(t), subs(sigma)(cdr(args)))
    ENDIF
MEASURE args BY << 

% define when two substitutions are equal
equal?(sigma, delta): bool =
    FORALL t: subs(sigma)(t) = subs(delta)(t)

% define when sigma is more general than delta
more_general?(sigma, delta): bool = 
    EXISTS delta2: equal?(sigma, append(delta2, delta))
    
% a superset of the domain of a substitution sigma
supset_dom(sigma): RECURSIVE finite_set[variable] = 
    IF null?(sigma) THEN emptyset
    ELSE LET X = car(sigma)`1 IN add(X, supset_dom(cdr(sigma)))
    ENDIF
MEASURE sigma BY << 

% if subs(sigma)(X) /= variable(X) then member(X, supset_dom(sigma))
% needed for the TCC of dom
supset_dom_correct: LEMMA
   subs(sigma)(X) /= variable(X) IMPLIES member(X, supset_dom(sigma))

% domain of a substitution
dom(sigma): finite_set[variable] = {X | subs(sigma)(X) /= variable(X)}

supset_dom_correct2: LEMMA
    subset?(dom(sigma), supset_dom(sigma))

% image of a substitution 
img(sigma): finite_set[term] = {t | EXISTS X: member(X, dom(sigma)) AND subs(sigma)(X) = t} 


%%%%%%%%%%%%%%%%%%% Theorems
% substitution and their effects on the terms
subs_const: LEMMA
    subs(sigma)(const(a)) = const(a)

subs_unit: LEMMA
    subs(sigma)(unit) = unit 
   
subs_pair: LEMMA
    subs(sigma)(pair(t, s)) = pair(subs(sigma)(t), subs(sigma)(s))

subs_app: LEMMA
    subs(sigma)(app(f, arg)) = app(f, subs(sigma)(arg))

subs_ac: LEMMA
    subs(sigma)(ac_app(f, arg)) = ac_app(f, subs(sigma)(arg))

subs_len: LEMMA
    length(subs(sigma)(args)) = length(args)

subs_append: LEMMA
    subs(sigma)(append(args1, args2)) = append(subs(sigma)(args1), subs(sigma)(args2))
    
subs_map: LEMMA
    map(subs(sigma))(args) = subs(sigma)(args)

subs_get_term_from_args: LEMMA
    subs(sigma)(get_term_from_args(args1)) = get_term_from_args(subs(sigma)(args1))

subs_get_ac_from_args: LEMMA
    subs(sigma)(get_ac_from_args(f)(args)) = get_ac_from_args(f)(subs(sigma)(args))

subs_args_nth: LEMMA
    i < length(args) IMPLIES
    nth(subs(sigma)(args), i) = subs(sigma)(nth(args, i))
 
subs_remove: LEMMA
    remove(subs(sigma)(args), i) = subs(sigma)(remove(args, i))

args_subs_ac: LEMMA 
    get_args(f)(subs(sigma)(t)) = flatten(map(get_args(f))(map(subs(sigma))(get_args(f)(t))))

subs_get_args1: LEMMA 
    num_arg(f, t) = 1 IMPLIES
    get_args(f)(subs(sigma)(t)) = get_args(f)(subs(sigma)(select(f, t)(i)))

subs_perm_get_args_ge1: LEMMA
    num_arg(f, t) > 1 IMPLIES 
    perm?(get_args(f)(subs(sigma)(t)),
          append(get_args(f)(subs(sigma)(select(f, t)(i))),
	  	 get_args(f)(subs(sigma)(delete(f, t)(i)))))

subs_equal?: LEMMA
    equal?(t, s) IMPLIES
    equal?(subs(sigma)(t), subs(sigma)(s))

subs_perm?: LEMMA
    perm?(args1, args2) => perm?(subs(sigma)(args1), subs(sigma)(args2))

subs_get_repeat_lst: LEMMA
    subs(sigma)(get_repeat_lst(t, i)) = get_repeat_lst(subs(sigma)(t), i)

subs_get_lst_mult: LEMMA
    subs(sigma)(get_lst_mult(args, coef)) = get_lst_mult(subs(sigma)(args), coef)

perm?_get_args_subs: LEMMA
    perm?(subs(sigma)(get_args(f)(t)), subs(sigma)(get_args(f)(s))) IMPLIES
    perm?(get_args(f)(subs(sigma)(t)), get_args(f)(subs(sigma)(s)))

% domain and img of a substitution lemmas
dom_basic_sub: LEMMA
    dom(cons((X, t), null)) = singleton(X) OR member(X, vars(t))

img_basic_sub: LEMMA
    img(cons((X, t), null)) = singleton(t) OR member(X, vars(t)) 

END substitution
