% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: Terms.pvs
% Description: Definition of a first order term and properties related to them

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% definition of a term
term[constant:TYPE, variable:TYPE+, f_symbol:TYPE, ac_symbol:TYPE]: DATATYPE
    BEGIN
	const (a: constant): const?
	variable (V: variable): var?
	unit: unit?
	pair (term1: term, term2: term): pair?
	app (f_sym: f_symbol, arg: term): app?
	ac_app (ac_sym: ac_symbol, ac_arg: term): ac_app? 
    END term


%%%%%%%%%%%%%%%%%%%%%%%%%%
term_properties: THEORY
BEGIN

% definition of variable, constant and syntactic and AC function symbols 
variable: TYPE = nat
constant: TYPE = nat
f_symbol: TYPE = string
ac_symbol: TYPE = string

IMPORTING 
	  term[constant, variable, f_symbol, ac_symbol],
	  list_theory[term] 

sym, f: VAR string
n, i, j: VAR nat
lst_nat: VAR list[nat]

t, s: VAR term

args: TYPE = list[term]
args: VAR args

% the size of a term 
size(t): RECURSIVE nat =
    CASES t OF
        const(a): 1,
	variable(X): 1, 
	unit: 1, 
	pair(t1, t2): 1 + size(term1(t)) + size(term2(t)),
	app(sym, arg): 1  + size(arg),
	ac_app(sym, arg): 1  + size(arg)
    ENDCASES
MEASURE t BY << 

% size of a list of arguments
size(args): RECURSIVE nat =
     IF null?(args) THEN 1
     ELSE LET t = car(args) IN size(t) + size(cdr(args)) 
     ENDIF 
MEASURE length(args) 

% test if t is an AC function symbol headed by sym
is_ac_sym?(t, sym): bool = ac_app?(t) AND sym = ac_sym(t)

% test if t and s are AC function symbols headed by "sym"
are_ac?(t, s, sym): bool = ac_app?(t) AND ac_app?(s) AND sym = ac_sym(t) AND sym = ac_sym(s) 

% get the number of arguments of a term "t"
% if it encounters an ac function whose root is "sym" it goes inside the function
num_arg(sym, t): RECURSIVE nat =
    IF pair?(t) THEN num_arg(sym, term1(t)) + num_arg(sym, term2(t))
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN num_arg(sym, ac_arg(t))
    ELSE 1
    ENDIF
MEASURE t BY << 


% select the nth (index start at one) argument of an a term.
% if it encounters an ac function whose root is "sym" it goes inside the function
select(sym, t)(n): RECURSIVE term =
    IF pair?(t) THEN
        LET n1 = num_arg(sym, term1(t)) IN
        IF n <= n1 THEN select(sym, term1(t))(n)
        ELSE select(sym, term2(t))(n-n1)
        ENDIF
    ELSIF ac_app?(t) AND ac_sym(t) = sym THEN select(sym, ac_arg(t))(n)
    ELSE t
    ENDIF 
MEASURE t BY <<

% delete the nth (index start at one) argument of a term
% if it encounters an ac function whose root is "sym" it goes inside the function
delete(sym, t)(n): RECURSIVE term =
   IF pair?(t) THEN LET
       num_arg1 = num_arg(sym, term1(t)),
       num_arg2 = num_arg(sym, term2(t)) IN
       IF n <= num_arg1 THEN
	  IF num_arg1 = 1 THEN term2(t)
	  ELSE pair(delete(sym, term1(t))(n), term2(t))
	  ENDIF
       ELSE
	  IF num_arg2 = 1 THEN term1(t)
	  ELSE pair(term1(t), delete(sym, term2(t))(n - num_arg1))
	  ENDIF
       ENDIF
   ELSIF ac_app?(t) AND ac_sym(t) = sym THEN
       IF num_arg(sym, t) = 1 THEN unit
       ELSE ac_app(ac_sym(t), delete(sym, ac_arg(t))(n))
       ENDIF 
   ELSE unit 
   ENDIF
MEASURE t by <<

% receives a list of terms "args = [t0, ..., ti, ..., tn]"
% deletes the "jth" element from the "ti"
% counting start at 0 
% returns [t1, ..., Dj(ti), ..., tn]
delete(args, f, i, j): RECURSIVE args = 
    IF null?(args) THEN null
    ELSE LET t = car(args) IN
         IF i = 0 THEN
	    IF num_arg(f, t) = 1 THEN cdr(args) 
	    ELSE cons(delete(f, t)(j+1), cdr(args))
	    ENDIF
	 ELSE cons(t, delete(cdr(args), f, i-1, j))
	 ENDIF
    ENDIF
MEASURE args BY << 

% returns true case i > 0 and i <= n.
nice_ind?(i, n): bool = i > 0 AND i <= n

% returns true case nice_ind?(i, n) for every "i" in "lst_nat"
nice_ind?(lst_nat, n): RECURSIVE bool =
    IF null?(lst_nat) THEN TRUE
    ELSE nice_ind?(car(lst_nat), n) AND nice_ind?(cdr(lst_nat), n)
    ENDIF
MEASURE lst_nat BY << 

% get the arguments of a term t.
% if it encounters an ac function whose root is "sym" it goes inside the function
get_args(sym)(t): args =
    LET n = num_arg(sym, t), lst_until_n = from_min2max(1, n) IN 
    	map(select(sym, t))(lst_until_n)
    
% get a list of arguments of an AC_term t (whose function symbol is sym)
% and how many times they appear as arguments
%get_args_coef_ac(t, sym): [args, list[nat]] =
%    LET args = get_args(sym)(t) IN
%    count_elem(null, null, args)

% obtain a term to represent a whole list of terms
get_term_from_args(args): RECURSIVE term =
    IF null?(args) THEN unit
    ELSIF length(args) = 1 THEN car(args)
    ELSE pair(car(args), get_term_from_args(cdr(args)))
    ENDIF
MEASURE args BY << 

get_ac_from_args(sym)(args): term = ac_app(sym, get_term_from_args(args))

%%%%%%%%%%%%%%%
% size
size_ge1: LEMMA
    size(t) >= 1
    
% num_arg
num_arg_ge1: LEMMA
    num_arg(f, t) > 0 

num_arg_ge1_type_t: LEMMA
    num_arg(f, t) > 1 IMPLIES (pair?(t) OR is_ac_sym?(t, f))

num_arg_not_pair_ac: LEMMA
    NOT (pair?(t) OR is_ac_sym?(t, f)) IMPLIES num_arg(f, t) = 1

% select
select_num_arg: LEMMA
    num_arg(f, select(f, t)(i)) = 1

select_le1: LEMMA
    n <= 1 IMPLIES select(f, t)(n) = select(f, t)(1)

select_ge_num_arg: LEMMA
    LET n = num_arg(f, t) IN 
    i >= n IMPLIES select(f, t)(i) = select(f, t)(n) 

select_size: LEMMA
    size(select(f, t)(n)) <= size(t) 

ac_select_size: LEMMA
    is_ac_sym?(t, f) IMPLIES size(select(f, t)(n)) < size(t) 

% delete
delete_size: LEMMA
    size(delete(f, t)(n)) <= size(t)


num_arg_delete: LEMMA
    num_arg(f, delete(f, t)(n)) <= num_arg(f, t)

num_arg_delete_ge1: LEMMA
    num_arg(f, t) > 1 IMPLIES num_arg(f, delete(f, t)(n)) = num_arg(f, t) - 1
    
num_arg_delete_size: LEMMA
    num_arg(f, t) > 1 IMPLIES size(delete(f, t)(n)) < size(t) 

num_arg1_delete: LEMMA
    num_arg(f, t) = 1 IMPLIES delete(f, t)(n) = unit

delete_num_arg: LEMMA 
    is_ac_sym?(t, f) AND delete(f, t)(n) = unit IMPLIES num_arg(f, t) = 1

ac_delete_size: LEMMA
    ac_app?(t) IMPLIES size(delete(f, t)(n)) < size(t) 

delete_le1: LEMMA
    n <= 1 IMPLIES delete(f, t)(n) = delete(f, t)(1) 

delete_ge_num_arg: LEMMA
    LET n = num_arg(f, t) IN 
    i >= n IMPLIES delete(f, t)(i) = delete(f, t)(n) 

delete_ac_num_arg_gt1: LEMMA 
    is_ac_sym?(t, f) AND num_arg(f, t) > 1
    IMPLIES is_ac_sym?(delete(f, t)(n), f)

is_ac_sym?_delete: LEMMA
    is_ac_sym?(t, f) IMPLIES
    is_ac_sym?(delete(f, t)(n), f) = is_ac_sym?(delete(f, t)(i), f) 

num_arg_select_delete: LEMMA
    num_arg(f, t) > 1 IMPLIES
    num_arg(f, t) = num_arg(f, select(f, t)(i)) + num_arg(f, delete(f, t)(i)) 

% delete (from a lst of args)
delete_size2: LEMMA 
    i < length(args) IMPLIES size(delete(args, f, i, j)) < size(args)

delete_remove1: LEMMA
    i < length(args) AND j < num_arg(f, nth(args, i)) AND num_arg(f, nth(args, i)) = 1
    IMPLIES delete(args, f, i, j) = remove(args, i) 

delete_nth_len: LEMMA
    i < length(args) AND num_arg(f, nth(args, i)) > 1 IMPLIES
    length(delete(args, f, i, j)) = length(args)

delete_nth: LEMMA
    i < length(args) AND j < num_arg(f, nth(args, i)) AND num_arg(f, nth(args, i)) > 1
    IMPLIES nth(delete(args, f, i, j), i) = delete(f, nth(args, i))(j+1)

delete_remove_gt1: LEMMA
    i < length(args) AND j < num_arg(f, nth(args, i)) AND num_arg(f, nth(args, i)) > 1
    IMPLIES remove(delete(args, f, i, j), i) = remove(args, i) 

delete_not_null: LEMMA
    i < length(args) AND num_arg(f, nth(args, i)) > 1
    IMPLIES NOT null?(delete(args, f, i, j))
    
% delete, select and nice_ind
gt_select_delete: LEMMA 
    nice_ind?((: i, n :), num_arg(f, t)) AND i > n IMPLIES 
    select(f, delete(f, t)(i))(n) = select(f, t)(n) 

le_select_delete: LEMMA
    nice_ind?((: i, n :), num_arg(f, t)-1) AND num_arg(f, t) > 1 AND i <= n
    IMPLIES select(f, delete(f, t)(i))(n) = select(f, t)(n+1)


gt_select_delete2: LEMMA
    nice_ind?((: i, n :), num_arg(f, t)) AND i > n IMPLIES
    select(f, delete(f, t)(n))(i-1) = select(f, t)(i) 
    

gt_delete_delete: LEMMA
    nice_ind?((: i, n :), num_arg(f, t)) AND i > n IMPLIES 
    delete(f, delete(f, t)(n))(i-1) = delete(f, delete(f, t)(i))(n)

% get args
get_args_len: LEMMA
    length(get_args(f)(t)) = num_arg(f, t) 

get_args_null: LEMMA
    NOT null?(get_args(f)(t))

get_args_ac: LEMMA
    get_args(f)(ac_app(f, t)) = get_args(f)(t)

get_args_pair: LEMMA
    get_args(f)(pair(t, s)) = append(get_args(f)(t), get_args(f)(s))

get_args_not_pair_ac: LEMMA
    NOT pair?(t) AND NOT is_ac_sym?(t, f) IMPLIES get_args(f)(t) = cons(t, null)

get_args_nth: LEMMA
    nice_ind?(i, num_arg(f, t)) IMPLIES
    nth(get_args(f)(t), i-1) = select(f, t)(i) 

get_args_remove: LEMMA
    nice_ind?(i, num_arg(f, t)) AND num_arg(f, t) > 1 IMPLIES
    remove(get_args(f)(t), i-1) = get_args(f)(delete(f, t)(i)) 

get_args_get_term_from_args: LEMMA
    NOT null?(args) IMPLIES
    get_args(f)(get_term_from_args(args)) = flatten(map(get_args(f))(args))

remove_get_args_del: LEMMA 
    j < num_arg(f, t) AND num_arg(f, t) > 1 IMPLIES
    remove(get_args(f)(t), j) = get_args(f)(delete(f, t)(j+1))
    
get_args_remove_del: LEMMA 
    i < length(args) AND j < num_arg(f, nth(args, i)) IMPLIES
    remove(map(get_args(f))(args), i, j) = map(get_args(f))(delete(args, f, i, j))


END term_properties
