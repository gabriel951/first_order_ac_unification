% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: diophantine.pvs
% Description: functions related to solving diophantine equations
%%%%%%%%%%%%%%%%%%%%%%%

diophantine: THEORY
BEGIN
	IMPORTING list_theory[nat], list_theory[list[nat]], min_nat[nat]

% a diophantine matrix is a list of list of naturals
Dio_matrix: TYPE = list[list[nat]]
dio_matrix: VAR Dio_matrix

% the variables mult_t are used to indicate the multiplicity of the term t. They are a vector [a1, ..., an]
mult_t, mult_t1, mult_t2: VAR list[posnat]

value_lst: VAR list[nat]

a1, X1, n, n1, n2, k, bound, value: VAR nat


% defines least common multiple
lcm(n1, n2): nat = min({k: posnat | divides(n1, k) AND divides(n2, k)})

% defines the maximum of possible pairs lcm(a_i, b_j)
max_lcm(mult_t1, mult_t2): nat =
    IF null?(mult_t1) OR null?(mult_t2) THEN 0
    ELSE LET lcm_seq = map(lcm, cartesian_product(mult_t1, mult_t2)) IN 
         {k: posnat | member(k, lcm_seq) AND (FORALL n: member(n, lcm_seq) IMPLIES k >= n)}
    ENDIF
    
% calculate the upper bound of solutions, where we can stop
calculate_upper_bound(mult_t1, mult_t2): nat =
    max(length(mult_t1), length(mult_t2)) * max_lcm(mult_t1, mult_t2)


get_new_value_lst(n, value_lst): RECURSIVE list[int] =
    IF null?(value_lst) THEN (::)
    ELSE cons(n - car(value_lst), get_new_value_lst(n, cdr(value_lst)))
    ENDIF
MEASURE value_lst BY << 

% receives a vector [a1, ..., an] and a specified value
% find all vectors [X1, ..., Xn] such that a1*X1 + ... + an*Xn = specified_value
find_vectors(mult_t)(value): RECURSIVE list[list[posnat]] =
    IF null?(mult_t) THEN (::)
    ELSIF length(mult_t) = 1 THEN LET a1 = car(mult_t) IN 
    	 IF divides(a1, value) THEN LET X1 = value/a1
	    IN cons(cons(X1, null), null)
	 ELSE (::) 
	 ENDIF
    ELSE LET
    	 a1 = car(mult_t),
	 X1_values = nat_upto[nat](floor(value/a1)),
	 new_value_lst = get_new_value_lst(value, X1_values)
	 vector_lst_cdr = map(find_vectors(cdr(mult_t)), new_value_lst),
	 vector_lst = cons_map(X1_values, vector_lst_cdr)
	 result = flatten(vector_lst)
	 IN result
    ENDIF
MEASURE mult_t BY << 

% solve diophantine equation with both sides being equal to n
dio_solver_n(mult_t1, mult_t2, n): Dio_matrix =
    LET vector_lst1 = find_vectors(mult_t1, n),
    	vector_lst2 = find_vectors(mult_t2, n),
	all_combinations = cartesian_product[list[nat]](vector_lst1, vector_lst2),

	% when we apply append to one particular combination in all_combinations
	% we obtain a row of the diophatine matrix
	dio_matrix = map(append_pair, all_combinations)
    IN  dio_matrix

% solve diophatine solution until upper bound
% this corresponds to function dioph in Fages paper 
dio_solver(mult_t1, mult_t2, bound): RECURSIVE Dio_matrix =
    IF bound = 0 THEN (::) % TODO: check if this is indeed correct
    ELSE append(dio_solver_n(mult_t1, mult_t2, bound), dio_solver(mult_t1, mult_t2, bound - 1))
    ENDIF
MEASURE bound  

END diophantine
