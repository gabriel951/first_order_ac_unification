("equality" |equality| |equal?_not_ac_get_args| 0 (|equal?_not_ac_get_args-1| NIL 3807563369 NIL ("" (MEASURE-INDUCT "size(t1)" "t1") (("" (SKOLEM 1 "t1") (("" (PROP) (("" (SKEEP) (("" (HIDE -1) (("" (EXPAND "equal?" -1) (("" (LIFT-IF) (("" (PROP) (("1" (GRIND) (("1" (LEMMA "term_const_eta") (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) (("2" (LEMMA "term_variable_eta") (("2" (INST? -1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL) ("4" (HIDE 1 2 3) (("4" (LEMMA "term_pair_eta") (("4" (INST-CP -1 "t1") (("4" (INST -1 "t2") (("4" (REPLACE -1 2 RL) (("4" (REPLACE -2 2 RL) (("4" (REWRITE "get_args_pair") (("4" (REWRITE "get_args_pair") (("4" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (POSTPONE) NIL NIL) ("6" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("terms" |term_properties| |delete_TCC6| 0 (|delete_TCC6-1| NIL 3807528173 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("terms" |term_properties| |delete_TCC5| 0 (|delete_TCC5-1| NIL 3807528173 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("terms" |term_properties| |delete_TCC4| 0 (|delete_TCC4-1| NIL 3807528173 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("terms" |term_properties| |delete_TCC3| 0 (|delete_TCC3-1| NIL 3807528173 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("terms" |term_properties| |get_ac_from_args_cor| 0 (|get_ac_from_args_cor-1| NIL 3805735173 NIL ("" (MEASURE-INDUCT "length(args)" "args") (("" (SKOLEM 1 "args1") (("" (PROP) (("" (SKEEP) (("" (EXPAND "get_ac_from_args" 2) (("" (EXPAND "get_term_from_args" 2) (("" (LIFT-IF) (("" (ASSERT) (("" (PROP) (("1" (EXPAND "simple_args?" -3) (("1" (PROP) (("1" (EXPAND "simple_term?") (("1" (REWRITE "get_args_ac") (("1" (ASSERT) (("1" (REPLACE -3 1 RL) (("1" (HIDE -2) (("1" (LEMMA "list_cons_eta[term]") (("1" (INST? -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "get_args_ac") (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("terms" |term_properties| |simple_args?_TCC1| 0 (|simple_args?_TCC1-1| NIL 3805735090 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((|simple_term?| CONST-DECL "bool" |term_properties| NIL) (|get_args| CONST-DECL "args" |term_properties| NIL) (|variable| TYPE-EQ-DECL NIL |term_properties| NIL) (|constant| TYPE-EQ-DECL NIL |term_properties| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|args| TYPE-EQ-DECL NIL |term_properties| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|term| TYPE-DECL NIL |term_adt| NIL) (|ac_symbol| TYPE-EQ-DECL NIL |term_properties| NIL) (|f_symbol| TYPE-EQ-DECL NIL |term_properties| NIL) (|char| TYPE-EQ-DECL NIL |strings| NIL) (|char?| ADT-RECOGNIZER-DECL "[character -> boolean]" |character_adt| NIL) (|character| TYPE-DECL NIL |character_adt| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("diophantine" |diophantine| |dio_matrix_correct?_split_TCC1| 0 (|dio_matrix_correct?_split_TCC1-1| NIL 3807800186 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("diophantine" |diophantine| |prod_TCC4| 0 (|prod_TCC4-1| NIL 3807802208 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("diophantine" |diophantine| |prod_TCC3| 0 (|prod_TCC3-1| NIL 3807802208 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |split_matrix_len1| 0 (|split_matrix_len1-1| NIL 3807805807 NIL ("" (INDUCT "matrix") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) NIL ((|split| CONST-DECL "[list[T], list[T]]" |list_theory| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|split_matrix| DEF-DECL "[list[list[T]], list[list[T]]]" |list_theory| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |split_matrix_nth_TCC2| 0 (|split_matrix_nth_TCC2-1| NIL 3807887388 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |cart_prod_mem_nth| 0 (|cart_prod_mem_nth-1| NIL 3807895312 NIL ("" (SKEEP) (("" (LEMMA "cart_prod_mem") (("" (INST? -1) (("" (ASSERT) (("" (NAME-REPLACE "result" "cartesian_product(lst1, lst2)") (("" (REPLACE -1 1) (("" (HIDE -1) (("" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("list" |list_theory| |get_repeat_lst_mem| 0 (|get_repeat_lst_mem-1| NIL 3807907576 NIL ("" (POSTPONE) NIL NIL) NIL NIL NIL NIL NIL SHOSTAK))("list" |list_theory| |all_lsts_length?_TCC1| 0 (|all_lsts_length?_TCC1-1| NIL 3804618454 NIL ("" (TCC)) NIL ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("diophantine" |diophantine| |get_lst_dio_matrix_mem_nth_TCC3| 0 (|get_lst_dio_matrix_mem_nth_TCC3-1| NIL 3808149955 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("diophantine" |diophantine| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808150529 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("diophantine" |diophantine| |temp_lemma| 0 (|temp_lemma-1| NIL 3808157266 NIL ("" (SKEEP) (("" (CASE "n/a1 >= j") (("1" (HIDE -2) (("1" (CASE "n/a1 - j >= 0") (("1" (HIDE -2) (("1" (GRIND) (("1" (CASE "n/a1 - j = 0") (("1" (GRIND) NIL NIL) ("2" (CASE "n/a1 - j > 0") (("1" (GRIND) (("1" (HIDE -2 1) (("1" (CASE " j < n/a1") (("1" (HIDE -2) (("1" (GRIND) (("1" (CASE "a1 * j < n") (("1" (GRIND) NIL NIL) ("2" (GRIND) (("2" (HIDE 2) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("aux_unification" |aux_unification| |dio_matrix2ac_sol_correct_TCC1| 0 (|dio_matrix2ac_sol_correct_TCC1-1| NIL 3805915736 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("aux_unification" |aux_unification| |extract_submatrices_cor_TCC2| 0 (|extract_submatrices_cor_TCC2-1| NIL 3805917506 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("aux_unification" |aux_unification| |extract_submatrices_cor_TCC1| 0 (|extract_submatrices_cor_TCC1-1| NIL 3805917506 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("aux_unification" |aux_unification| |get_all_sublists_dio_cor_TCC2| 0 (|get_all_sublists_dio_cor_TCC2-1| NIL 3808228204 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("aux_unification" |aux_unification| |get_all_sublists_dio_cor_TCC1| 0 (|get_all_sublists_dio_cor_TCC1-1| NIL 3808228204 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("diophantine" |diophantine| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808162744 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|dio_matrix| TYPE-EQ-DECL NIL |diophantine| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("diophantine" |diophantine| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808162744 ("" (SUBTYPE-TCC) NIL NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|dio_matrix| TYPE-EQ-DECL NIL |diophantine| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808235834 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |select_args_len| 0 (|select_args_len-1| NIL 3805732280 NIL ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 ("lst1")) (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" 1 1) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (PROP) (("1" (EXPAND "select_args" 1 2) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (EXPAND "length" 1) (("1" (INST -2 "cdr(lst1)") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "select_args" 2 2) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |select_args_pos2| 0 (|select_args_pos2-1| NIL 3804688572 NIL ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("1" (SKOLEM 1 ("lst1")) (("1" (PROP) (("1" (SKEEP) (("1" (EXPAND "select_args" -2) (("1" (LIFT-IF) (("1" (SPLIT) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE -2) (("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (MEASURE-INDUCT "length(lst1)" "lst1") (("2" (SKOLEM 1 ("lst1")) (("2" (PROP) (("2" (HIDE -1) (("2" (SKEEP) (("2" (EXPAND "select_args" -1) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (> CONST-DECL "bool" |reals| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |select_args_pos2_TCC1| 0 (|select_args_pos2_TCC1-1| NIL 3804688571 NIL ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 "lst1") (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" -2) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (HIDE -2) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |select_args_pos| 0 (|select_args_pos-1| NIL 3804680626 NIL ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 "lst1") (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" -2) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (ASSERT) NIL NIL) ("2" (INST -3 "cdr(lst1)") (("2" (PROP) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -1 -2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST -2 "cdr(lst1)") (("2" (PROP) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -1 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (> CONST-DECL "bool" |reals| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |select_args_TCC1| 0 (|select_args_TCC1-1| NIL 3803487042 NIL ("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (REPLACE -6 3) (("" (EXPAND "every" 3) (("" (ASSERT) (("" (TYPEPRED "v(cdr(lst1), cdr(coef1), lst2, coef2)`2") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |count_elem_TCC2| 0 (|count_elem_TCC2-1| NIL 3803367839 NIL ("" (TCC)) NIL ((|pos?| DEF-DECL "[bool, nat]" |list_theory| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |count_elem_TCC1| 0 (|count_elem_TCC1-1| NIL 3803367839 NIL ("" (TCC)) NIL ((|pos?| DEF-DECL "[bool, nat]" |list_theory| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC5| 0 (|select_greater_TCC5-1| NIL 3804618454 NIL ("" (TCC)) NIL ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC4| 0 (|select_greater_TCC4-1| NIL 3804618454 NIL ("" (TCC)) NIL ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC3| 0 (|select_greater_TCC3-1| NIL 3804618454 NIL ("" (TCC)) NIL ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |get_multiplicity_TCC3| 0 (|get_multiplicity_TCC3-1| NIL 3803477476 NIL ("" (TCC)) NIL ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |get_multiplicity_TCC2| 0 (|get_multiplicity_TCC2-1| NIL 3803477476 NIL ("" (TCC)) NIL ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808235834 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("list" |list_theory| |select_args_len| 0 (|select_args_len-1| NIL 3805732280 ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 ("lst1")) (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" 1 1) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (PROP) (("1" (EXPAND "select_args" 1 2) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (EXPAND "length" 1) (("1" (INST -2 "cdr(lst1)") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "select_args" 2 2) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK))("list" |list_theory| |select_args_pos2| 0 (|select_args_pos2-1| NIL 3804688572 ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("1" (SKOLEM 1 ("lst1")) (("1" (PROP) (("1" (SKEEP) (("1" (EXPAND "select_args" -2) (("1" (LIFT-IF) (("1" (SPLIT) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE -2) (("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (MEASURE-INDUCT "length(lst1)" "lst1") (("2" (SKOLEM 1 ("lst1")) (("2" (PROP) (("2" (HIDE -1) (("2" (SKEEP) (("2" (EXPAND "select_args" -1) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (> CONST-DECL "bool" |reals| NIL)) SHOSTAK))("list" |list_theory| |select_args_pos2_TCC1| 0 (|select_args_pos2_TCC1-1| NIL 3804688571 ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 "lst1") (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" -2) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (HIDE -2) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (SPLIT) (("1" (INST? -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REVEAL -1) (("2" (INST -1 "cdr(lst1)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK))("list" |list_theory| |select_args_pos| 0 (|select_args_pos-1| NIL 3804680626 ("" (MEASURE-INDUCT "length(lst1)" "lst1") (("" (SKOLEM 1 "lst1") (("" (PROP) (("" (SKEEP) (("" (EXPAND "select_args" -2) (("" (LIFT-IF) (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "member" -2) (("1" (SPLIT) (("1" (ASSERT) NIL NIL) ("2" (INST -3 "cdr(lst1)") (("2" (PROP) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -1 -2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST -2 "cdr(lst1)") (("2" (PROP) (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -1 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (> CONST-DECL "bool" |reals| NIL) (|select_args| DEF-DECL "[list[T], list[nat]]" |list_theory| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK))("list" |list_theory| |select_greater_TCC5| 0 (|select_greater_TCC5-1| NIL 3804618454 ("" (TCC)) ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("list" |list_theory| |select_greater_TCC4| 0 (|select_greater_TCC4-1| NIL 3804618454 ("" (TCC)) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("list" |list_theory| |select_greater_TCC3| 0 (|select_greater_TCC3-1| NIL 3804618454 ("" (TCC)) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("list" |list_theory| |select_args_TCC1| 0 (|select_args_TCC1-1| NIL 3803487042 ("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (REPLACE -6 3) (("" (EXPAND "every" 3) (("" (ASSERT) (("" (TYPEPRED "v(cdr(lst1), cdr(coef1), lst2, coef2)`2") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) SHOSTAK))("list" |list_theory| |get_multiplicity_TCC3| 0 (|get_multiplicity_TCC3-1| NIL 3803477476 ("" (TCC)) ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("list" |list_theory| |get_multiplicity_TCC2| 0 (|get_multiplicity_TCC2-1| NIL 3803477476 ("" (TCC)) ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL))("equality" |equality| |perm_remove_common_get_common| 0 (|perm_remove_common_get_common-1| NIL 3808339569 NIL ("" (MEASURE-INDUCT "length(args1)" "args1") (("" (SKOLEM 1 ("args1")) (("" (PROP) (("" (SKEEP) (("" (EXPAND "perm?" 1 1) (("" (PROP) (("1" (REWRITE "null_append") (("1" (GRIND) NIL NIL)) NIL) ("2" (INST 2 "0" "_") (("1" (EXPAND "nth" 2 1) (("1" (EXPAND "remove" 2 1) (("1" (ASSERT) (("1" (CASE "member(car(args1), remove_common(args1, args2, equal?))") (("1" (HIDE -2) (("1" (INST 2 "0") (("1" (PROP) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("list" |list_theory| |get_common_TCC5| 0 (|get_common_TCC5-1| NIL 3808344388 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_common_TCC4| 0 (|get_common_TCC4-1| NIL 3808344388 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_common_TCC3| 0 (|get_common_TCC3-1| NIL 3808344388 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_common_TCC2| 0 (|get_common_TCC2-1| NIL 3808344388 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_common_TCC1| 0 (|get_common_TCC1-1| NIL 3808344388 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808406085 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("equality" |equality| |perm_get_common| 0 (|perm_get_common-1| NIL 3808407164 NIL ("" (MEASURE-INDUCT "length(args1)" "args1") (("" (SKOLEM 1 ("args1")) (("" (PROP) (("" (SKEEP) (("" (EXPAND "get_common" 1 1) (("" (LIFT-IF) (("" (PROP) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808406897 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |remove_common_TCC2| 0 (|remove_common_TCC2-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |remove_common_TCC1| 0 (|remove_common_TCC1-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |remove_TCC2| 0 (|remove_TCC2-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |split_matrix_TCC1| 0 (|split_matrix_TCC1-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |pareate_TCC2| 0 (|pareate_TCC2-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |pareate_TCC1| 0 (|pareate_TCC1-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_TCC2| 0 (|count_TCC2-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_TCC1| 0 (|count_TCC1-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_all_sublists_TCC1| 0 (|get_all_sublists_TCC1-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |matrix?_TCC2| 0 (|matrix?_TCC2-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC5| 0 (|select_greater_TCC5-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC4| 0 (|select_greater_TCC4-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |select_greater_TCC3| 0 (|select_greater_TCC3-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_TCC3| 0 (|put_in_head_TCC3-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_TCC2| 0 (|put_in_head_TCC2-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_TCC1| 0 (|put_in_head_TCC1-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_multiplicity_TCC3| 0 (|get_multiplicity_TCC3-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_multiplicity_TCC2| 0 (|get_multiplicity_TCC2-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_elem_TCC5| 0 (|count_elem_TCC5-1| NIL 3808406774 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_elem_TCC4| 0 (|count_elem_TCC4-1| NIL 3808406774 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_elem_TCC3| 0 (|count_elem_TCC3-1| NIL 3808343803 NIL ("" (TERMINATION-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808413596 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808422294 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808496129 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |put_in_head_mem_TCC1| 0 (|put_in_head_mem_TCC1-1| NIL 3808515789 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_multiplicity_TCC1| 0 (|get_multiplicity_TCC1-1| NIL 3803477476 NIL ("" (TCC)) NIL ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL NIL NIL NIL))("list" |list_theory| |cdr_append_TCC2| 0 (|cdr_append_TCC2-1| NIL 3808585526 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("equality" |equality| |perm?_get_common_sym_TCC1| 0 (|perm?_get_common_sym_TCC1-1| NIL 3808518211 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |get_lst_mult_ind| 0 (|get_lst_mult_ind-1| NIL 3808579207 NIL ("" (INDUCT "lst" 1) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "nth" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (REPLACE -1 1) (("1" (EXPAND "sum" 1) (("1" (EXPAND "get_lst_mult" 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (GRIND) NIL NIL) ("2" (LEMMA "nth_append") (("2" (INST? -1) (("2" (PROP) (("1" (LIFT-IF) (("1" (PROP) (("1" (REPLACE -2 2) (("1" (HIDE -2) (("1" (EXPAND "get_repeat_lst" 2) (("1" (EXPAND "nth" -6) (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "nth" 2) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" -6) (("2" (ASSERT) (("2" (EXPAND "get_repeat_lst" 1) (("2" (EXPAND "length" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" -5) (("2" (ASSERT) (("2" (EXPAND "get_repeat_lst" 1) (("2" (EXPAND "length" 1 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" -4) (("2" (ASSERT) (("2" (EXPAND "sum" 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (EXPAND "get_lst_mult" 2) (("2" (ASSERT) (("2" (LEMMA "nth_append") (("2" (HIDE -2) (("2" (INST? -1) (("2" (PROP) (("1" (LIFT-IF) (("1" (PROP) (("1" (HIDE -2 2) (("1" (REWRITE "get_repeat_lst_len") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (REPLACE -1 2) (("2" (HIDE -1) (("2" (REWRITE "get_repeat_lst_len") (("2" (ASSERT) (("2" (REVEAL -3) (("2" (INST? -1) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "get_repeat_lst_len") (("2" (ASSERT) (("2" (LEMMA "get_lst_mult_ind_TCC1") (("2" (INST? -1) (("2" (INST -1 "tail") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (SKEEP) (("3" (LEMMA "get_lst_mult_ind_TCC1") (("3" (INST? -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|get_lst_mult| DEF-DECL "list[T]" |list_theory| NIL) (|sum| DEF-DECL "nat" |list_theory| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (> CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nth_append| FORMULA-DECL NIL |list_theory| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|get_repeat_lst| DEF-DECL "list[T]" |list_theory| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|get_lst_mult_ind_TCC1| SUBTYPE-TCC NIL |list_theory| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|get_repeat_lst_len| FORMULA-DECL NIL |list_theory| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |get_lst_mult_ind_TCC1| 0 (|get_lst_mult_ind_TCC1-1| NIL 3808579200 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("equality" |equality| |perm?_get_common_TCC2| 0 (|perm?_get_common_TCC2-1| NIL 3808516500 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("list" |list_theory| |count_cons| 0 (|count_cons-1| NIL 3808603305 NIL ("" (INDUCT "lst1") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) NIL (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|equiv| TYPE-EQ-DECL NIL |list_theory| NIL) (|equivalence?| CONST-DECL "bool" |relations| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL)) NIL NIL NIL SHOSTAK))("list" |list_theory| |count_apppend| 0 (|count_apppend-1| NIL 3808606679 NIL ("" (INDUCT "lst1") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) NIL ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|symmetric?| CONST-DECL "bool" |relations| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (T FORMAL-TYPE-DECL NIL |list_theory| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|count| DEF-DECL "nat" |list_theory| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|equiv| TYPE-EQ-DECL NIL |list_theory| NIL) (|equivalence?| CONST-DECL "bool" |relations| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL)) NIL NIL NIL SHOSTAK))("equality" |equality| |equal?_select_delete_TCC1| 0 (|equal?_select_delete_TCC1-1| NIL 3807606266 ("" (GRIND) NIL NIL) ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) NIL))("aux_unification" |aux_unification| |elim_com_arg_pos_TCC1| 0 (|elim_com_arg_pos_TCC1-1| NIL 3804670529 ("" (SKEEP) (("" (EXPAND "elim_com_arg" -1) (("" (LEMMA "select_args_pos2[Term]") (("" (INST? -1) (("" (ASSERT) (("" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|elim_com_arg_pos| SUBTYPE "aux_unification.num" "real")))("aux_unification" |aux_unification| |elim_com_arg_pos2_TCC1| 0 (|elim_com_arg_pos2_TCC1-1| NIL 3804751239 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|elim_com_arg_pos2| SUBTYPE "aux_unification.num" "real")))("substitution" |substitution| |subs_remove_common_TCC1| 0 (|subs_remove_common_TCC1-1| NIL 3808749295 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|subs_remove_common| SUBTYPE "equality.equal?" "equiv[term[constant, variable, f_symbol, ac_symbol]]")))("substitution" |substitution| |subs_pos?1_TCC1| 0 (|subs_pos?1_TCC1-1| NIL 3808750007 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|subs_pos?1| SUBTYPE "equality.equal?" "equiv[term[constant, variable, f_symbol, ac_symbol]]")))("substitution" |substitution| |subs_pos?1| 0 (|subs_pos?1-1| NIL 3808750008 ("" (INDUCT "args") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "pos?" -2) (("2" (PROP) (("1" (EXPAND "pos?" 1) (("1" (EXPAND "subs" 1 1) (("1" (PROP) (("1" (HIDE 2) (("1" (EXPAND "subs" 1 2) (("1" (LEMMA "subs_equal?") (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "pos?" 2) (("2" (EXPAND "subs" 2 1) (("2" (PROP) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL) ("4" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK))("substitution" |substitution| |subs_remove_common| 0 (|subs_remove_common-1| NIL 3808749735 ("" (INDUCT "args1") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "subs" 1 1) (("2" (EXPAND "remove_common" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "remove_common" 1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK))("list" |map_theory| |get_lst_mult_flatten_map| 0 (|get_lst_mult_flatten_map-1| NIL 3808912421 ("" (INDUCT "l1") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_lst_mult" 1 1) (("2" (LEMMA "map_append2") (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |list_theory| |get_lst_mult_flatten_map| 0 (|get_lst_mult_flatten_map-1| NIL 3808913096 ("" (INDUCT "lst") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_lst_mult" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "get_lst_mult" 1) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REWRITE "map_append") (("2" (REWRITE "flatten_append") (("2" (EXPAND "map" 2 3) (("2" (EXPAND "flatten" 2 3) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |more_list_theory_props| |flatten_map_get_repeat_lst| 0 (|flatten_map_get_repeat_lst-1| NIL 3808938875 ("" (INDUCT "n") (("1" (SKEEP) (("1" (EXPAND "get_repeat_lst" 1 1) (("1" (EXPAND "map" 1) (("1" (EXPAND "flatten") (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (EXPAND "get_repeat_lst" 1 1) (("2" (EXPAND "map" 1) (("2" (EXPAND "flatten" 1) (("2" (EXPAND "get_repeat_lst" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |more_list_theory_props| |flatten_map_get_lst_mult| 0 (|flatten_map_get_lst_mult-1| NIL 3808932184 ("" (INDUCT "lst") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_lst_mult" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (REWRITE "map_append") (("2" (REWRITE "flatten_append") (("2" (EXPAND "map" 2 3) (("2" (EXPAND "flatten" 2 3) (("2" (EXPAND "glm_aux" 2) (("2" (ASSERT) (("2" (REWRITE "get_lst_mult_append") (("1" (INST? -1) (("1" (REPLACE -1 2) (("1" (POSTPONE) NIL NIL)) NIL)) NIL) ("2" (REWRITE "get_repeat_lst_len") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("terms" |term_properties| |get_args_get_ac_from_args_gt1| 0 (|get_args_get_ac_from_args_gt1-1| NIL 3808946197 ("" (INDUCT "lst_args") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("args_" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_ac_from_args_gt1" 1) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |more_list_theory_props| |glm_aux_TCC1| 0 (|glm_aux_TCC1-1| NIL 3808932158 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|glm_aux| SUBTYPE "more_list_theory_props.coef" "(list_adt[nat].cons?)")))("list" |more_list_theory_props| |glm_aux_TCC2| 0 (|glm_aux_TCC2-1| NIL 3808932158 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|glm_aux| SUBTYPE "more_list_theory_props.lst" "(list_adt[more_list_theory_props.T].cons?)")))("list" |more_list_theory_props| |glm_aux_TCC3| 0 (|glm_aux_TCC3-1| NIL 3808932158 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|glm_aux| TERMINATION "more_list_theory_props.glm_aux(more_list_theory_props.g, list_adt[more_list_theory_props.T].cdr(more_list_theory_props.lst), list_adt[nat].cdr(more_list_theory_props.coef))" "NIL")))("list" |more_list_theory_props| |glm_aux_TCC4| 0 (|glm_aux_TCC4-1| NIL 3808932158 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|glm_aux| SUBTYPE "more_list_theory_props.lst" "(list_adt[more_list_theory_props.T].cons?)")))("list" |more_list_theory_props| |get_lst_mult_0| 0 (|get_lst_mult_0-1| NIL 3808945461 ("" (INDUCT "lst" 1) (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_repeat_lst" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (EXPAND "get_lst_mult" 2) (("2" (EXPAND "get_repeat_lst" 2 1) (("2" (INST? -1) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (NIL NIL NIL NIL NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (T FORMAL-TYPE-DECL NIL |more_list_theory_props| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|get_repeat_lst| DEF-DECL "list[T]" |list_theory| NIL) (|get_lst_mult| DEF-DECL "list[T]" |list_theory| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NIL NIL NIL NIL NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL)) SHOSTAK))("list" |more_list_theory_props| |count_get_lst_mult_get_repeat_lst| 0 (|count_get_lst_mult_get_repeat_lst-1| NIL 3808944527 ("" (INDUCT "lst" 1) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_repeat_lst" 1 1) (("2" (LIFT-IF) (("2" (EXPAND "length" 1 1) (("2" (ASSERT) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (HIDE 1) (("2" (EXPAND "get_lst_mult" 1 1) (("2" (REWRITE "count_append") (("1" (EXPAND "get_repeat_lst" 1 3) (("1" (LIFT-IF) (("1" (PROP) (("1" (GRIND) NIL NIL) ("2" (HIDE 1) (("2" (EXPAND "length" 1) (("2" (EXPAND "get_lst_mult" 1 2) (("2" (REWRITE "count_append") (("2" (EXPAND "get_repeat_lst" 1 2) (("2" (INST? -1) (("2" (EXPAND "count" 1 3) (("2" (LIFT-IF) (("2" (PROP) (("1" (REPLACE -2 1) (("1" (ASSERT) (("1" (EXPAND "count" 1 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 2) (("2" (ASSERT) (("2" (EXPAND "count" 2 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|count_append| FORMULA-DECL NIL |list_theory| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (T FORMAL-TYPE-DECL NIL |more_list_theory_props| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|get_repeat_lst| DEF-DECL "list[T]" |list_theory| NIL) (|get_lst_mult| DEF-DECL "list[T]" |list_theory| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NIL NIL NIL NIL NIL) (NIL NIL NIL NIL NIL) (|equiv| TYPE-EQ-DECL NIL |list_theory| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|equiv| TYPE-EQ-DECL NIL |more_list_theory_props| NIL) (|equivalence?| CONST-DECL "bool" |relations| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL)) SHOSTAK))("list" |more_list_theory_props| |count_flatten_map_get_repeat_lst| 0 (|count_flatten_map_get_repeat_lst-1| NIL 3808942700 ("" (INDUCT "n") (("1" (SKEEP) (("1" (REWRITE "get_lst_mult_0") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (EXPAND "get_repeat_lst" 1 1) (("2" (EXPAND "map" 1) (("2" (EXPAND "flatten" 1) (("2" (REWRITE "count_append" 1) (("2" (INST? -1) (("2" (REPLACE -1 1) (("2" (HIDE -1) (("2" (LEMMA "count_get_lst_mult_get_repeat_lst") (("2" (INST? -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (T FORMAL-TYPE-DECL NIL |more_list_theory_props| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|equivalence?| CONST-DECL "bool" |relations| NIL) (|equiv| TYPE-EQ-DECL NIL |more_list_theory_props| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|equiv| TYPE-EQ-DECL NIL |list_theory| NIL) (NIL NIL NIL NIL NIL) (|flatten| DEF-DECL "list[T]" |list_theory| NIL) (NIL NIL NIL NIL NIL) (|get_repeat_lst| DEF-DECL "list[T]" |list_theory| NIL) (NIL NIL NIL NIL NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|get_lst_mult| DEF-DECL "list[T]" |list_theory| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|get_lst_mult_0| FORMULA-DECL NIL |more_list_theory_props| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|count_append| FORMULA-DECL NIL |list_theory| NIL) (|count_get_lst_mult_get_repeat_lst| FORMULA-DECL NIL |more_list_theory_props| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) SHOSTAK))("list" |more_list_theory_props| |count_flatten_map_get_lst_mult| 0 (|count_flatten_map_get_lst_mult-1| NIL 3808941694 ("" (INDUCT "lst") (("1" (SKEEP) (("1" (EXPAND "get_lst_mult" 1 1) (("1" (EXPAND "map" 1) (("1" (EXPAND "flatten" 1) (("1" (EXPAND "glm_aux" 1) (("1" (EXPAND "get_lst_mult" 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (HIDE -1) (("2" (SKEEP) (("2" (EXPAND "get_lst_mult" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "glm_aux" 1) (("1" (ASSERT) (("1" (EXPAND "get_lst_mult" 1) (("1" (EXPAND "map") (("1" (EXPAND "flatten" 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "map_append") (("2" (REWRITE "flatten_append") (("2" (REWRITE "count_append") (("2" (EXPAND "map" 2 3) (("2" (EXPAND "flatten" 2 3) (("2" (EXPAND "glm_aux") (("2" (ASSERT) (("2" (REVEAL -1) (("2" (INST? -1) (("2" (REWRITE "get_lst_mult_append") (("1" (REWRITE "count_append" 2) (("1" (REPLACE -1 2) (("1" (ASSERT) (("1" (LEMMA "count_flatten_map_get_repeat_lst") (("1" (INST? -1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3 -1) (("2" (REWRITE "get_repeat_lst_len") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (NIL NIL NIL NIL NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|equivalence?| CONST-DECL "bool" |relations| NIL) (|equiv| TYPE-EQ-DECL NIL |more_list_theory_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|equiv| TYPE-EQ-DECL NIL |list_theory| NIL) (NIL NIL NIL NIL NIL) (|flatten| DEF-DECL "list[T]" |list_theory| NIL) (NIL NIL NIL NIL NIL) (|get_lst_mult| DEF-DECL "list[T]" |list_theory| NIL) (|glm_aux| DEF-DECL "list[nat]" |more_list_theory_props| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (T FORMAL-TYPE-DECL NIL |more_list_theory_props| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|get_repeat_lst| DEF-DECL "list[T]" |list_theory| NIL) (|map_append| FORMULA-DECL NIL |more_map_props| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|count_append| FORMULA-DECL NIL |list_theory| NIL) (|get_repeat_lst_len| FORMULA-DECL NIL |list_theory| NIL) (|count_flatten_map_get_repeat_lst| FORMULA-DECL NIL |more_list_theory_props| NIL) (|get_lst_mult_append| FORMULA-DECL NIL |list_theory| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|flatten_append| FORMULA-DECL NIL |list_theory| NIL)) SHOSTAK))("terms" |term_properties| |get_ac_from_args_gt1_TCC1| 0 (|get_ac_from_args_gt1_TCC1-1| NIL 3808946196 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| SUBTYPE "term_properties.lst_args" "(list_adt[args].cons?)")))("terms" |term_properties| |get_ac_from_args_gt1_TCC2| 0 (|get_ac_from_args_gt1_TCC2-1| NIL 3808946196 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| TERMINATION "term_properties.get_ac_from_args_gt1(term_properties.sym)(list_adt[args].cdr(term_properties.lst_args))" "NIL")))("terms" |term_properties| |get_ac_from_args_gt1_TCC3| 0 (|get_ac_from_args_gt1_TCC3-1| NIL 3808946196 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| SUBTYPE "term_properties.lst_args" "(list_adt[args].cons?)")))("terms" |term_properties| |get_ac_from_args_gt1_TCC4| 0 (|get_ac_from_args_gt1_TCC4-1| NIL 3808946196 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| TERMINATION "term_properties.get_ac_from_args_gt1(term_properties.sym)(list_adt[args].cdr(term_properties.lst_args))" "NIL")))("terms" |term_properties| |get_ac_from_args_gt1_TCC5| 0 (|get_ac_from_args_gt1_TCC5-1| NIL 3808946196 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| SUBTYPE "term_properties.lst_args" "(list_adt[args].cons?)")))("terms" |term_properties| |get_ac_from_args_gt1_TCC6| 0 (|get_ac_from_args_gt1_TCC6-1| NIL 3809092427 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| TERMINATION "term_properties.get_ac_from_args_gt1(term_properties.sym)(list_adt[args].cdr(term_properties.lst_args))" "NIL")))("terms" |term_properties| |get_ac_from_args_gt1_TCC7| 0 (|get_ac_from_args_gt1_TCC7-1| NIL 3809092427 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|get_ac_from_args_gt1| SUBTYPE "term_properties.lst_args" "(list_adt[args].cons?)")))("terms" |term_properties| |get_ac_from_args_gt1_len| 0 (|get_ac_from_args_gt1_len-1| NIL 3809092446 ("" (INDUCT "lst_args") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|string| TYPE-EQ-DECL NIL |strings| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|constant| TYPE-EQ-DECL NIL |term_properties| NIL) (|variable| TYPE-EQ-DECL NIL |term_properties| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|map| ADT-DEF-DECL "list[T1]" |list_adt_map| NIL) (|get_ac_from_args| CONST-DECL "term" |term_properties| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|character| TYPE-DECL NIL |character_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|char?| ADT-RECOGNIZER-DECL "[character -> boolean]" |character_adt| NIL) (|char| TYPE-EQ-DECL NIL |strings| NIL) (|f_symbol| TYPE-EQ-DECL NIL |term_properties| NIL) (|ac_symbol| TYPE-EQ-DECL NIL |term_properties| NIL) (|term| TYPE-DECL NIL |term_adt| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|every| ADT-DEF-DECL "boolean" |term_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|args| TYPE-EQ-DECL NIL |term_properties| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) SHOSTAK))("terms" |term_properties| |count_args_get_ac_from_args| 0 (|count_args_get_ac_from_args-1| NIL 3809105575 ("" (SKEEP) (("" (EXPAND "get_ac_from_args" 2) (("" (REWRITE "get_args_ac") (("" (LEMMA "get_args_get_term_from_args") (("" (INST? -1) (("" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("terms" |term_properties| |get_ac_from_args_gt_len| 0 (|get_ac_from_args_gt_len-1| NIL 3809109934 ("" (POSTPONE) NIL NIL) NIL SHOSTAK))("aux_unification" |aux_unification| |split_get_pre_new_args_TCC1| 0 (|split_get_pre_new_args_TCC1-1| NIL 3809114009 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|split_get_pre_new_args| SUBTYPE "list_theory[numbers.number].split_matrix(aux_unification.dio_matrix, aux_unification.n)`1" "dio_matrix")))("list" |list_theory| |from_min2max_TCC1| 0 (|from_min2max_TCC1-1| NIL 3804618454 ("" (TCC) NIL NIL) NIL SHOSTAK (|from_min2max| SUBTYPE "real_defs.max(0, (number_fields.-)(list_theory.max, list_theory.min))" "naturalnumber")))("list" |list_theory| |from_min2max_TCC2| 0 (|from_min2max_TCC2-1| NIL 3804618454 ("" (TCC)) NIL NIL (|from_min2max| TERMINATION "list_theory.from_min2max((number_fields.+)(list_theory.min, 1), list_theory.max)" "NIL")))("list" |list_theory| |from_min2max_len| 0 (|from_min2max_len-1| NIL 3805753437 ("" (MEASURE-INDUCT "max(0, n-i + 1)" ("i" "n")) (("1" (SKOLEM 1 ("i" "n")) (("1" (PROP) (("1" (EXPAND "from_min2max" 1) (("1" (LIFT-IF) (("1" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND "length" 2 1) (("2" (INST -1 "1+i" "n") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL) NIL SHOSTAK))("list" |list_nat_theory| |from_min2max_len| 0 (|from_min2max_len-1| NIL 3809117242 ("" (POSTPONE) NIL NIL) NIL SHOSTAK))("list" |list_theory| |increment_TCC1| 0 (|increment_TCC1-1| NIL 3803367839 ("" (TCC)) NIL NIL (|increment| SUBTYPE "list_theory.lst_nat" "(list_adt[numfield].cons?)")))("list" |list_theory| |increment_TCC2| 0 (|increment_TCC2-1| NIL 3803367839 ("" (TCC)) NIL NIL (|increment| SUBTYPE "list_adt[numfield].cdr(list_theory.lst_nat)" "list[nat]")))("list" |list_theory| |increment_TCC3| 0 (|increment_TCC3-1| NIL 3803367839 ("" (TCC)) NIL NIL (|increment| SUBTYPE "list_theory.lst_nat" "(list_adt[nat].cons?)")))("list" |list_theory| |increment_TCC4| 0 (|increment_TCC4-1| NIL 3803367839 ("" (TCC)) NIL SHOSTAK (|increment| SUBTYPE "(number_fields.-)(list_theory.n, 1)" "nat")))("list" |list_theory| |increment_TCC5| 0 (|increment_TCC5-1| NIL 3803367839 ("" (TCC)) NIL NIL (|increment| TERMINATION "list_theory.increment(list_adt[nat].cdr(list_theory.lst_nat), (number_fields.-)(list_theory.n, 1), list_theory.inc)" "NIL")))("list" |list_theory| |increment_TCC6| 0 (|increment_TCC6-1| NIL 3804618454 ("" (TCC)) NIL NIL (|increment| SUBTYPE "list_theory.lst_nat" "(list_adt[nat].cons?)")))("list" |list_theory| |dot_product_TCC1| 0 (|dot_product_TCC1-1| NIL 3809081564 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|dot_product| SUBTYPE "list_theory.lst_nat1" "(list_adt[nat].cons?)")))("list" |list_theory| |dot_product_TCC2| 0 (|dot_product_TCC2-1| NIL 3809081564 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|dot_product| SUBTYPE "list_theory.lst_nat2" "(list_adt[nat].cons?)")))("list" |list_theory| |dot_product_TCC3| 0 (|dot_product_TCC3-1| NIL 3809081564 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|dot_product| TERMINATION "list_theory.dot_product(list_adt[nat].cdr(list_theory.lst_nat1), list_adt[nat].cdr(list_theory.lst_nat2))" "NIL")))("list" |list_theory| |sum_TCC1| 0 (|sum_TCC1-1| NIL 3808579200 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|sum| SUBTYPE "(number_fields.-)(list_theory.i, 1)" "nat")))("list" |list_theory| |sum_ind| 0 (|sum_ind-1| NIL 3808591657 ("" (INDUCT "coef") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "sum" 1 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (ASSERT) NIL NIL) ("2" (EXPAND "sum" 2 2) (("2" (ASSERT) (("2" (INST -1 "i-1" "n-1") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |list_theory| |sum_ind2| 0 (|sum_ind2-1| NIL 3808591896 ("" (INDUCT "coef") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "sum" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (EXPAND "sum" 2 1) (("2" (INST? -1) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("list" |list_theory| |get_lst_mult_len| 0 (|get_lst_mult_len-1| NIL 3808591645 ("" (INDUCT "lst") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("hd" "tail")) (("2" (PROP) (("2" (SKEEP) (("2" (EXPAND "get_lst_mult" 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (GRIND) NIL NIL) ("2" (REWRITE "length_append" 2) (("2" (EXPAND "length" 2 3) (("2" (EXPAND "length" 2 4) (("2" (ASSERT) (("2" (EXPAND "sum" 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -2 1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 1) (("2" (REWRITE "get_repeat_lst_len" 1) (("2" (ASSERT) (("2" (CASE "min(1 + length[T](tail), 1 + length[nat](cdr(coef))) - 1 = min(length(tail), length(cdr(coef)))") (("1" (REPLACE -1 1) (("1" (INST? -2) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK))("aux_unification" |aux_unification| |add_new_arg_split_TCC1| 0 (|add_new_arg_split_TCC1-1| NIL 3809202400 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|add_new_arg_split| SUBTYPE "list_theory[numbers.number].split(aux_unification.row, aux_unification.n)`1" "list[nat]")))("list" |list_nat_theory| |from_min2max_TCC1| 0 (|from_min2max_TCC1-1| NIL 3809117203 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|from_min2max| SUBTYPE "real_defs.max(0, (number_fields.-)(list_nat_theory.max, list_nat_theory.min))" "naturalnumber")))("list" |list_nat_theory| |from_min2max_TCC2| 0 (|from_min2max_TCC2-1| NIL 3809117203 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|from_min2max| TERMINATION "list_nat_theory.from_min2max((number_fields.+)(list_nat_theory.min, 1), list_nat_theory.max)" "NIL")))("list" |list_nat_theory| |increment_TCC1| 0 (|increment_TCC1-1| NIL 3809183868 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|increment| SUBTYPE "list_nat_theory.lst_nat" "(list_adt[numfield].cons?)")))("list" |list_nat_theory| |increment_TCC2| 0 (|increment_TCC2-1| NIL 3809183868 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|increment| SUBTYPE "list_adt[numfield].cdr(list_nat_theory.lst_nat)" "list[nat]")))("list" |list_nat_theory| |increment_TCC3| 0 (|increment_TCC3-1| NIL 3809183868 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|increment| SUBTYPE "list_nat_theory.lst_nat" "(list_adt[nat].cons?)")))("list" |list_nat_theory| |increment_TCC4| 0 (|increment_TCC4-1| NIL 3809183868 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|increment| SUBTYPE "(number_fields.-)(list_nat_theory.n, 1)" "nat")))("list" |list_nat_theory| |increment_TCC5| 0 (|increment_TCC5-1| NIL 3809183868 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|increment| TERMINATION "list_nat_theory.increment(list_adt[nat].cdr(list_nat_theory.lst_nat), (number_fields.-)(list_nat_theory.n, 1), list_nat_theory.inc)" "NIL")))("list" |list_nat_theory| |increment_TCC6| 0 (|increment_TCC6-1| NIL 3809183868 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|increment| SUBTYPE "list_nat_theory.lst_nat" "(list_adt[nat].cons?)")))("list" |list_theory| |dot_product_TCC1| 0 (|dot_product_TCC2-1| NIL 3809081564 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|dot_product| SUBTYPE "list_theory.lst_nat2" "(list_adt[nat].cons?)")))("list" |list_theory| |dot_product_TCC2| 0 (|dot_product_TCC3-1| NIL 3809081564 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|dot_product| TERMINATION "list_theory.dot_product(list_adt[nat].cdr(list_theory.lst_nat1), list_adt[nat].cdr(list_theory.lst_nat2))" "NIL")))("aux_unification" |aux_unification| |apply_elimvar_TCC1| 0 (|apply_elimvar_TCC1-1| NIL 3804667940 ("" (TCC)) ((|elimvar| CONST-DECL "[sub, unif_prb]" |aux_unification| NIL)) NIL (|apply_elimvar| SUBTYPE "aux_unification.ac_sol_lst" "(list_adt[unification.unif_prb].cons?)")))("aux_unification" |aux_unification| |apply_elimvar_TCC2| 0 (|apply_elimvar_TCC2-1| NIL 3804667940 ("" (TCC)) ((|elimvar| CONST-DECL "[sub, unif_prb]" |aux_unification| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL (|apply_elimvar| TERMINATION "aux_unification.apply_elimvar(list_adt[unification.unif_prb].cdr(aux_unification.ac_sol_lst))" "NIL")))("aux_unification" |aux_unification| |apply_elimvar_TCC3| 0 (|apply_elimvar_TCC3-1| NIL 3804667940 ("" (TCC)) NIL NIL (|apply_elimvar| SUBTYPE "aux_unification.ac_sol_lst" "(list_adt[unification.unif_prb].cons?)")))("substitution" substitution subs_pos?1_TCC1 0 (subs_pos?1_TCC1-1 nil 3808750007 ("" (subtype-tcc) nil nil) nil nil (subs_pos?1 SUBTYPE "equality.equal?" "equiv[term[constant, variable, f_symbol, ac_symbol]]")))("substitution" substitution subs_pos?1 0 (subs_pos?1-1 nil 3808750008 ("" (induct "args") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "pos?" -2) (("2" (prop) (("1" (expand "pos?" 1) (("1" (expand "subs" 1 1) (("1" (prop) (("1" (hide 2) (("1" (expand "subs" 1 2) (("1" (lemma "subs_equal?") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pos?" 2) (("2" (expand "subs" 2 1) (("2" (prop) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil SHOSTAK))("substitution" substitution subs_remove_common 0 (subs_remove_common-1 nil 3808749735 ("" (induct "args1") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "subs" 1 1) (("2" (expand "remove_common" 1 2) (("2" (lift-if) (("2" (prop) (("1" (expand "remove_common" 1 1) (("1" (lift-if) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil SHOSTAK))("aux_unification" aux_unification apply_elimvar_TCC1 0 (apply_elimvar_TCC1-1 nil 3804667940 ("" (tcc)) ((elimvar const-decl "[sub, unif_prb]" aux_unification)) nil (apply_elimvar SUBTYPE "aux_unification.ac_sol_lst" "(list_adt[unification.unif_prb].cons?)")))("aux_unification" aux_unification apply_elimvar_TCC2 0 (apply_elimvar_TCC2-1 nil 3804667940 ("" (tcc)) ((elimvar const-decl "[sub, unif_prb]" aux_unification) (<< adt-def-decl "(strict_well_founded?[list])" list_adt)) nil (apply_elimvar TERMINATION "aux_unification.apply_elimvar(list_adt[unification.unif_prb].cdr(aux_unification.ac_sol_lst))" "NIL")))("aux_unification" aux_unification apply_elimvar_TCC3 0 (apply_elimvar_TCC3-1 nil 3804667940 ("" (tcc)) nil nil (apply_elimvar SUBTYPE "aux_unification.ac_sol_lst" "(list_adt[unification.unif_prb].cons?)")))("terms" term_properties size_TCC1 "" (tcc))("terms" term_properties size_TCC2 "" (tcc))("terms" term_properties size_TCC3 "" (tcc))("terms" term_properties size_TCC4 "" (tcc))("terms" term_properties size_TCC5 "" (tcc))("terms" term_properties vars_TCC1 "" (termination-tcc) nil nil)("terms" term_properties vars_TCC2 "" (termination-tcc) nil nil)("terms" term_properties size_TCC6 "" (subtype-tcc) nil nil)("terms" term_properties size_TCC7 "" (termination-tcc) nil nil)("terms" term_properties size_TCC8 "" (subtype-tcc) nil nil)("terms" term_properties num_arg_TCC1 "" (tcc))("terms" term_properties num_arg_TCC2 "" (tcc))("terms" term_properties num_arg_TCC3 "" (tcc))("terms" term_properties select_TCC1 "" (subtype-tcc) nil nil)("terms" term_properties delete_TCC2 "" (subtype-tcc) nil nil)("terms" term_properties delete_TCC3 "" (skeep) (("" (skeep) (("" (grind) nil nil)) nil)) nil)("terms" term_properties nice_ind?_TCC1 "" (subtype-tcc) nil nil)("terms" term_properties nice_ind?_TCC2 "" (termination-tcc) nil nil)("terms" term_properties get_term_from_args_TCC1 "" (tcc))("terms" term_properties all_var?_TCC1 "" (termination-tcc) nil nil)("terms" term_properties all_var?_TCC2 "" (subtype-tcc) nil nil)("terms" term_properties all_var?_TCC3 "" (termination-tcc) nil nil)("terms" term_properties gt_select_delete2_TCC1 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC3 "" (termination-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC4 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC5 "" (termination-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC6 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC7 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC8 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC1 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC2 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC3 "" (subtype-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC4 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC5 "" (subtype-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC6 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC7 "" (subtype-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC8 "" (subtype-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC9 "" (termination-tcc) nil nil)("termination_alg" termination_alg get_ops_above_vars_TCC10 "" (subtype-tcc) nil nil)("termination_alg" termination_alg vars_under2more_TCC1 "" (termination-tcc) nil nil)("termination_alg" termination_alg vars_under2more_TCC2 "" (termination-tcc) nil nil)("termination_alg" termination_alg vars_not_ac_TCC1 0 (vars_not_ac_TCC1-1 nil 3819316174 ("" (termination-tcc) nil nil) nil shostak (vars_not_ac termination "termination_alg.vars_not_ac(termination_alg.unif_prb)" "nil")))("termination_alg" termination_alg add_ops_TCC2 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC3 "" (tcc))("termination_alg" termination_alg add_ops_TCC4 "" (tcc))("termination_alg" termination_alg add_ops_TCC5 "" (tcc))("termination_alg" termination_alg add_ops_TCC6 "" (tcc))("termination_alg" termination_alg add_ops_TCC7 "" (tcc))("termination_alg" termination_alg add_ops_TCC8 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC1 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC2 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC3 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC4 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC5 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC6 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC7 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC8 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC9 "" (tcc))("termination_alg" termination_alg get_ops_above_vars_TCC10 "" (tcc))("termination_alg" termination_alg vars_under2more_TCC1 "" (tcc))("termination_alg" termination_alg vars_under2more_TCC2 "" (tcc))("termination_alg" termination_alg prop_subterms_TCC1 0 (prop_subterms_TCC1-1 nil 3819316174 ("" (subtype-tcc) nil nil) nil shostak (prop_subterms subtype "list2set[finite_set[term[constant, variable, f_symbol, ac_symbol]]].list2set(list_adt_map[term[constant, variable, f_symbol, ac_symbol], finite_set[term[constant, variable, f_symbol, ac_symbol]]].map(termination_alg.subterms, term_properties.get_args(termination_alg.sym)(termination_alg.t)))" "setofsets[term[constant, variable, f_symbol, ac_symbol]]")))("termination_alg" termination_alg prop_subterms_TCC2 0 (prop_subterms_TCC2-1 nil 3819316174 ("" (subtype-tcc) nil nil) nil shostak (prop_subterms subtype "sets[term[constant, variable, f_symbol, ac_symbol]].Union(list2set[finite_set[term[constant, variable, f_symbol, ac_symbol]]].list2set(list_adt_map[term[constant, variable, f_symbol, ac_symbol], finite_set[term[constant, variable, f_symbol, ac_symbol]]].map(termination_alg.subterms, term_properties.get_args(termination_alg.sym)(termination_alg.t))))" "finite_set[term[constant, variable, f_symbol, ac_symbol]]")))("terms" term_properties subterms_TCC1 "" (termination-tcc) nil nil)("terms" term_properties subterms_TCC2 "" (termination-tcc) nil nil)("terms" term_properties subterms_TCC3 "" (termination-tcc) nil nil)("termination_alg" termination_alg subterms_TCC1 0 (subterms_TCC2-1 nil 3819316174 ("" (skeep) (("" (lemma "every_nth[term]") (("" (inst? -1) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak (subterms termination-subtype "term_properties.get_args(termination_alg.sym)(termination_alg.t)" "[{z: term_adt[constant, variable, f_symbol, ac_symbol].term | term_adt[constant, variable, f_symbol, ac_symbol].<<(z, termination_alg.t)} -> finite_set[term[constant, variable, f_symbol, ac_symbol]]]")))("termination_alg" termination_alg subterms_TCC2 0 (subterms_TCC1-1 nil 3819316174 ("" (termination-tcc) nil nil) nil shostak (subterms termination-subtype "list2set[finite_set[term[constant, variable, f_symbol, ac_symbol]]].list2set(list_adt_map[{z: term_adt[constant, variable, f_symbol, ac_symbol].term | term_adt[constant, variable, f_symbol, ac_symbol].<<(z, termination_alg.t)}, finite_set[term[constant, variable, f_symbol, ac_symbol]]].map(LAMBDA (x: {z: term_adt[constant, variable, f_symbol, ac_symbol].term | term_adt[constant, variable, f_symbol, ac_symbol].<<(z, termination_alg.t)}): termination_alg.subterms(x))(term_properties.get_args(termination_alg.sym)(termination_alg.t)))" "[{z: term_adt[constant, variable, f_symbol, ac_symbol].term | term_adt[constant, variable, f_symbol, ac_symbol].<<(z, termination_alg.t)} -> finite_set[term[constant, variable, f_symbol, ac_symbol]]]")))("termination_alg" termination_alg add_ops_TCC2 "" (tcc))("list" list_theory snd_proj_TCC1 0 (snd_proj_TCC1-1 nil 3805569188 ("" (tcc)) nil nil (snd_proj subtype "list_theory.lst_pair" "(list_adt[[list_theory.T, list_theory.T]].cons?)")))("list" list_theory snd_proj_TCC2 0 (snd_proj_TCC2-1 nil 3805569188 ("" (tcc)) nil nil (snd_proj termination "list_theory.snd_proj(list_adt[[list_theory.T, list_theory.T]].cdr(list_theory.lst_pair))" "nil")))("list" list_theory snd_proj_TCC3 0 (snd_proj_TCC3-1 nil 3805569188 ("" (tcc)) nil nil (snd_proj subtype "list_theory.lst_pair" "(list_adt[[list_theory.T, list_theory.T]].cons?)")))("aux_unification" aux_unification construct_input_lst_TCC1 0 (construct_input_lst_TCC1-1 nil 3804667940 ("" (tcc)) ((construct_input const-decl "[unif_prb, sub, set[variable]]" aux_unification) (list2set def-decl "set[T]" list2set) (finite_emptyset name-judgement "finite_set" finite_sets) (variable type-eq-decl nil term_properties) (int nonempty-type-eq-decl nil integers) (>= const-decl "bool" reals) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (AND const-decl "[bool, bool -> bool]" booleans) nil (list type-decl nil list_adt) (PRED type-eq-decl nil defined_types) (number nonempty-type-decl nil numbers) (NOT const-decl "[bool -> bool]" booleans) (bool nonempty-type-eq-decl nil booleans) (boolean nonempty-type-decl nil booleans)) nil (construct_input_lst SUBTYPE "aux_unification.ac_sol_simp_lst" "(list_adt[[substitution.sub, unification.unif_prb]].cons?)")))("aux_unification" aux_unification construct_input_lst_TCC2 0 (construct_input_lst_TCC2-1 nil 3804667940 ("" (tcc)) ((construct_input const-decl "[unif_prb, sub, set[variable]]" aux_unification) (list2set def-decl "set[T]" list2set) (<< adt-def-decl "(strict_well_founded?[list])" list_adt) (finite_emptyset name-judgement "finite_set" finite_sets) (variable type-eq-decl nil term_properties) (int nonempty-type-eq-decl nil integers) (>= const-decl "bool" reals) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (AND const-decl "[bool, bool -> bool]" booleans) nil (list type-decl nil list_adt) (PRED type-eq-decl nil defined_types) (number nonempty-type-decl nil numbers) (NOT const-decl "[bool -> bool]" booleans) (bool nonempty-type-eq-decl nil booleans) (boolean nonempty-type-decl nil booleans)) nil (construct_input_lst TERMINATION "aux_unification.construct_input_lst(list_adt[[substitution.sub, unification.unif_prb]].cdr(aux_unification.ac_sol_simp_lst), aux_unification.unif_prb, aux_unification.sigma, aux_unification.vars2avoid)" "NIL")))("aux_unification" aux_unification construct_input_lst_TCC3 0 (construct_input_lst_TCC3-1 nil 3804667940 ("" (tcc)) nil nil (construct_input_lst SUBTYPE "aux_unification.ac_sol_simp_lst" "(list_adt[[substitution.sub, unification.unif_prb]].cons?)")))("unification" unification unifies?_TCC2 0 (unifies?_TCC2-1 nil 3805034332 ("" (termination-tcc) nil nil) ((unifies? const-decl "bool" unification) (<< adt-def-decl "(strict_well_founded?[list])" list_adt)) nil))("unification" unification unifies?_TCC3 0 (unifies?_TCC3-1 nil 3805034332 ("" (subtype-tcc) nil nil) nil nil))("terms" term_properties vars_TCC1 "" (tcc))("terms" term_properties vars_TCC2 "" (tcc))("terms" term_properties vars_TCC3 "" (subtype-tcc) nil nil)("terms" term_properties size_TCC6 "" (tcc))("terms" term_properties size_TCC7 "" (tcc))("terms" term_properties size_TCC8 "" (tcc))("terms" term_properties select_TCC1 "" (tcc))("terms" term_properties delete_TCC2 "" (tcc))("terms" term_properties delete_TCC3 "" (tcc))("terms" term_properties nice_ind?_TCC1 "" (tcc))("terms" term_properties nice_ind?_TCC2 "" (tcc))("terms" term_properties all_var?_TCC1 "" (tcc))("terms" term_properties all_var?_TCC2 "" (tcc))("terms" term_properties all_var?_TCC3 "" (tcc))("terms" term_properties not_var_args_TCC1 "" (termination-tcc) nil nil)("terms" term_properties not_var_args_TCC2 "" (termination-tcc) nil nil)("terms" term_properties gt_select_delete2_TCC1 "" (tcc))("substitution" substitution supset_img_TCC1 0 (supset_img_TCC1-1 nil 3823269770 ("" (termination-tcc) nil nil) nil nil (supset_img termination "substitution.supset_img(list_adt[basic_sub].cdr(substitution.sigma))" "nil")))("substitution" substitution supset_dom_supset_img 0 (supset_dom_supset_img-1 nil 3823271005 ("" (induct "sigma") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "supset_dom" -2) (("2" (expand "member" -2) (("2" (expand "add" -2) (("2" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution supset_img_correct 0 (supset_img_correct-1 nil 3823269782 ("" (skeep) (("" (skeep) (("" (case "member(X, supset_dom(sigma))") (("1" (hide -2) (("1" (lemma "supset_dom_supset_img") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "supset_dom_correct2") (("2" (inst? -1) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((supset_dom def-decl "finite_set[variable]" substitution nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (basic_sub type-eq-decl nil substitution nil) (constant type-eq-decl nil term_properties nil) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (variable type-eq-decl nil term_properties nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (supset_dom_supset_img formula-decl nil substitution nil) (subset? const-decl "bool" sets nil) (supset_dom_correct2 formula-decl nil substitution nil)) shostak))("unification" unification unifies?_TCC1 0 (unifies?_TCC1-1 nil 3805034332 ("" (subtype-tcc) nil nil) ((unifies? const-decl "bool" unification nil)) nil (unifies? termination "unification.unifies?(unification.sigma, list_adt[unif_pair].cdr(unification.unif_prb))" "nil")))("unification" unification apply_sub_TCC1 0 (apply_sub_TCC1-1 nil 3823281024 ("" (termination-tcc) nil nil) nil nil (apply_sub termination "unification.apply_sub(unification.sigma, list_adt[unif_pair].cdr(unification.unif_prb))" "nil")))("termination_alg" termination_alg vars_not_ac_TCC1 "" (termination-tcc) nil nil)("termination_alg" termination_alg vars_not_ac_TCC2 "" (termination-tcc) nil nil)("termination_alg" termination_alg vars_not_ac_TCC3 "" (termination-tcc) nil nil)("termination_alg" termination_alg vars_not_ac_TCC5 "" (subtype-tcc) nil nil)("termination_alg" termination_alg add_ops_TCC1 0 (add_ops_TCC1-1 nil 3819316174 ("" (skeep) (("" (skeep) (("" (replace -7 2) (("" (assert) nil nil)) nil)) nil)) nil) nil shostak (add_ops subtype "termination_alg.new_ops_above_var1" "ops_above_var")))("termination_alg" termination_alg add_ops_TCC2 0 (add_ops_TCC2-1 nil 3819316174 ("" (tcc)) ((injective? const-decl "bool" functions nil) (finite_union application-judgement "finite_set" finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (add_ops subtype "termination_alg.lst_ops_above_var2" "(list_adt[ops_above_var].cons?)")))("termination_alg" termination_alg add_ops_TCC3 0 (add_ops_TCC3-1 nil 3819316174 ("" (tcc)) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (add_ops termination "termination_alg.add_ops(termination_alg.new_ops_above_var1, list_adt[ops_above_var].cdr(termination_alg.lst_ops_above_var2))" "nil")))("termination_alg" termination_alg add_ops_TCC4 0 (add_ops_TCC4-1 nil 3819316174 ("" (tcc)) ((injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (add_ops subtype "termination_alg.lst_ops_above_var2" "(list_adt[ops_above_var].cons?)")))("termination_alg" termination_alg add_ops_TCC5 0 (add_ops_TCC5-1 nil 3819316174 ("" (tcc)) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (add_ops termination "termination_alg.add_ops(termination_alg.ops_above_var1, list_adt[ops_above_var].cdr(termination_alg.lst_ops_above_var2))" "nil")))("termination_alg" termination_alg add_ops_TCC6 0 (add_ops_TCC6-1 nil 3819316174 ("" (tcc)) nil nil (add_ops subtype "termination_alg.lst_ops_above_var2" "(list_adt[ops_above_var].cons?)")))("termination_alg" termination_alg add_ops_TCC7 0 (add_ops_TCC7-1 nil 3819316174 ("" (tcc)) nil nil (add_ops subtype "termination_alg.lst_ops_above_var1" "(list_adt[ops_above_var].cons?)")))("termination_alg" termination_alg add_ops_TCC8 0 (add_ops_TCC8-1 nil 3819316174 ("" (tcc)) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (add_ops termination "termination_alg.add_ops(list_adt[ops_above_var].cdr(termination_alg.lst_ops_above_var1), termination_alg.lst_ops_above_var2)" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC1 0 (get_ops_above_vars_TCC1-1 nil 3819316174 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil)) nil (get_ops_above_vars termination "termination_alg.get_ops_above_vars(termination_alg.t1, termination_alg.lst_ops)" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC2 0 (get_ops_above_vars_TCC2-1 nil 3819316174 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil)) nil (get_ops_above_vars termination "termination_alg.get_ops_above_vars(termination_alg.t2, termination_alg.lst_ops)" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC3 0 (get_ops_above_vars_TCC3-1 nil 3819316174 ("" (tcc)) ((list2set def-decl "set[T]" list2set nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil)) nil (get_ops_above_vars subtype "list2set[f_symbol].list2set(list_adt[f_symbol].cons(termination_alg.sym, list_adt[f_symbol].null))" "finite_set[string]")))("termination_alg" termination_alg get_ops_above_vars_TCC4 0 (get_ops_above_vars_TCC4-1 nil 3819316174 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil)) nil (get_ops_above_vars termination "termination_alg.get_ops_above_vars(termination_alg.arg, list2set[f_symbol].list2set(list_adt[f_symbol].cons(termination_alg.sym, list_adt[f_symbol].null)))" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC5 0 (get_ops_above_vars_TCC5-1 nil 3819316174 ("" (tcc)) ((list2set def-decl "set[T]" list2set nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil)) nil (get_ops_above_vars subtype "list2set[ac_symbol].list2set(list_adt[ac_symbol].cons(termination_alg.sym, list_adt[ac_symbol].null))" "finite_set[string]")))("termination_alg" termination_alg get_ops_above_vars_TCC6 0 (get_ops_above_vars_TCC6-1 nil 3819316174 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) (pair type-eq-decl nil term_adt nil) (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil)) nil (get_ops_above_vars termination "termination_alg.get_ops_above_vars(termination_alg.arg, list2set[ac_symbol].list2set(list_adt[ac_symbol].cons(termination_alg.sym, list_adt[ac_symbol].null)))" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC7 0 (get_ops_above_vars_TCC7-1 nil 3819316174 ("" (tcc)) ((list2set def-decl "set[T]" list2set nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (get_ops_above_vars subtype "list2set[string].list2set(list_adt[string].null)" "finite_set[string]")))("termination_alg" termination_alg get_ops_above_vars_TCC8 0 (get_ops_above_vars_TCC8-1 nil 3819316174 ("" (tcc)) nil nil (get_ops_above_vars subtype "termination_alg.unif_prb" "(list_adt[unif_pair].cons?)")))("termination_alg" termination_alg get_ops_above_vars_TCC9 0 (get_ops_above_vars_TCC9-1 nil 3819316174 ("" (tcc)) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (get_ops_above_vars termination "termination_alg.get_ops_above_vars(list_adt[unif_pair].cdr(termination_alg.unif_prb))" "nil")))("termination_alg" termination_alg get_ops_above_vars_TCC10 0 (get_ops_above_vars_TCC10-1 nil 3819316174 ("" (tcc)) nil nil (get_ops_above_vars subtype "termination_alg.unif_prb" "(list_adt[unif_pair].cons?)")))("list" list_theory member_union_lst2set 0 (member_union_lst2set-1 nil 3823447094 ("" (induct "lst_of_fin_sets") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "list2set" -2) (("2" (expand "Union" -2) (("2" (expand "member" -2) (("2" (skolem -2 "A") (("2" (typepred "A") (("2" (expand "add" -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("list" map_theory mem_union_map_TCC1 0 (mem_union_map_TCC1-1 nil 3823889074 ("" (subtype-tcc) nil nil) nil nil (mem_union_map subtype "map_theory.x" "(sets[map_theory.T2].singleton?)")))("terms" term_properties size_prop_subterm 0 (size_prop_subterm-1 nil 3823959807 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skeep) (("" (expand "prop_subterms" -2) (("" (lift-if) (("" (prop) (("1" (hide-all-but -2) (("1" (grind) nil nil)) nil) ("2" (hide-all-but -2) (("2" (grind) nil nil)) nil) ("3" (hide-all-but -2) (("3" (grind) nil nil)) nil) ("4" (hide 1 2 3) (("4" (expand "member" -2) (("4" (expand "union" -2) (("4" (prop) (("1" (inst -3 "term1(t)") (("1" (case "size(term1(t)) < size(t)") (("1" (prop) (("1" (inst -1 "s") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -3 "term2(t)") (("2" (case "size(term2(t)) < size(t)") (("1" (assert) (("1" (inst -4 "s") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 1 2 3 4) (("5" (hide -3) (("5" (postpone) nil nil)) nil)) nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification choose_not_ac 0 (choose_not_ac-1 nil 3823965678 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "choose_not_ac" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (expand "choose_not_ac" 3) (("2" (assert) (("2" (reveal -1) (("2" (inst -1 "cdr(unseen_unif_prb)") (("2" (prop) (("1" (inst -1 "cons(car(unseen_unif_prb), seen_unif_prb)" "unif_pair") (("1" (prop) (("1" (expand "member" -2) (("1" (prop) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "choose_not_ac" 4) (("3" (assert) (("3" (lemma "member_append[unif_pair]") (("3" (inst? -1) (("3" (assert) (("3" (prop) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification choose_not_ac_mem 0 (choose_not_ac_mem-1 nil 3824049624 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "choose_not_ac" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (expand "choose_not_ac" 3) (("2" (assert) (("2" (reveal -1) (("2" (inst -1 "cdr(unseen_unif_prb)") (("2" (prop) (("1" (inst -1 "cons(car(unseen_unif_prb), seen_unif_prb)" "unif_pair") (("1" (prop) (("1" (expand "member" -2) (("1" (prop) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "choose_not_ac" 4) (("3" (assert) (("3" (lemma "member_append[unif_pair]") (("3" (inst? -1) (("3" (assert) (("3" (prop) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil))("list" list_theory2 x_TCC1 0 (x_TCC1-1 nil 3821910421 ("" (existence-tcc) nil nil) nil nil (x existence "" "list_theory2.T1")))("list" map_theory func_flatten_map2 0 (func_flatten_map2-1 nil 3825089208 ("" (induct "lst_of_lsts") (("1" (skeep) (("1" (expand "map" 1) (("1" (expand "flatten" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "map" 1) (("2" (expand "flatten" 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg inst_step_vars_not_ac_aux 0 (inst_step_vars_not_ac_aux-1 nil 3825075354 ("" (postpone) nil nil) nil shostak))("termination_alg" termination_alg vars_not_ac_var_apply_sub_t_TCC1 0 (vars_not_ac_var_apply_sub_t_TCC1-1 nil 3825429194 ("" (subtype-tcc) nil nil) nil nil (vars_not_ac_var_apply_sub_t subtype "substitution.img(termination_alg.sigma)" "(sets[term[constant, variable, f_symbol, ac_symbol]].singleton?)")))("substitution" substitution subs_im_under? 0 (subs_im_under?-1 nil 3825514291 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (hide -1) (("" (skeep) (("" (lemma "term_opt") (("" (inst -1 "t") (("" (prop) (("1" (replace -1 -2) (("1" (rewrite "subs_const" -2) (("1" (hide -1) (("1" (expand "im_under?" -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "member(V(t), dom(sigma))") (("1" (inst 1 "subs(sigma)(t)") (("1" (split 1) (("1" (flatten) (("1" (expand "member" 1) (("1" (expand "img" 1) (("1" (inst 1 "V(t)") (("1" (assert) (("1" (expand "subs" 1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (inst 2 "t") (("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (flatten) (("2" (expand "subs" -1) (("2" (replace -2 -1 :dir rl) (("2" (replace -1 -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (replace -1 -2) (("3" (rewrite "subs_unit") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (replace -1 -2) (("4" (rewrite "subs_pair") (("4" (hide -1) (("4" (expand "im_under?" -1) (("4" (expand "im_under" -1) (("4" (expand "member" -1) (("4" (expand "union" -1) (("4" (prop) (("1" (reveal -3) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg vars_not_ac_var_apply_sub_t 0 (vars_not_ac_var_apply_sub_t-2 "" 3825454954 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (expand "vars_not_ac_var" -1) (("" (expand "member" -1 1) (("" (skolem -1 "ti_sigma") (("" (flatten) (("" (lemma "subs_subterm_mem") (("" (inst? -1) (("" (assert) (("" (skolem -1 "ti") (("" (hide -2) (("" (flatten) (("" (replace -2 -3) (("" (lemma "subs_im_under?") (("" (inst? -1) (("" (assert) (("" (skolem -1 "s") (("" (prop) (("1" (expand "union" 2) (("1" (expand "member" 2 1) (("1" (prop) (("1" (expand "vars_not_ac_var" 3) (("1" (expand "member" 3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (vars_not_ac_var_apply_sub_t-1 nil 3825429236 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (lemma "term_opt") (("" (inst? -1) (("" (prop) (("1" (expand "vars_not_ac_var" -3) (("1" (expand "member" -3 1) (("1" (skeep) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "subs_const") (("1" (expand "subterms" -2) (("1" (expand "member" -2) (("1" (expand "singleton") (("1" (replace -2 -3) (("1" (expand "im_under?" -3) (("1" (hide-all-but -3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -3) (("2" (case "member(V(t), dom(sigma))") (("1" (name-replace "t_sigma" "subs(sigma)(variable(V(t)))") (("1" (expand "member" 1) (("1" (expand "union" 1) (("1" (flatten) (("1" (expand "member" 1) (("1" (expand "member" -4) (("1" (expand "vars_not_ac_var" -4) (("1" (skolem -4 "t1") (("1" (expand "vars_not_ac_var" 1) (("1" (inst 1 "t1") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (assert) (("2" (flatten) (("2" (expand "subs" -1) (("2" (replace -1 -4) (("2" (hide -1) (("2" (replace -1 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1 -3) (("3" (rewrite "subs_unit") (("3" (expand "member" -3) (("3" (expand "vars_not_ac_var" -3) (("3" (skeep) (("3" (expand "subterms" -3) (("3" (expand "member" -3) (("3" (expand "singleton" -3) (("3" (replace -3) (("3" (expand "im_under?" -4) (("3" (hide-all-but -4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -1 -3) (("4" (rewrite "subs_pair") (("4" (expand "vars_not_ac_var" -3) (("4" (expand "member" -3 1) (("4" (skolem -3 "s") (("4" (flatten) (("4" (expand "subterms" -3) (("4" (expand "member" -3) (("4" (expand "union" -3) (("4" (prop) (("1" (inst -3 "term1(t)") (("1" (prop) (("1" (inst -1 "sigma") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (expand "union" -1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "member" 2) (("2" (expand "union" 2) (("2" (flatten) (("2" (hide 2) (("2" (hide -2 -3 -4 1) (("2" (expand "member" -1) (("2" (expand "vars_not_ac_var" -1) (("2" (skolem -1 "s1") (("2" (expand "vars_not_ac_var" 1) (("2" (expand "member" 1 1) (("2" (inst 1 "s1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "vars_not_ac_var" 1) (("2" (inst 1 "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -3 "term2(t)") (("2" (prop) (("1" (inst -1 "sigma") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (prop) (("1" (expand "member" -1) (("1" (expand "union" -1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -2 -3 -4 1) (("2" (expand "union" 1) (("2" (expand "member" 1 1) (("2" (prop) (("2" (expand "vars_not_ac_var" -1) (("2" (expand "member" -1 1) (("2" (skolem -1 s1) (("2" (expand "vars_not_ac_var" 2) (("2" (expand "member" 2 1) (("2" (inst 2 "s1") (("2" (flatten) (("2" (assert) (("2" (reveal -2) (("2" (expand "subterms" 3) (("2" (assert) (("2" (expand "union" 3) (("2" (expand "member" 3 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_not_ac_var" 1 1) (("2" (expand "member" 1) (("2" (inst 1 "s") (("2" (assert) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replace -1 -3) (("5" (rewrite "subs_app") (("5" (expand "vars_not_ac_var" -3) (("5" (expand "member" -3 1) (("5" (skolem -3 "s") (("5" (flatten) (("5" (expand "subterms" -3) (("5" (expand "member" -3) (("5" (expand "union" -3) (("5" (prop) (("1" (expand "singleton" -1) (("1" (expand "member" -1) (("1" (hide -2) (("1" (expand "im_under?" -3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (replace -1 -3) (("6" (rewrite "subs_ac") (("6" (expand "vars_not_ac_var" -3) (("6" (expand "member" -3 1) (("6" (skolem -3 "s") (("6" (flatten) (("6" (expand "subterms" -3) (("6" (assert) (("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution subs_singleton_TCC1 0 (subs_singleton_TCC1-1 nil 3825698796 ("" (subtype-tcc) nil nil) nil nil (subs_singleton subtype "substitution.subs(substitution.sigma)(sets[term[constant, variable, f_symbol, ac_symbol]].singleton(substitution.t))" "(sets[term[constant, variable, f_symbol, ac_symbol]].singleton?)")))("substitution" substitution subs_subterm_t 0 (subs_subterm_t-1 nil 3825695318 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skeep) (("" (expand "subterms" 1 2) (("" (lift-if) (("" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution subs_subterm_arg 0 (subs_subterm_arg-1 nil 3825699944 ("" (induct "args") (("1" (skeep) (("1" (expand "subs" 1 1) (("1" (expand "subterms" 1) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "subs" 1 1) (("2" (expand "subterms" 1 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution subs_subterm_mem 0 (subs_subterm_mem-1 nil 3825700887 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skeep) (("" (lemma "term_opt") (("" (inst -1 "t") (("" (prop) (("1" (replace -1 -3) (("1" (rewrite "subs_const") (("1" (expand "subterms" -3) (("1" (expand "member" -3) (("1" (expand "singleton" -3) (("1" (inst 1 "t") (("1" (prop) (("1" (replace -1 1) (("1" (expand "member" 1) (("1" (expand "subterms" 1) (("1" (expand "singleton" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (rewrite "subs_const") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "t") (("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg vars_not_ac_solve_ac 0 (vars_not_ac_solve_ac-1 nil 3825758610 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("terms" term_properties not_var_args_TCC1 0 (not_var_args_TCC1-1 nil 3819455914 ("" (termination-tcc) nil nil) nil nil (not_var_args termination "term_properties.not_var_args(list_adt[term[constant, variable, f_symbol, ac_symbol]].cdr(term_properties.args))" "nil")))("terms" term_properties not_var_args_TCC2 0 (not_var_args_TCC2-1 nil 3819455914 ("" (termination-tcc) nil nil) nil nil (not_var_args termination "term_properties.not_var_args(list_adt[term[constant, variable, f_symbol, ac_symbol]].cdr(term_properties.args))" "nil")))("termination_alg" termination_alg vars_not_ac_var_inst_step2_TCC1 0 (vars_not_ac_var_inst_step2_TCC1-1 nil 3825784395 ("" (subtype-tcc) nil nil) nil nil (vars_not_ac_var_inst_step2 subtype "list2set[term[constant, variable, f_symbol, ac_symbol]].list2set(list_theory2[term[constant, variable, f_symbol, ac_symbol], term[constant, variable, f_symbol, ac_symbol]].sec_proj(termination_alg.unif_prb1))" "finite_set[term[constant, variable, f_symbol, ac_symbol]]")))("termination_alg" termination_alg vars_not_ac_var_inst_step2_TCC2 0 (vars_not_ac_var_inst_step2_TCC2-1 nil 3825784395 ("" (subtype-tcc) nil nil) nil nil (vars_not_ac_var_inst_step2 subtype "list2set[term[constant, variable, f_symbol, ac_symbol]].list2set(list_theory2[term[constant, variable, f_symbol, ac_symbol], term[constant, variable, f_symbol, ac_symbol]].first_proj(termination_alg.unif_prb1))" "finite_set[term[constant, variable, f_symbol, ac_symbol]]")))("termination_alg" termination_alg vars_not_ac_var_inst_step2 0 (vars_not_ac_var_inst_step2-1 nil 3825784436 ("" (measure-induct "length(unif_prb1)" "unif_prb1") (("" (skolem 1 "unif_prb1") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "instantiate_step" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (rewrite "card_union") (("1" (assert) (("1" (lemma "card_intersection_le[variable]") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(unif_prb1)`1") (("1" (name-replace "s" "car(unif_prb1)`2") (("1" (name-replace "delta" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split 2) (("1" (flatten) (("1" (expand "vars_not_ac" 1 1) (("1" (rewrite "card_emptyset") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -6) (("1" (inst -1 "cdr(unif_prb1)") (("1" (prop) (("1" (inst? -1) (("1" (assert) (("1" (case "card(union(union(vars_not_ac_var(sec_proj(cdr(unif_prb1))),
                        vars_not_ac_var(first_proj(cdr(unif_prb1)))),
                  vars_not_ac(cons((t, s), unif_prb2)))) <= card(union(union(vars_not_ac_var(sec_proj(unif_prb1)),
                        vars_not_ac_var(first_proj(unif_prb1))),
                  vars_not_ac(unif_prb2)))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "card_subset[variable]") (("2" (inst? -1) (("2" (assert) (("2" (hide 2) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (reveal -6) (("2" (inst -1 "apply_sub(delta, cdr(unif_prb1))") (("2" (prop) (("1" (inst -1 "append(delta, sigma)" "apply_sub(delta, unif_prb2)") (("1" (case "card(union(union(vars_not_ac_var(sec_proj
                                        (apply_sub
                                         (delta, cdr(unif_prb1)))),
                        vars_not_ac_var(first_proj
                                        (apply_sub
                                         (delta, cdr(unif_prb1))))),
                  vars_not_ac(apply_sub(delta, unif_prb2)))) <= 
card(union(union(vars_not_ac_var(sec_proj(unif_prb1)),
                        vars_not_ac_var(first_proj(unif_prb1))),
                  vars_not_ac(unif_prb2)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg apply_ac_step_vars_not_ac_aux 0 (apply_ac_step_vars_not_ac_aux-1 nil 3825152152 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (lemma "vars_not_ac_var_inst_step") (("" (inst? -1) (("" (expand "subset?" -1) (("" (inst -1 "x") (("" (assert) (("" (expand "member" -1) (("" (expand "union" -1 1) (("" (expand "member" 1) (("" (expand "union" 1 1) (("" (flatten) (("" (prop) (("1" (expand "member" -1) (("1" (expand "union" -1) (("1" (prop) (("1" (lemma "vars_not_ac_var_solve_ac") (("1" (inst? -1) (("1" (assert) (("1" (replace -1 -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_solve_ac") (("2" (inst? -1) (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (basic_sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (sub type-eq-decl nil substitution nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (member const-decl "bool" sets nil) (string type-eq-decl nil strings nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (union const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (vars_not_ac_var_inst_step formula-decl nil termination_alg nil) (subset? const-decl "bool" sets nil)) shostak))("list" list_theory surj_2_ind_fun_TCC1 0 (surj_2_ind_fun_TCC1-1 nil 3826481491 ("" (subtype-tcc) nil nil) nil nil (surj_2_ind_fun subtype "list_theory.sing" "(sets[list_theory.T].nonempty?)")))("list" list_theory card_inj_surj 0 (card_inj_surj-1 nil 3826406103 ("" (skeep) (("" (skeep) (("" (expand "injective?" 1) (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("substitution" substitution img_append 0 (img_append-1 nil 3827502756 ("" (skeep) (("" (expand "subset?" 1) (("" (skolem 1 "t") (("" (prop) (("" (expand "member" -1) (("" (expand "img" -1) (("" (skeep) (("" (lemma "dom_append") (("" (inst? -1) (("" (expand "subset?" -1) (("" (inst -1 "X") (("" (assert) (("" (expand "member" 1) (("" (expand "union" 1) (("" (prop) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("substitution" substitution mem_get_args_subs 0 (mem_get_args_subs-1 nil 3827507676 ("" (skeep) (("" (prop) (("1" (expand "get_args" -1) (("1" (lemma "map_member4[nat, term]") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "n") (("1" (flatten) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) nil shostak))("substitution" substitution apply_sub_elim_var_t 0 (apply_sub_elim_var_t-1 nil 3827590809 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (rewrite "subs_const") (("1" (hide-all-but -2) (("1" (grind) nil))))))))) ("2" (skolem 1 "Y") (("2" (skeep) (("2" (case "X = Y") (("1" (replace -1) (("1" (hide -1) (("1" (expand "img" 1) (("1" (lemma "vars_correct") (("1" (inst? -1) (("1" (inst -1 "subs(sigma)(variable(Y))") (("1" (assert) (("1" (hide 2) (("1" (expand "member" 1) (("1" (inst 1 "Y") (("1" (expand "member" -1) (("1" (assert) (("1" (expand "subs" 1 1) (("1" (propax) nil))))))))))))))))) ("2" (hide 2) (("2" (lemma "img_TCC1") (("2" (inst? -1) nil))))))))))))))) ("2" (lemma "vars_correct") (("2" (inst -1 "X" "img(sigma)" "subs(sigma)(variable(Y))") (("2" (assert) (("2" (hide 3) (("2" (expand "img" 1) (("2" (expand "member" 1) (("2" (inst 1 "Y") (("2" (expand "subs" 1 1) (("2" (expand "dom" 1) (("2" (assert) (("2" (expand "subs" 1 1) (("2" (assert) (("2" (expand "/=") (("2" (replace -1 -3) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))))))))))))))))))) ("3" (skeep) (("3" (hide-all-but -2) (("3" (rewrite "subs_unit") (("3" (grind) nil))))))) ("4" (skolem 1 ("t1" "t2")) (("4" (prop) (("4" (skeep) (("4" (rewrite "subs_pair") (("4" (expand "vars" -4) (("4" (expand "member" -4) (("4" (expand "union" -4) (("4" (prop) (("1" (hide -3) (("1" (grind) nil))) ("2" (hide -2) (("2" (grind) nil))))))))))))))))))) ("5" (skolem 1 ("f" "arg")) (("5" (prop) (("5" (skeep) (("5" (rewrite "subs_app") (("5" (expand "vars" -3) (("5" (inst? -1) (("5" (grind) nil))))))))))))) ("6" (skolem 1 ("f" "arg")) (("6" (prop) (("6" (skeep) (("6" (rewrite "subs_ac") (("6" (expand "vars" -3) (("6" (inst? -1) (("6" (assert) nil)))))))))))))) nil) nil nil))("unification" unification apply_sub_elim_var_t 0 (apply_sub_elim_var_t-1 nil 3823282112 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (rewrite "subs_const") (("1" (hide-all-but -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "Y") (("2" (skeep) (("2" (case "X = Y") (("1" (replace -1) (("1" (hide -1) (("1" (expand "img" 1) (("1" (lemma "vars_correct") (("1" (inst? -1) (("1" (inst -1 "subs(sigma)(variable(Y))") (("1" (assert) (("1" (hide 2) (("1" (expand "member" 1) (("1" (inst 1 "Y") (("1" (expand "member" -1) (("1" (assert) (("1" (expand "subs" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "img_TCC1") (("2" (inst? -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_correct") (("2" (inst -1 "X" "img(sigma)" "subs(sigma)(variable(Y))") (("2" (assert) (("2" (hide 3) (("2" (expand "img" 1) (("2" (expand "member" 1) (("2" (inst 1 "Y") (("2" (expand "subs" 1 1) (("2" (expand "dom" 1) (("2" (assert) (("2" (expand "subs" 1 1) (("2" (assert) (("2" (expand "/=") (("2" (replace -1 -3) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but -2) (("3" (rewrite "subs_unit") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (skolem 1 ("t1" "t2")) (("4" (prop) (("4" (skeep) (("4" (rewrite "subs_pair") (("4" (expand "vars" -4) (("4" (expand "member" -4) (("4" (expand "union" -4) (("4" (prop) (("1" (hide -3) (("1" (grind) nil nil)) nil) ("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skolem 1 ("f" "arg")) (("5" (prop) (("5" (skeep) (("5" (rewrite "subs_app") (("5" (expand "vars" -3) (("5" (inst? -1) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skolem 1 ("f" "arg")) (("6" (prop) (("6" (skeep) (("6" (rewrite "subs_ac") (("6" (expand "vars" -3) (("6" (inst? -1) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (basic_sub type-eq-decl nil substitution nil) (list type-decl nil list_adt nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (dom const-decl "finite_set[variable]" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (term_induction formula-decl nil term_adt nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (subs_const formula-decl nil substitution nil) (/= const-decl "boolean" notequal nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (subs const-decl "term" substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (img_TCC1 subtype-tcc nil substitution nil) (vars_correct formula-decl nil term_properties nil) (= const-decl "[T, T -> boolean]" equalities nil) (subs_unit formula-decl nil substitution nil) (subs_pair formula-decl nil substitution nil) (empty? const-decl "bool" sets nil) (union const-decl "set" sets nil) (subs_app formula-decl nil substitution nil) (pair type-eq-decl nil term_adt nil) (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subs_ac formula-decl nil substitution nil)) shostak))("termination_alg" termination_alg vars_not_ac_subterms 0 (vars_not_ac_subterms-1 nil 3827842738 ("" (measure-induct "size(t)" "t") (("" (skolem 1 "t") (("" (prop) (("" (skeep) (("" (lemma "term_opt") (("" (inst? -1) (("" (prop) (("1" (hide -2 1) (("1" (grind) nil nil)) nil) ("2" (hide -2) (("2" (grind) nil nil)) nil) ("3" (hide -2) (("3" (grind) nil nil)) nil) ("4" (expand "vars_not_ac" 1) (("4" (assert) (("4" (replace -1 -4) (("4" (expand "subterms" -4) (("4" (expand "member" -4) (("4" (expand "union" -4) (("4" (prop) (("1" (inst -3 "term1(t)") (("1" (expand "union" 1) (("1" (expand "member" 1 1) (("1" (prop) (("1" (inst? -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (inst -3 "term2(t)") (("2" (prop) (("1" (inst? -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "subterms" -4) (("5" (assert) (("5" (expand "union" -4) (("5" (expand "member" -4 1) (("5" (prop) (("1" (hide -3 -2) (("1" (grind) nil nil)) nil) ("2" (inst -3 "arg(t)") (("2" (prop) (("1" (inst? -1) (("1" (assert) (("1" (expand "vars_not_ac" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "subterms" -4) (("6" (assert) (("6" (expand "member" -4) (("6" (expand "union" -4) (("6" (prop) (("1" (hide -2 -3) (("1" (grind) nil nil)) nil) ("2" (lemma "mem_union_map[term, term]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "ti") (("2" (prop) (("2" (inst -4 "ti") (("2" (prop) (("1" (inst? -1) (("1" (assert) (("1" (expand "vars_not_ac" 1) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg vars_not_ac_var_img_append 0 (vars_not_ac_var_img_append-1 nil 3828194727 ("" (skeep) (("" (expand "subset?" 1) (("" (skolem 1 "X") (("" (prop) (("" (expand "member" 1) (("" (expand "union" 1) (("" (prop) (("" (lemma "vars_not_ac_var_finset") (("" (inst? -1) (("" (assert) (("" (skolem -1 "t") (("" (prop) (("" (hide -4) (("" (expand "img" -1) (("" (expand "member" -1 1) (("" (skolem -1 "Y") (("" (flatten) (("" (expand "subs" -2) (("" (rewrite "subs_append2") (("" (case "member(Y, dom(delta))") (("1" (name-replace "s" "subs(delta)(variable(Y))") (("1" (lemma "vars_not_ac_var_subs") (("1" (replace -4 -5 :dir rl) (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (skolem -1 "W") (("1" (prop) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg inst_step_vars_not_ac_var_sub_unif_prb 0 (inst_step_vars_not_ac_var_sub_unif_prb-1 nil 3827934488 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "instantiate_step" -1 1) (("" (lift-if) (("" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (name-replace "t" "car(unif_prb)`1") (("1" (name-replace "s" "car(unif_prb)`2") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (reveal -5) (("1" (inst -1 "cdr(unif_prb)") (("1" (prop) (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 4 "X") (("1" (assert) (("1" (prop) (("1" (expand "instantiate_step" 1 1) (("1" (reveal -2 -3 -4 -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -1) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 5 6) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 1 3 5) (("2" (grind) nil nil)) nil) ("3" (hide 2 4 5 6) (("3" (expand "disjoint?") (("3" (expand "empty?") (("3" (skeep) (("3" (inst -4 "x") (("3" (hide -3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "sigma1" "instantiate_step(t, s)`1") (("2" (reveal -6) (("2" (inst -1 "apply_sub(sigma1, cdr(unif_prb))") (("2" (prop) (("1" (inst? -1) (("1" (assert) (("1" (hide -2) (("1" (prop) (("1" (skeep) (("1" (lemma "vars_not_ac_var_subs_unif_prb") (("1" (inst -1 "X" "sigma1" "cdr(unif_prb)") (("1" (assert) (("1" (prop) (("1" (skolem -1 "W") (("1" (flatten) (("1" (case "W = Y") (("1" (replace -1) (("1" (hide -4 -5 -6 1 2 3 4 6 8) (("1" (grind) nil nil)) nil)) nil) ("2" (inst 7 "W") (("2" (prop) (("1" (expand "instantiate_step" 1) (("1" (lift-if) (("1" (reveal -4 -5 -6 -7 -8) (("1" (replace -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -2) (("1" (replace -1) (("1" (hide -1 -2 -3 -4 -5) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide 1 3 4 5 6) (("2" (lemma "instantiate_step_sub_append") (("2" (inst -1 "apply_sub(sigma1, unif_prb1)" "append(sigma1, delta)" "apply_sub(sigma1, cdr(unif_prb))") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (expand "subs" -3) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_no_effect_t") (("2" (inst? -1) (("2" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (expand "subs" -1) (("1" (replace -1 1) (("1" (case "member(X, vars(unif_prb))") (("1" (lemma "subs_no_effect_t") (("1" (inst -1 "delta" "variable(X)") (("1" (prop) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "subs_no_effect_t") (("1" (inst -1 "sigma1" "variable(X)") (("1" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide -1 -2 -3 -4 -6 2 3 4 6 7) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "tsigma") (("2" (flatten) (("2" (lemma "apply_sub_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t1") (("2" (flatten) (("2" (replace -2) (("2" (hide -3 -5) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand "intersection" -4) (("2" (expand "member" -4 1) (("2" (prop) (("2" (expand "vars" -5) (("2" (expand "member" -5) (("2" (expand "singleton" -5) (("2" (replace -5) (("2" (expand "member" -3) (("2" (expand "vars_not_ac_var" -3) (("2" (prop) (("2" (lemma "vars_not_ac_vars_t") (("2" (inst? -1) (("2" (assert) (("2" (hide -4) (("2" (lemma "apply_sub_elim_var_t") (("2" (inst? -1) (("2" (assert) (("2" (lemma "idempotent_disjoint_dom_img") (("2" (inst? -1) (("2" (prop) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "X") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "sigma1" 1) (("2" (lemma "instantiate_step_fail") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (reveal 5) (("2" (expand "fail1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 2 3 4 6 7) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -3 "x") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -5 2 3 4) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "t1") (("2" (flatten) (("2" (lemma "apply_sub_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide -3) (("2" (replace -2) (("2" (hide -2) (("2" (expand "vars_not_ac_var" -2) (("2" (expand "member" -2 1) (("2" (flatten) (("2" (lemma "vars_not_ac_vars_t") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (lemma "vars_subs_t") (("2" (inst? -1) (("2" (expand "subset?" -1) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "union" -1) (("2" (expand "member" -1 1) (("2" (prop) (("1" (expand "sigma1") (("1" (lemma "instantiate_step_img") (("1" (inst? -1) (("1" (prop) (("1" (replace -1 -2) (("1" (grind) nil nil)) nil) ("2" (replace -1 -2) (("2" (rewrite "vars_singleton") (("2" (reveal -26) (("2" (hide -2 -4 -5 1 4 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (rewrite "vars_singleton") (("3" (reveal -25) (("3" (hide -2 -4 -5 1 2 5 6) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 1 4 5) (("2" (lemma "vars_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 2 3 4 6 7) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -3 "x") (("2" (expand "member" -1) (("2" (expand "intersection" -1) (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "intersection" 2) (("2" (prop) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t1") (("2" (prop) (("2" (hide -5) (("2" (expand "vars_not_ac_var" -2) (("2" (expand "member" -2 1) (("2" (flatten) (("2" (lemma "vars_not_ac_vars_t") (("2" (inst -1 "W" "t1") (("2" (assert) (("2" (lemma "vars_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4 5 6 8 9) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst -1 "W" "cdr(unif_prb)") (("2" (assert) (("2" (skolem -1 "t2") (("2" (inst 1 "t2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 5 "X") (("2" (prop) (("1" (expand "instantiate_step" 1) (("1" (reveal -4 -5 -6 -7 -8) (("1" (replace -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -2) (("1" (replace -1) (("1" (hide -1 -2 -3 -4 -5) (("1" (lift-if) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (expand "sigma1") (("2" (reveal -10 -11) (("2" (lemma "instantiate_step_img") (("2" (inst? -1) (("2" (prop) (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (replace -1 -4) (("2" (lemma "vars_not_ac_var_finset") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t1") (("2" (flatten) (("2" (lemma "vars_not_ac_var_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t1") (("2" (hide -3 -4 2 3 4 5 7 8) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (hide -1 1 3 4 5 7 8) (("3" (lemma "vars_not_ac_var_finset") (("3" (inst? -1) (("3" (assert) (("3" (skolem -1 "s1") (("3" (flatten) (("3" (lemma "vars_not_ac_var_unif_prb") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "s1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 5 "X") (("3" (prop) (("1" (expand "instantiate_step" 1) (("1" (reveal -4 -5 -6 -7 -8) (("1" (replace -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -2) (("1" (replace -1) (("1" (hide -1 -2 -3 -4 -5) (("1" (lift-if) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_not_ac_var" 1) (("2" (hide -2 -3 -4 2 3 4 5 6 7) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (expand "sigma1") (("4" (lemma "instantiate_step_fail") (("4" (inst? -1) (("4" (assert) (("4" (assert) (("4" (expand "fail1") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (expand "disjoint?" 1) (("4" (expand "empty?" 1) (("4" (skeep) (("4" (expand "intersection" -1) (("4" (expand "member" -1 1) (("4" (prop) (("4" (lemma "dom_append") (("4" (inst? -1) (("4" (expand "subset?" -1) (("4" (inst -1 "x") (("4" (assert) (("4" (hide -2) (("4" (expand "union" -1) (("4" (expand "member" -1 1) (("4" (expand "disjoint?" -3) (("4" (case "idempotent?(sigma1)") (("1" (prop) (("1" (lemma "vars_unif_prb") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "tsigma1") (("1" (flatten) (("1" (hide -5) (("1" (lemma "apply_sub_mem") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "t1") (("1" (flatten) (("1" (hide -3) (("1" (replace -2) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst? -1) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst? -1) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (hide -2 -6 -7 2 3 5 6 7) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty?" -4) (("2" (inst -4 "x") (("2" (hide 5 6 7) (("2" (expand "member" 4) (("2" (expand "intersection" 4) (("2" (prop) (("2" (lemma "vars_unif_prb") (("2" (inst -1 "x" "apply_sub(sigma1, cdr(unif_prb))") (("2" (assert) (("2" (skolem -1 "tsigma1") (("2" (flatten) (("2" (lemma "apply_sub_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t1") (("2" (prop) (("2" (replace -2) (("2" (hide -2 -5 -7) (("2" (lemma "vars_subs_t") (("2" (inst? -1) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand "member" -1) (("2" (expand "union" -1) (("2" (prop) (("1" (expand "sigma1" -1) (("1" (lemma "instantiate_step_img") (("1" (inst? -1) (("1" (prop) (("1" (replace -1 -2) (("1" (grind) nil nil)) nil) ("2" (replace -1 -2) (("2" (hide -1 -3 -4 -5) (("2" (reveal -23) (("2" (lemma "vars_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t") (("2" (rewrite "vars_singleton") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1 -2) (("3" (rewrite "vars_singleton") (("3" (hide -1 -3 -4 -5 -6) (("3" (reveal -23) (("3" (lemma "vars_unif_prb") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "s") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sigma1") (("2" (lemma "instantiate_step_fail") (("2" (inst? -1) (("2" (assert) (("2" (assert) (("2" (expand "fail1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification instantiate_step1_append 0 (instantiate_step1_append-1 nil 3828296246 ("" (postpone) nil nil) nil shostak))("aux_unification" aux_unification instantiate_step1_sub 0 (instantiate_step1_sub-1 nil 3828299393 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "instantiate_step" 1 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(unif_prb)`1") (("1" (name-replace "s" "car(unif_prb)`2") (("1" (name-replace "delta" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split 2) (("1" (flatten) (("1" (expand "instantiate_step" 1) (("1" (reveal -5 -4 -3 -2 -1) (("1" (replace -5) (("1" (replace -4) (("1" (replace -3) (("1" (replace -2) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "instantiate_step" 1 2) (("1" (lift-if) (("1" (reveal -5 -4 -3 -2 -1) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replace -5) (("2" (replace -4) (("2" (replace -3) (("2" (replace -2) (("2" (replace -1) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (reveal -6) (("1" (inst -1 "cdr(unif_prb)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (reveal -6) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification instantiate_step1_sub_aux 0 (instantiate_step1_sub_aux-1 nil 3828300533 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (expand "instantiate_step" 1 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(unif_prb)`1") (("1" (name-replace "s" "car(unif_prb)`2") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (postpone) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification apply_ac_step_mem_unif_prb 0 (apply_ac_step_mem_unif_prb-1 nil 3830012761 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification mem_first_proj_solve_ac 0 (mem_first_proj_solve_ac-1 nil 3830021637 ("" (skeep) (("" (expand "solve_ac" -1) (("" (name-replace "args" "elim_com_arg(t1, t2, f)`1") (("" (name-replace "mult_t1" "elim_com_arg(t1, t2, f)`2") (("" (name-replace "mult_t2" "elim_com_arg(t1, t2, f)`3") (("" (name-replace "bound" "calculate_upper_bound(mult_t1, mult_t2)") (("" (name-replace "dio_sol_matrix" "dio_solver(mult_t1, mult_t2, bound)") (("" (name-replace "submatrix_sol_lst" "extract_submatrices(dio_sol_matrix, args)") (("" (name-replace "results" "map(dio_matrix2ac_sol(args, vars2avoid, f))(submatrix_sol_lst)") (("" (expand "results" -1) (("" (lemma "member_lst_unif_prb_equiv") (("" (inst? -1) (("" (assert) (("" (skolem -1 "unif_prb") (("" (prop) (("" (lemma "first_proj_mem[unif_prb, list[variable]]") (("" (inst? -1) (("" (assert) (("" (skolem -1 "ac_sol1") (("" (prop) (("" (lemma "map_member4[dio_matrix, ac_sol]") (("" (inst? -1) (("" (assert) (("" (skolem -1 "dio_matrix") (("" (hide -2) (("" (prop) (("" (expand "dio_matrix2ac_sol" -2) (("" (replace -2 -3) (("" (hide -2) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg apply_ac_step_vars_under2more 0 (apply_ac_step_vars_under2more-1 nil 3829344218 ("" (skeep) (("" (case "subset?(vars_under2more(unif_prb1), image(vars_not_ac_magic_fun(sigma), vars_under2more(unif_prb)))") (("1" (lemma "card_subset[variable]") (("1" (inst -1 "vars_under2more(unif_prb1)" "image(vars_not_ac_magic_fun(sigma), vars_under2more(unif_prb))") (("1" (assert) (("1" (lemma "card_image[variable, variable]") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "Y") (("2" (prop) (("2" (expand "vars_under2more" -1) (("2" (expand "member" -1 1) (("2" (skolem -1 ("t1" "s1")) (("2" (prop) (("2" (hide -6) (("2" (lemma "instantiate_step_mem") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (prop) (("2" (hide -9) (("2" (lemma "instantiate_step_im_under_subterm") (("2" (inst? -1) (("2" (inst -1 "unif_prb2") (("2" (assert) (("2" (replace -3 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (hide -1) (("2" (lemma "instantiate_step_im_under_subterm") (("2" (inst -1 "Y" "s1" "unif_prb2") (("2" (assert) (("2" (skolem -1 "s2") (("2" (reveal -1) (("2" (prop) (("1" (lemma "apply_ac_step_new_var") (("1" (inst -1 "Y" "t2" "unif_prb" "unif_prb2") (("1" (prop) (("1" (hide -4) (("1" (hide -10 -11 -12 -13 -14) (("1" (lemma "apply_ac_step_new_var") (("1" (inst -1 "Y" "s2" "unif_prb" "unif_prb2") (("1" (prop) (("1" (expand "member" 1) (("1" (expand "image") (("1" (inst 1 "Y") (("1" (expand "vars_not_ac_magic_fun" 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 -10 -11) (("1" (reveal -12 -14) (("1" (reveal -10) (("1" (replace -1) (("1" (hide -1) (("1" (reveal -10) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "subterms_mem_unif_prb") (("1" (inst -1 "t1" "unif_prb1") (("1" (assert) (("1" (skolem -1 "t_") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst -1 "Y" "t1" "t_") (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step1_mem") (("1" (inst -1 "t_" "unif_prb2") (("1" (assert) (("1" (reveal -14) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (skolem -2 "t_1") (("1" (prop) (("1" (replace -9 :dir rl) (("1" (replace -3) (("1" (hide -1 -2 -3 -5) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst? -1) (("1" (assert) (("1" (lemma "instantiate_step_sub") (("1" (reveal -29) (("1" (inst? -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst? -1) (("1" (assert) (("1" (hide -2 -4 -5 -6) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "im_under_var") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_under2more" 1) (("2" (inst 1 "t2" "s2") (("2" (prop) (("2" (hide -1 -2 -3 -4 -6 -8 -9 -10) (("2" (reveal -9) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4 -5 -6 -7 -8 -9) (("2" (hide 2) (("2" (lemma "subterms_mem_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t2_") (("2" (prop) (("2" (lemma "vars_unif_prb") (("2" (inst -1 "Y" "unif_prb") (("2" (assert) (("2" (inst 1 "t2_") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst -1 "Y" "t2" "t2_") (("2" (prop) (("2" (rewrite "im_under_var") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_vars_under2more_inst_step") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (prop) (("1" (hide -1 -2 2 3) (("1" (expand "member" 1) (("1" (expand "vars_under2more") (("1" (inst 1 "t1" "s1") (("1" (replace -6 :dir rl) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14) (("2" (hide 2 3) (("2" (lemma "subterms_mem_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "t2_") (("2" (prop) (("2" (lemma "vars_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "t2_") (("2" (prop) (("2" (lemma "vars_subterm") (("2" (inst? -1) (("2" (inst -1 "t2") (("2" (prop) (("2" (rewrite "im_under_var") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (replace -9 :dir rl) (("2" (skolem -1 "X") (("2" (prop) (("2" (case "idempotent?(sigma)") (("1" (hide -1 -10) (("1" (lemma "instantiate_step_apply_ac_step_im_under") (("1" (inst -1 "X" "Y" "unif_prb" "unif_prb2") (("1" (assert) (("1" (replace -10 :dir rl) (("1" (prop) (("1" (skolem -1 "t3") (("1" (case "same_func?(t2, t3)") (("1" (prop) (("1" (lemma "instantiate_step_apply_ac_step_im_under2") (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("terms" term_properties get_ac_from_args_TCC1 0 (get_ac_from_args_TCC1-1 nil 3819387232 ("" (subtype-tcc) nil nil) nil shostak (get_ac_from_args subtype "term_properties.get_term_from_args(term_properties.args)" "pair[constant, variable, f_symbol, string]")))("terms" term_properties get_args_ac_TCC1 0 (get_args_ac_TCC1-1 nil 3819387232 ("" (subtype-tcc) nil nil) nil shostak (get_args_ac subtype "term_properties.t" "pair[constant, variable, f_symbol, string]")))("terms" term_properties term_opt_TCC1 0 (term_opt_TCC1-1 nil 3825441259 ("" (subtype-tcc) nil nil) nil nil (term_opt subtype "term_properties.t" "(term_adt[constant, variable, f_symbol, ac_symbol].const?)")))("terms" term_properties term_opt_TCC2 0 (term_opt_TCC2-1 nil 3825441259 ("" (subtype-tcc) nil nil) nil nil (term_opt subtype "term_properties.t" "(term_adt[constant, variable, f_symbol, ac_symbol].var?)")))("terms" term_properties term_opt_TCC3 0 (term_opt_TCC3-1 nil 3825441259 ("" (subtype-tcc) nil nil) nil nil (term_opt subtype "term_properties.t" "pair[constant, variable, f_symbol, ac_symbol]")))("terms" term_properties term_opt_TCC4 0 (term_opt_TCC4-1 nil 3825441259 ("" (subtype-tcc) nil nil) nil nil (term_opt subtype "term_properties.t" "(term_adt[constant, variable, f_symbol, ac_symbol].app?)")))("terms" term_properties term_opt_TCC5 0 (term_opt_TCC5-1 nil 3825441259 ("" (subtype-tcc) nil nil) nil nil (term_opt subtype "term_properties.t" "(term_adt[constant, variable, f_symbol, ac_symbol].ac_app?)")))("terms" term_properties subterms_TCC1 0 (subterms_TCC1-1 nil 3819387232 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (size def-decl "nat" term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (subterms termination "term_properties.subterms(term_properties.t1)" "nil")))("terms" term_properties subterms_TCC2 0 (subterms_TCC2-1 nil 3819387232 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (size def-decl "nat" term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (subterms termination "term_properties.subterms(term_properties.t2)" "nil")))("terms" term_properties subterms_TCC3 0 (subterms_TCC3-1 nil 3819387232 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (size def-decl "nat" term_properties nil)) nil (subterms termination "term_properties.subterms(term_properties.arg)" "nil")))("terms" term_properties subterms_TCC4 0 (subterms_TCC4-1 nil 3819387232 ("" (skeep) (("" (lemma "every_nth[term[number, number, f_symbol, ac_symbol]]") (("" (inst? -1) (("" (assert) (("" (hide 2) (("" (skeep) (("" (lemma "get_args_nth") (("" (inst? -1) (("" (split -1) (("1" (replace -1 1) (("1" (prop) (("1" (lemma "subterms_aux_TCC") (("1" (inst? -1) nil nil)) nil) ("2" (lemma "ac_select_size") (("2" (inst? -1) (("2" (assert) (("2" (hide 2 -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "i") (("2" (rewrite "get_args_len") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (every_nth formula-decl nil list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (get_args_len formula-decl nil term_properties nil) (nice_ind? const-decl "bool" term_properties nil) (num_arg def-decl "nat" term_properties nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (ac_select_size formula-decl nil term_properties nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_ac_sym? const-decl "bool" term_properties nil) (subterms_aux_TCC formula-decl nil term_properties nil) (get_args_nth formula-decl nil term_properties nil) (get_args const-decl "args" term_properties nil) (args type-eq-decl nil term_properties nil) (every adt-def-decl "boolean" list_adt nil) (string type-eq-decl nil strings nil) (list type-decl nil list_adt nil) (size def-decl "nat" term_properties nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil)) shostak (subterms termination-subtype "term_properties.get_args(term_properties.sym)(term_properties.t)" "[{z: term_adt[constant, variable, f_symbol, ac_symbol].term | reals.<(term_properties.size(z), term_properties.size(term_properties.t))} -> finite_set[term[constant, variable, f_symbol, ac_symbol]]]")))("terms" term_properties lst_vars_TCC1 0 (lst_vars_TCC1-1 nil 3830461812 ("" (termination-tcc) nil nil) nil nil (lst_vars termination "term_properties.lst_vars(term_properties.t1)" "nil")))("terms" term_properties lst_vars_TCC2 0 (lst_vars_TCC2-1 nil 3830461812 ("" (termination-tcc) nil nil) nil nil (lst_vars termination "term_properties.lst_vars(term_properties.t2)" "nil")))("terms" term_properties lst_vars_TCC3 0 (lst_vars_TCC3-1 nil 3830461812 ("" (termination-tcc) nil nil) nil nil (lst_vars termination-subtype "term_properties.get_args(term_properties.sym)(term_properties.t)" "[{z: term_adt[constant, variable, f_symbol, ac_symbol].term | term_adt[constant, variable, f_symbol, ac_symbol].<<(z, term_properties.t)} -> list[variable]]")))("substitution" substitution subs_ac_TCC1 0 (subs_ac_TCC1-1 nil 3823268323 ("" (subtype-tcc) nil nil) nil nil (subs_ac subtype "substitution.arg" "pair[constant, variable, f_symbol, ac_symbol]")))("substitution" substitution subs_ac_TCC2 0 (subs_ac_TCC2-1 nil 3823268323 ("" (subtype-tcc) nil nil) nil nil (subs_ac subtype "substitution.subs(substitution.sigma)(substitution.arg)" "pair[constant, variable, f_symbol, ac_symbol]")))("unification" unification subterms_TCC1 0 (subterms_TCC2-1 nil 3825711568 ("" (termination-tcc) nil nil) nil nil (subterms termination "unification.subterms(list_adt[unification.unif_prb].cdr(unification.lst_unif_prb))" "nil")))("aux_unification" aux_unification solve_ac_vars_sec_proj_TCC1 0 (solve_ac_vars_sec_proj_TCC1-1 nil 3830681348 ("" (subtype-tcc) nil nil) nil nil (solve_ac_vars_sec_proj subtype "aux_unification.t" "(term_adt[constant, variable, f_symbol, ac_symbol].ac_app?)")))("aux_unification" aux_unification solve_ac_vars_sec_proj 0 (solve_ac_vars_sec_proj-1 nil 3830681348 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (expand "solve_ac" 1) (("" (name-replace "f" "ac_sym(t)") (("" (name-replace "args" "elim_com_arg(t, s, f)`1") (("" (name-replace "mult_t1" "elim_com_arg(t, s, f)`2") (("" (name-replace "mult_t2" "elim_com_arg(t, s, f)`3") (("" (name-replace "bound" "calculate_upper_bound(mult_t1, mult_t2)") (("" (name-replace "dio_sol_matrix" "dio_solver(mult_t1, mult_t2, bound)") (("" (name-replace "submatrix_sol_lst" "extract_submatrices(dio_sol_matrix, args)") (("" (name-replace "results" "map(dio_matrix2ac_sol(args, vars2avoid, f))(submatrix_sol_lst)") (("" (expand "results") (("" (lemma "vars_lst_lst_vars") (("" (inst? -1) (("" (assert) (("" (expand "map" 2) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (hide 2) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification apply_ac_step_TCC1 0 (apply_ac_step_TCC1-1 nil 3823964261 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (finite_union application-judgement "finite_set" finite_sets nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars const-decl "finite_set[variable]" unification nil) (injective? const-decl "bool" functions nil) (list type-decl nil list_adt nil) (get_args const-decl "args" term_properties nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (calculate_upper_bound const-decl "nat" diophantine nil) (number nonempty-type-decl nil numbers nil) (nonmatrix? const-decl "bool" list_theory nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)) nil (apply_ac_step subtype "aux_unification.unif_prb" "(list_adt[unif_pair].cons?)")))("aux_unification" aux_unification apply_ac_step_TCC2 0 (apply_ac_step_TCC2-1 nil 3823964261 ("" (termination-tcc) nil nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (union const-decl "set" sets nil) (vars const-decl "finite_set[variable]" unification nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (get_args const-decl "args" term_properties nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (cartesian_product_aux def-decl "list[[T, T]]" list_theory nil) (append def-decl "list[T]" list_props nil) (cartesian_product def-decl "list[[T, T]]" list_theory nil) (lcm const-decl "posnat" diophantine nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (select_greater def-decl "nat" list_theory nil) (max_lcm const-decl "nat" diophantine nil) (calculate_upper_bound const-decl "nat" diophantine nil) (matrix? const-decl "bool" list_theory nil) (nonmatrix? const-decl "bool" list_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (first_proj def-decl "list[T1]" list_theory2 nil) (sec_proj def-decl "list[T2]" list_theory2 nil)) nil (apply_ac_step termination "aux_unification.apply_ac_step(list_adt[unif_pair].cdr(aux_unification.unif_prb), aux_unification.new_set_vars2avoid)" "nil")))("aux_unification" aux_unification apply_ac_step_TCC3 0 (apply_ac_step_TCC3-1 nil 3823964261 ("" (subtype-tcc) nil nil) nil nil (apply_ac_step subtype "aux_unification.unif_prb" "(list_adt[unif_pair].cons?)")))("aux_unification" aux_unification apply_ac_step_mem 0 (apply_ac_step_mem-4 nil 3830694641 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (prop) nil nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_set_vars2avoid" "union(vars(ac_results_so_far), union(vars(unif_prb), set_vars2avoid))") (("2" (name-replace "vars2avoid" "finset2list[variable](cur_set_vars2avoid)") (("2" (name-replace "ac_results" "first_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (name-replace "new_set_vars2avoid" "union(cur_set_vars2avoid, vars(sec_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))))") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (hide -4) (("2" (lemma "first_proj_mem_flatten[unif_prb, finite_set[variable]]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "pair1") (("2" (prop) (("2" (hide -4) (("2" (lemma "map_member4[list[unif_prb],[list[unif_prb], finite_set[variable]]]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "lst_unif_prb") (("2" (prop) (("2" (hide -3) (("2" (reveal -14) (("2" (inst -1 "cdr(unif_prb)") (("2" (prop) (("1" (inst -1 "lst_unif_prb" "new_set_vars2avoid" "t1") (("1" (prop) (("1" (skeep) (("1" (inst 2 "t!1" "s!1" "vars2avoid!1" "f") (("1" (reveal -12 -13 -14) (("1" (assert) (("1" (hide -6 -7 -8 -9 -10 -11 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst -1 "lst_unif_prb" "t1") (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (hide -2) (("2" (prop) (("2" (lemma "put_in_head_mem3[unif_prb]") (("2" (inst? -1) (("2" (inst? -1) (("2" (assert) (("2" (prop) (("1" (expand "ac_results" -1 1) (("1" (inst 2 "t" "s" "vars2avoid" "ac_sym(t)") (("1" (prop) (("1" (hide-all-but 1) (("1" (reveal -24 -25) (("1" (grind) nil nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8) (("2" (reveal -23 -25) (("2" (grind) nil nil)) nil)) nil) ("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "unif_prb2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -2 :dir rl) (("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "unif_prb1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (first_proj def-decl "list[list[T1]]" list_theory2 nil) (flatten def-decl "list[T]" list_theory nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (put_in_head_mem3 formula-decl nil list_theory nil) (map_member4 formula-decl nil map_theory nil) (first_proj_mem_flatten formula-decl nil list_theory2 nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (union const-decl "set" sets nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (apply_ac_step def-decl "[list[unif_prb], finite_set[variable]]" aux_unification nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (apply_ac_step_mem-3 nil 3830613963 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (prop) nil nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_set_vars2avoid" "union(vars(ac_results_so_far), union(vars(unif_prb), set_vars2avoid))") (("2" (name-replace "vars2avoid" "finset2list[variable](cur_set_vars2avoid)") (("2" (name-replace "ac_results" "first_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (name-replace "new_ac_results_so_far" "put_in_head[unif_prb](ac_results, ac_results_so_far)") (("2" (name-replace "new_set_vars2avoid" "vars(sec_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t))))") (("2" (name-replace "results_part1" "flatten(first_proj[unif_prb, finite_set[variable]](map(apply_ac_step(cdr(unif_prb), new_set_vars2avoid))(new_ac_results_so_far)))") (("2" (expand "results_part1") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (hide -4) (("2" (lemma "first_proj_mem_flatten[unif_prb, finite_set[variable]]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "pair1") (("2" (prop) (("2" (hide -4) (("2" (lemma "map_member4[list[unif_prb],[list[unif_prb], finite_set[variable]]]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "lst_unif_prb") (("2" (prop) (("2" (reveal -15) (("2" (hide -4) (("2" (inst -1 "cdr(unif_prb)") (("2" (prop) (("1" (inst -1 "lst_unif_prb" "new_set_vars2avoid" "t1") (("1" (prop) (("1" (skeep) (("1" (inst 2 "t!1" "s!1" "vars2avoid!1" "f") (("1" (assert) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "new_ac_results_so_far") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (prop) (("2" (hide -3) (("2" (lemma "put_in_head_mem3[unif_prb]") (("2" (inst? -1) (("2" (inst -1 "unif_prb2") (("2" (assert) (("2" (prop) (("1" (lemma "member_lst_unif_prb_equiv") (("1" (inst -1 "ac_results" "t1") (("1" (flatten) (("1" (hide -1) (("1" (prop) (("1" (expand "ac_results" -1 1) (("1" (inst 2 "t" "s" "vars2avoid" "ac_sym(t)") (("1" (prop) (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 3) (("1" (reveal -28 -29) (("1" (grind) nil nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 3) (("2" (reveal -27 -29) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst -1 "ac_results_so_far" "t1") (("2" (assert) (("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (hide 2 4 5) (("3" (inst 1 "unif_prb1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (put_in_head_mem3 formula-decl nil list_theory nil) (map_member4 formula-decl nil map_theory nil) (first_proj_mem_flatten formula-decl nil list_theory2 nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (flatten def-decl "list[T]" list_theory nil) (first_proj def-decl "list[list[T1]]" list_theory2 nil) (finset2list def-decl "list[T]" list_theory nil)) nil) (apply_ac_step_mem-2 nil 3830613719 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (prop) nil nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_set_vars2avoid" "union(vars(ac_results_so_far), union(vars(unif_prb), set_vars2avoid))") (("2" (name-replace "vars2avoid" "finset2list[variable](cur_set_vars2avoid)") (("2" (name-replace "ac_results" "first_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (name-replace "new_ac_results_so_far" "put_in_head[unif_prb](ac_results, ac_results_so_far)") (("2" (name-replace "new_set_vars2avoid" "vars(sec_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t))))") (("2" (name-replace "results_part1" "flatten(first_proj[list[unif_prb], finite_set[variable]](map(apply_ac_step(cdr(unif_prb), new_set_vars2avoid))(new_ac_results_so_far)))") (("2" (expand "results_part1") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (hide -4) (("2" (lemma "first_proj_mem_flatten[unif_prb, finite_set[variable]]") (("2" (inst? -1) (("2" (assert) (("2" (inst -1 "unif_prb1") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (apply_ac_step_mem-1 nil 3827266786 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (prop) nil nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_set_vars2avoid" "union(vars(ac_results_so_far), union(vars(unif_prb), set_vars2avoid))") (("2" (name-replace "vars2avoid" "finset2list[variable](cur_set_vars2avoid)") (("2" (name-replace "ac_results" "first_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (name-replace "new_ac_results_so_far" "put_in_head[unif_prb](ac_results, ac_results_so_far)") (("2" (name-replace "new_set_vars2avoid" "vars(sec_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t))))") (("2" (name-replace "results_part1" "flatten(first_proj(map(apply_ac_step(cdr(unif_prb), new_set_vars2avoid))(new_ac_results_so_far)))") (("2" (expand "results_part1") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (hide -4) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (flatten def-decl "list[T]" list_theory nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (mem_flatten_map2 formula-decl nil map_theory nil) (put_in_head_mem3 formula-decl nil list_theory nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (lst_vars def-decl "list[variable]" unification nil)) shostak))("aux_unification" aux_unification apply_ac_step_mem2 0 (apply_ac_step_mem2-2 "" 3830028364 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (prop) nil nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_set_vars2avoid" "union(vars(ac_results_so_far), union(vars(unif_prb), set_vars2avoid))") (("2" (name-replace "vars2avoid" "finset2list[variable](cur_set_vars2avoid)") (("2" (name-replace "ac_results" "first_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (name-replace "new_set_vars2avoid" "union(cur_set_vars2avoid, vars(sec_proj[unif_prb, list[variable]](solve_ac(t, s, vars2avoid, ac_sym(t)))))") (("2" (name-replace "new_ac_results_so_far" "put_in_head[unif_prb](ac_results, ac_results_so_far)") (("2" (name-replace "results_part1" "flatten(first_proj[unif_prb, finite_set[variable]](map(apply_ac_step(cdr(unif_prb), new_set_vars2avoid))(new_ac_results_so_far)))") (("2" (expand "results_part1") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (lemma "first_proj_mem_flatten[unif_prb, finite_set[variable]]") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (skolem -1 "pair1") (("2" (prop) (("2" (lemma "map_member4[list[unif_prb],[list[unif_prb], finite_set[variable]]]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "lst_unif_prb") (("2" (prop) (("2" (reveal -16) (("2" (inst -1 "cdr(unif_prb)") (("2" (prop) (("1" (inst -1 "lst_unif_prb" "new_set_vars2avoid" "t1") (("1" (prop) (("1" (skeep) (("1" (inst 2 "t!1" "s!1" "vars2avoid!1" "f") (("1" (prop) (("1" (hide-all-but (-1 1 2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (expand "subset?" -2) (("3" (inst -2 "x") (("3" (assert) (("3" (hide 1) (("3" (expand "new_set_vars2avoid" 1) (("3" (expand "member" 1) (("3" (expand "union" 1 1) (("3" (prop) (("3" (hide 1) (("3" (expand "member" 1) (("3" (expand "union" 1 1) (("3" (prop) (("3" (hide 1) (("3" (expand "member" 1) (("3" (expand "union" 1) (("3" (prop) (("3" (hide 2) (("3" (expand "cur_set_vars2avoid") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst -1 "lst_unif_prb" "t1") (("2" (prop) (("2" (skolem -2 "unif_prb2") (("2" (hide -1) (("2" (prop) (("2" (hide -3) (("2" (expand "new_ac_results_so_far") (("2" (lemma "put_in_head_mem3[unif_prb]") (("2" (inst? -1) (("2" (inst? -1) (("2" (assert) (("2" (prop) (("1" (expand "ac_results" -1) (("1" (inst 2 "t" "s" "vars2avoid" "ac_sym(t)") (("1" (prop) (("1" (hide-all-but 1) (("1" (reveal -27 -28) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -26 -28) (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-9 1 2)) (("3" (expand "all_ac_prb?" -1) (("3" (inst -1 "unif_pair") (("3" (reveal -26 -27 -28) (("3" (assert) (("3" (prop) (("1" (expand "ac_prb?" -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "member_lst_unif_prb_equiv") (("4" (inst? -1) (("4" (assert) (("4" (inst 1 "unif_prb2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "subset?" 1) (("5" (skeep) (("5" (rewrite "mem_lst2set") (("5" (hide 2) (("5" (expand "vars2avoid") (("5" (rewrite "finset2list_mem") (("5" (expand "cur_set_vars2avoid") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -2 :dir rl) (("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "unif_prb1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-6 1)) (("4" (expand "all_ac_prb?" 1) (("4" (skeep) (("4" (expand "all_ac_prb?" -2) (("4" (inst -2 "unif_pair!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (first_proj def-decl "list[list[T1]]" list_theory2 nil) (flatten def-decl "list[T]" list_theory nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (first_proj_mem_flatten formula-decl nil list_theory2 nil) (map_member4 formula-decl nil map_theory nil) (member const-decl "bool" sets nil) (vars const-decl "finite_set[variable]" unification nil) (ac_prb? const-decl "bool" unification nil) (member def-decl "bool" list_props nil) (mem_lst2set formula-decl nil list_theory nil) (finset2list_mem formula-decl nil list_theory nil) (put_in_head_mem3 formula-decl nil list_theory nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (list2set def-decl "set[T]" list2set nil) (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (are_ac? const-decl "bool" term_properties nil) (string type-eq-decl nil strings nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (all_ac_prb? const-decl "bool" unification nil) (apply_ac_step def-decl "[list[unif_prb], finite_set[variable]]" aux_unification nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak) (apply_ac_step_mem2-1 nil 3830019604 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (name-replace "unif_pair" "car(unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "vars1" "lst_vars(unif_prb)") (("2" (name-replace "vars2" "lst_vars(flatten(ac_results_so_far))") (("2" (name-replace "vars2avoid" "append(vars1, vars2)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, vars2avoid, ac_sym(t)))") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (skeep) (("2" (lemma "mem_flatten_map2[list[unif_prb], unif_prb]") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (skolem -1 "lst_unif_prb") (("2" (flatten) (("2" (reveal -12) (("2" (inst -1 "cdr(unif_prb)") (("2" (prop) (("1" (inst -1 "lst_unif_prb" "t1") (("1" (prop) (("1" (skolem -1 ("t2" "s2" "vars2avoid2" "f")) (("1" (flatten) (("1" (inst 2 "t2" "s2" "vars2avoid2" "f") (("1" (prop) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (grind) nil nil)) nil) ("2" (hide -4 -5 -6 -7 -8 -9) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (flatten) (("2" (lemma "put_in_head_mem3[unif_prb]") (("2" (inst? -1) (("2" (inst -1 "unif_prb2") (("2" (assert) (("2" (prop) (("1" (expand "ac_results" -1) (("1" (inst 2 "t" "s" "vars2avoid" "ac_sym(t)") (("1" (prop) (("1" (reveal -12 -13 -14) (("1" (hide -4 -5 -6 -7 -8 -9 -10 -12) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal -12 -13 -14) (("2" (hide -4 -5 -6 -7 -8 -9 -10 -11 -12) (("2" (grind) nil nil)) nil)) nil) ("3" (reveal -12 -13 -14) (("3" (hide -4 -5 -6 -7 -8 -9 -10) (("3" (grind) nil nil)) nil)) nil) ("4" (lemma "member_lst_unif_prb_equiv") (("4" (inst? -1) (("4" (assert) (("4" (inst 1 "unif_prb2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst -1 "ac_results_so_far" "t1") (("2" (assert) (("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "unif_prb_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 -3 3 4) (("4" (expand "all_ac_prb?" -2) (("4" (expand "all_ac_prb?" 1) (("4" (skolem 1 "unif_pair2") (("4" (inst -2 "unif_pair2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lst_vars def-decl "list[variable]" unification nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (put_in_head_mem3 formula-decl nil list_theory nil) (ac_prb? const-decl "bool" unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (flatten def-decl "list[T]" list_theory nil) (first_proj def-decl "list[T1]" list_theory2 nil) (are_ac? const-decl "bool" term_properties nil) (all_ac_prb? const-decl "bool" unification nil) (unif_prb type-eq-decl nil unification nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil)) nil))("aux_unification" aux_unification apply_ac_step_new_var 0 (apply_ac_step_new_var-1 nil 3830009841 ("" (skeep) (("" (lemma "subterms_mem_unif_prb") (("" (inst? -1) (("" (assert) (("" (skolem -1 "t1") (("" (prop) (("" (lemma "apply_ac_step_mem2") (("" (inst? -1) (("" (inst -1 "t1") (("" (prop) (("1" (skolem -1 ("t2" "s2" "vars2avoid" "f")) (("1" (prop) (("1" (hide-all-but (-4 -12 1)) (("1" (expand "solve_ac" -1) (("1" (name-replace "args" "elim_com_arg(t2, s2, f)`1") (("1" (name-replace "mult_t1" "elim_com_arg(t2, s2, f)`2") (("1" (name-replace "mult_t2" "elim_com_arg(t2, s2, f)`3") (("1" (name-replace "bound" "calculate_upper_bound(mult_t1, mult_t2)") (("1" (name-replace "dio_sol_matrix" "dio_solver(mult_t1, mult_t2, bound)") (("1" (name-replace "submatrix_sol_lst" "extract_submatrices(dio_sol_matrix, args)") (("1" (name-replace "results" "map(dio_matrix2ac_sol(args, vars2avoid, f))(submatrix_sol_lst)") (("1" (expand "results") (("1" (lemma "member_lst_unif_prb_equiv") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prb1") (("1" (prop) (("1" (lemma "first_proj_mem[unif_prb, list[variable]]") (("1" (inst? -1) (("1" (hide -4) (("1" (assert) (("1" (skolem -1 "pair1") (("1" (prop) (("1" (hide -4) (("1" (lemma "map_member4[dio_matrix, [unif_prb, list[variable]]]") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "dio") (("1" (prop) (("1" (hide -3) (("1" (expand "dio_matrix2ac_sol" -2) (("1" (replace -2 -3) (("1" (assert) (("1" (hide -2) (("1" (lemma "member_unif_prb_equiv") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_pair") (("1" (prop) (("1" (replace -4 -2) (("1" (lemma "pareate_mem[term]") (("1" (inst? -1) (("1" (assert) (("1" (hide -5) (("1" (prop) (("1" (hide -2) (("1" (hide -3) (("1" (replace -2 :dir rl) (("1" (expand "args" -1) (("1" (lemma "elim_com_arg_mem") (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (reveal -26 -30 -28) (("1" (lemma "subterms_mem_unif_prb") (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (inst 1 "t2") (("1" (assert) (("1" (lemma "subterm_transitive") (("1" (inst? -1) (("1" (inst -1 "t1") (("1" (assert) (("1" (expand "are_ac?" -2) (("1" (flatten) (("1" (hide -3 -5) (("1" (hide 2) (("1" (expand "subterms" 1) (("1" (assert) (("1" (expand "union" 1) (("1" (expand "member" 1 1) (("1" (prop) (("1" (lemma "mem_union_map[term, term]") (("1" (inst? -1) (("1" (assert) (("1" (hide 3) (("1" (inst 1 "t1") (("1" (assert) (("1" (lemma "subterm_reflexive") (("1" (inst? -1) (("1" (assert) (("1" (expand "get_args" -6) (("1" (lemma "map_member4[nat, term]") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "n") (("1" (prop) (("1" (lemma "select_not_pair") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (reveal -27 -28 -30) (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "s2") (("2" (assert) (("2" (lemma "subterm_transitive") (("2" (inst -1 "t" "t1" "s2") (("2" (assert) (("2" (expand "are_ac?" -2) (("2" (flatten) (("2" (hide -2 -4) (("2" (expand "subterms" 1) (("2" (assert) (("2" (expand "union" 1) (("2" (expand "member" 1 1) (("2" (prop) (("2" (hide 1 3) (("2" (lemma "mem_union_map[term, term]") (("2" (inst? -1) (("2" (assert) (("2" (hide 2) (("2" (inst 1 "t1") (("2" (assert) (("2" (lemma "subterm_reflexive") (("2" (inst? -1) (("2" (assert) (("2" (expand "get_args" -6) (("2" (lemma "map_member4[nat, term]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "n") (("2" (prop) (("2" (lemma "select_not_pair") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 -2) (("2" (hide -4) (("2" (lemma "pareate_mem[term]") (("2" (inst? -1) (("2" (assert) (("2" (prop) (("2" (hide -1 -4) (("2" (replace -2 :dir rl) (("2" (lemma "map_member4[args, term]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "new_args") (("2" (prop) (("2" (lemma "get_pre_new_args_mem_var") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (prop) (("1" (reveal -27) (("1" (hide-all-but (-1 -7 1)) (("1" (expand "subset?" -1) (("1" (inst -1 "Y") (("1" (rewrite "mem_lst2set_2") (("1" (hide 1 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (lemma "vars_lst_args") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (hide -3) (("2" (lemma "get_repeat_lst_mem[args]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "vars_get_ac_from_args") (("3" (inst? -1) (("3" (replace -1 1 :dir rl) (("3" (replace -3 1 :dir rl) (("3" (hide -1) (("3" (reveal -33 -30) (("3" (hide -3) (("3" (lemma "vars_subterm") (("3" (inst? -1) (("3" (inst -1 "t") (("3" (assert) (("3" (lemma "im_under_var") (("3" (inst? -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil) ("3" (lemma "member_lst_unif_prb_equiv") (("3" (inst? -1) (("3" (assert) (("3" (inst 1 "unif_prb2") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subterms_mem_unif_prb formula-decl nil unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (calculate_upper_bound const-decl "nat" diophantine nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (first_proj_mem formula-decl nil list_theory2 nil) (get_pre_new_args_mem_var formula-decl nil aux_unification nil) (vars_get_ac_from_args formula-decl nil term_properties nil) (im_under_var formula-decl nil term_properties nil) (vars_subterm formula-decl nil term_properties nil) (get_repeat_lst_mem formula-decl nil list_theory nil) (vars_lst_args formula-decl nil term_properties nil) (subset? const-decl "bool" sets nil) (mem_lst2set_2 formula-decl nil list_theory nil) (finite_union application-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (length def-decl "nat" list_props nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (get_pre_new_args def-decl "[list[args], list[variable]]" aux_unification nil) (get_ac_from_args const-decl "term" term_properties nil) (elim_com_arg_mem formula-decl nil aux_unification nil) (subterm_transitive formula-decl nil term_properties nil) (are_ac? const-decl "bool" term_properties nil) (union const-decl "set" sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (get_args const-decl "args" term_properties nil) (num_arg def-decl "nat" term_properties nil) (from_min2max def-decl "list[nat]" list_theory nil) (select def-decl "term" term_properties nil) (select_not_pair formula-decl nil term_properties nil) (subterm_reflexive formula-decl nil term_properties nil) (mem_union_map formula-decl nil map_theory nil) (member const-decl "bool" sets nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (pareate_mem formula-decl nil list_theory nil) (member_unif_prb_equiv formula-decl nil unification nil) (map_member4 formula-decl nil map_theory nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (ac_sol type-eq-decl nil aux_unification nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (dio_matrix type-eq-decl nil diophantine nil) (dio_solver def-decl "dio_matrix" diophantine nil) (= const-decl "[T, T -> boolean]" equalities nil) (string type-eq-decl nil strings nil) (args type-eq-decl nil term_properties nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (apply_ac_step def-decl "[list[unif_prb], finite_set[variable]]" aux_unification nil) (apply_ac_step_mem2 formula-decl nil aux_unification nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("termination_alg" termination_alg inst_step_vars_not_ac_var_mem 0 (inst_step_vars_not_ac_var_mem-1 nil 3828540763 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (expand "apply_ac_step" -4) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lemma "vars_not_ac_var_lst_unif_prb") (("1" (inst -1 "X" "lst_unif_prb") (("1" (assert) (("1" (inst 1 "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (name-replace "t1" "unif_pair`1") (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "vars1" "lst_vars(unif_prb)") (("2" (name-replace "vars2" "lst_vars(flatten(lst_unif_prb))") (("2" (name-replace "vars2avoid" "append(vars1, vars2)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t1, s, vars2avoid, ac_sym(t1)))") (("2" (lemma "member_lst_unif_prb_equiv") (("2" (inst? -1) (("2" (assert) (("2" (hide -3) (("2" (skolem -1 "unif_prb1") (("2" (prop) (("2" (lemma "mem_flatten_map2[list[unif_prb], unif_prb]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "lst_unif_prb1") (("2" (prop) (("2" (hide -4) (("2" (reveal -12) (("2" (inst -1 "cdr(unif_prb)") (("2" (prop) (("1" (inst -1 "X" "lst_unif_prb1" "t") (("1" (prop) (("1" (expand "vars_not_ac" 2) (("1" (expand "union" 2) (("1" (expand "member" 2 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_var_lst_unif_prb2") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "unif_prb2") (("2" (prop) (("2" (hide -3) (("2" (lemma "put_in_head_mem3[unif_prb]") (("2" (inst? -1) (("2" (inst -1 "unif_prb2") (("2" (assert) (("2" (prop) (("1" (hide -4 -5 -6 -8) (("1" (hide -2) (("1" (lemma "vars_not_ac_var_lst_unif_prb2") (("1" (inst -1 "X" "ac_results") (("1" (assert) (("1" (prop) (("1" (hide -2 -3 -4) (("1" (expand "ac_results") (("1" (expand "solve_ac") (("1" (name-replace "f" "ac_sym(t1)") (("1" (name-replace "args" "elim_com_arg(t1, s, f)`1") (("1" (name-replace "mult_t1" "elim_com_arg(t1, s, f)`2") (("1" (name-replace "mult_t2" "elim_com_arg(t1, s, f)`3") (("1" (name-replace "bound" "calculate_upper_bound(mult_t1, mult_t2)") (("1" (name-replace "dio_sol_matrix" "dio_solver(mult_t1, mult_t2, bound)") (("1" (name-replace "submatrix_sol_lst" "extract_submatrices(dio_sol_matrix, args)") (("1" (name-replace "results" "map(dio_matrix2ac_sol(args, vars2avoid, f))(submatrix_sol_lst)") (("1" (lemma "vars_not_ac_var_lst_unif_prb2") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "unif_prb3") (("1" (prop) (("1" (hide -3) (("1" (expand "results") (("1" (lemma "vars_not_ac_var_dio_matrix2ac_sol") (("1" (inst? -1) (("1" (inst -1 "X") (("1" (assert) (("1" (hide -2 -3) (("1" (expand "args" -1) (("1" (lemma "vars_not_ac_var_args") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "ti") (("1" (prop) (("1" (hide -3) (("1" (expand "elim_com_arg" -1) (("1" (lemma "member_append[term]") (("1" (inst? -1) (("1" (replace -1) (("1" (hide -1) (("1" (prop) (("1" (lemma "count_elem_mem[term]") (("1" (inst? -1) (("1" (assert) (("1" (hide -2) (("1" (prop) (("1" (grind) nil nil) ("2" (lemma "remove_common_mem[term]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (expand "vars_not_ac_var" -2) (("2" (expand "member" -2 1) (("2" (prop) (("2" (reveal -44 -45) (("2" (expand "vars_not_ac" 3) (("2" (expand "member" 3) (("2" (expand "union" 3) (("2" (prop) (("2" (hide 4 5) (("2" (replace -2) (("2" (expand "vars_not_ac" 3) (("2" (replace -1) (("2" (expand "member" 3) (("2" (expand "union" 3) (("2" (prop) (("2" (hide 4) (("2" (expand "vars_not_ac" 3) (("2" (lemma "mem_union_map[term, variable]") (("2" (inst? -1) (("2" (assert) (("2" (hide 4) (("2" (inst 1 "ti") (("2" (prop) (("2" (lemma "not_var_args_get_args2") (("2" (inst? -1) (("2" (assert) (("2" (expand "f") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "count_elem_mem[term]") (("2" (inst? -1) (("2" (assert) (("2" (prop) (("1" (grind) nil nil) ("2" (hide -2) (("2" (lemma "remove_common_mem[term]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (reveal -43 -45) (("2" (expand "vars_not_ac" 2) (("2" (expand "member" 2) (("2" (expand "union" 2) (("2" (prop) (("2" (hide 3 4) (("2" (replace -2) (("2" (expand "vars_not_ac" 2) (("2" (replace -1) (("2" (hide -1 -2) (("2" (expand "union" 2) (("2" (expand "member" 2 1) (("2" (prop) (("2" (hide 2) (("2" (reveal -43 -45) (("2" (expand "all_ac_prb?" -6) (("2" (inst -6 "unif_pair") (("2" (prop) (("1" (expand "ac_prb?" -1) (("1" (assert) (("1" (prop) (("1" (expand "vars_not_ac" 2) (("1" (assert) (("1" (lemma "mem_union_map[term, variable]") (("1" (inst? -1) (("1" (assert) (("1" (hide 3) (("1" (inst 1 "ti") (("1" (expand "vars_not_ac_var" -7) (("1" (expand "member" -7 1) (("1" (prop) (("1" (expand "f" -6) (("1" (reveal -46) (("1" (lemma "not_var_args_get_args2") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_var_lst_unif_prb2") (("2" (inst -1 "X" "lst_unif_prb") (("2" (assert) (("2" (inst 1 "unif_prb2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "all_ac_prb?" -6) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "unif_pair2") (("3" (inst -6 "unif_pair2") (("3" (assert) (("3" (prop) (("3" (expand "member" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "member_lst_unif_prb_equiv") (("4" (inst? -1) (("4" (assert) (("4" (inst 1 "unif_prb1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (all_ac_prb? const-decl "bool" unification nil) (apply_ac_step def-decl "list[unif_prb]" aux_unification nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vars_not_ac_var_lst_unif_prb formula-decl nil termination_alg nil) (lst_vars def-decl "list[variable]" unification nil) (append def-decl "list[T]" list_props nil) (member_lst_unif_prb_equiv formula-decl nil unification nil) (mem_flatten_map2 formula-decl nil map_theory nil) (union const-decl "set" sets nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (args type-eq-decl nil term_properties nil) (dio_solver def-decl "dio_matrix" diophantine nil) (dio_matrix type-eq-decl nil diophantine nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (vars_not_ac_var_dio_matrix2ac_sol formula-decl nil termination_alg nil) (vars_not_ac_var_args formula-decl nil termination_alg nil) (get_args const-decl "args" term_properties nil) (remove_common def-decl "list[T]" list_theory nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (count_elem def-decl "[list[T], list[nat]]" list_theory nil) (equiv type-eq-decl nil list_theory nil) (equivalence? const-decl "bool" relations nil) (ac_prb? const-decl "bool" unification nil) (count_elem_mem formula-decl nil list_theory nil) (member def-decl "bool" list_props nil) (mem_union_map formula-decl nil map_theory nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (not_var_args_get_args2 formula-decl nil term_properties nil) (not_var_args const-decl "args" term_properties nil) (vars_not_ac const-decl "finite_set[variable]" termination_alg nil) (remove_common_mem formula-decl nil list_theory nil) (member_append formula-decl nil list_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (calculate_upper_bound const-decl "nat" diophantine nil) (put_in_head_mem3 formula-decl nil list_theory nil) (vars_not_ac_var_lst_unif_prb2 formula-decl nil termination_alg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (flatten def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak))("termination_alg" termination_alg not_vars_under2more_inst_step 0 (not_vars_under2more_inst_step-1 nil 3829937138 ("" (postpone) nil nil) nil shostak))("termination_alg" termination_alg inst_step_vars_not_ac 0 (inst_step_vars_not_ac-2 nil 3825153194 ("" (skeep) (("" (case "subset?(vars_not_ac(unif_prb1), image(vars_not_ac_magic_fun(sigma), vars_not_ac(unif_prb)))") (("1" (lemma "card_subset[variable]") (("1" (inst -1 "vars_not_ac(unif_prb1)" "image(vars_not_ac_magic_fun(sigma), vars_not_ac(unif_prb))") (("1" (assert) (("1" (lemma "card_image[variable, variable]") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "Y") (("2" (prop) (("2" (lemma "inst_step_vars_not_ac_mem") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (skolem -1 "ti") (("2" (flatten) (("2" (lemma "vars_not_ac_var_subs") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (lemma "instantiate_step_sub") (("2" (inst? -1) (("2" (assert) (("2" (prop) (("1" (skeep) (("1" (expand "image" 3) (("1" (expand "member" 3 1) (("1" (inst 3 "X") (("1" (expand "vars_not_ac_magic_fun" 3) (("1" (lift-if) (("1" (split 3) (("1" (flatten) (("1" (assert) (("1" (replace -3 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 1) (("2" (assert) (("2" (expand "dom" 1) (("2" (expand "member" 1) (("2" (assert) (("2" (flatten) (("2" (replace -1 -2) (("2" (lemma "term_variable_eta") (("2" (hide -1 -2 -4 -5 -6 -7 -8 -9 -10) (("2" (hide 3) (("2" (grind) (("2" (lemma "term_variable_eta") (("2" (hide -1) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -5 -6 -7 -8) (("2" (lemma "inst_step_vars_not_ac_var_mem") (("2" (inst? -1) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "member" -1 1) (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "image" 2) (("2" (expand "member" 2 1) (("2" (lemma "inst_step_vars_not_ac_var_sub") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (prop) (("1" (skeep) (("1" (inst 3 "X") (("1" (expand "vars_not_ac_magic_fun" 3) (("1" (lift-if) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (expand "dom" 1) (("2" (flatten) (("2" (assert) (("2" (replace -1 -2) (("2" (hide -1 -3 -4 -5 -6 -7 -8 -9 -10) (("2" (grind) (("2" (case "X = V(variable(X))") (("1" (replace -2) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_var_lst_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (lemma "inst_step_vars_not_ac_var_mem") (("2" (inst? -1) (("2" (inst -1 "X") (("2" (assert) (("2" (expand "member" -1 1) (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "Y") (("1" (expand "vars_not_ac_magic_fun" 2) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide -2 -3 -6 -7 -8 -9 -10 1 2) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst? -1) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?") (("1" (inst -1 "Y") (("1" (expand "intersection" 1) (("1" (expand "member" 1 1) (("1" (hide -1 -3) (("1" (lemma "vars_not_ac_var_finset") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "t") (("1" (flatten) (("1" (expand "vars_not_ac_var" -2) (("1" (expand "member" -2 1) (("1" (flatten) (("1" (lemma "vars_not_ac_vars_t") (("1" (inst? -1) (("1" (assert) (("1" (lemma "vars_finset") (("1" (inst? -1) (("1" (assert) (("1" (inst 1 "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vars_not_ac_var_lst_unif_prb") (("2" (inst? -1) (("2" (assert) (("2" (skeep) (("2" (lemma "inst_step_vars_not_ac_var_mem") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (expand "member" -1 1) (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "image" 2) (("3" (expand "member" 2) (("3" (inst 2 "Y") (("1" (expand "vars_not_ac_magic_fun" 2) (("1" (lift-if) (("1" (prop) (("1" (hide -2 -3 -5 -7 -8 -9 1 2) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst? -1) (("1" (assert) (("1" (hide -3) (("1" (lemma "apply_sub_elim_var_t") (("1" (inst? -1) (("1" (inst -1 "Y") (("1" (assert) (("1" (prop) (("1" (lemma "vars_not_ac_vars_t") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inst_step_vars_not_ac_var_mem") (("2" (inst? -1) (("2" (inst -1 "Y") (("2" (assert) (("2" (expand "member" -1 1) (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "vars_not_ac_var" 1) (("4" (expand "member" 1 1) (("4" (lemma "subs_var") (("4" (inst? -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inst_step_vars_not_ac_mem formula-decl nil termination_alg nil) (vars_not_ac_var_subs formula-decl nil termination_alg nil) (term_variable_eta formula-decl nil term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (dom const-decl "finite_set[variable]" substitution nil) (inst_step_vars_not_ac_var_mem formula-decl nil termination_alg nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (vars_finset formula-decl nil term_properties nil) (vars_not_ac_vars_t formula-decl nil termination_alg nil) (vars_not_ac_var_finset formula-decl nil termination_alg nil) (disjoint? const-decl "bool" sets nil) (vars_not_ac_var_lst_unif_prb formula-decl nil termination_alg nil) (inst_step_vars_not_ac_var_sub formula-decl nil termination_alg nil) (apply_sub_elim_var_t formula-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (subs const-decl "term" substitution nil) (subs_var formula-decl nil substitution nil) (instantiate_step_sub formula-decl nil aux_unification nil) (apply_ac_step def-decl "list[unif_prb]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (card_image formula-decl nil function_image_aux nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (vars_not_ac_magic_fun const-decl "variable" termination_alg nil)) nil) (inst_step_vars_not_ac-1 nil 3824407815 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 ("unif_prb")) (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -2) (("" (lift-if) (("" (prop) (("1" (expand "vars_not_ac" 1 2) (("1" (lift-if) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "instantiate_step" -1) (("2" (expand "first_proj" -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (name-replace "unif_pair" "car(unif_prb)") (("3" (name-replace "t" "unif_pair`1") (("3" (name-replace "s" "unif_pair`2") (("3" (name-replace "vars1" "lst_vars(unif_prb)") (("3" (name-replace "vars2" "lst_vars(flatten(lst_unif_prb))") (("3" (name-replace "vars2avoid" "append(vars1, vars2)") (("3" (name-replace "ac_results" "first_proj(solve_ac(t, s, vars2avoid, ac_sym(t)))") (("3" (name-replace "new_ac_results_so_far" "put_in_head(ac_results, lst_unif_prb)") (("3" (lemma "func_flatten_map[unif_prb, [unif_prb, sub]]") (("3" (inst? -1) (("3" (prop) (("1" (replace -1 -3) (("1" (hide -1) (("1" (rewrite "map_list_composition") (("1" (lemma "func_flatten_map[[unif_prb, sub], unif_prb]") (("1" (inst? -1) (("1" (prop) (("1" (replace -1 -3) (("1" (rewrite "map_list_composition") (("1" (hide -1) (("1" (lemma "mem_flatten_map2[list[unif_prb], unif_prb]") (("1" (inst? -1) (("1" (assert) (("1" (skolem -1 "lst_unif_prb1") (("1" (hide -3) (("1" (flatten) (("1" (expand "o" -2) (("1" (hide -1) (("1" (reveal -16) (("1" (inst -1 "cdr(unif_prb)") (("1" (prop) (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (expand "subset?" 2) (("1" (skeep) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "member" -1) (("1" (expand "union" -1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "union" 2) (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (expand "new_ac_results_so_far") (("2" (lemma "put_in_head_mem2[unif_prb]") (("2" (inst? -1) (("2" (assert) (("2" (case "null?(lst_unif_prb1)") (("1" (expand "instantiate_step" -4) (("1" (assert) (("1" (expand "first_proj" -4) (("1" (expand "vars_not_ac" -4) (("1" (hide-all-but -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "instantiate_step" -3) (("2" (flatten) (("2" (hide -5 -7) (("2" (name-replace "fail1" "instantiate_step(car(lst_unif_prb1), null)`3") (("2" (lift-if) (("2" (prop) (("1" (replace -4 -2) (("1" (expand "member" 3) (("1" (expand "union" 3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "first_proj" -1) (("2" (expand "vars_not_ac" -1) (("2" (expand "member" -1) (("2" (expand "union" -1) (("2" (prop) (("1" (hide 1) (("1" (expand "ac_results" -2) (("1" (lemma "apply_ac_step_vars_not_ac_aux") (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (replace -3 -1) (("2" (expand "member" 4) (("2" (expand "union" 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" 1) (("2" (skolem 1 "unif_pair1") (("2" (prop) (("2" (expand "all_ac_prb?" -4) (("2" (inst -4 "unif_pair1") (("2" (expand "member" -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification add_vars2avoid_TCC1 0 (add_vars2avoid_TCC1-1 nil 3830547881 ("" (subtype-tcc) nil nil) nil nil (add_vars2avoid subtype "aux_unification.lst_unif_prb_and_subs" "(list_adt[[unification.unif_prb, substitution.sub]].cons?)")))("aux_unification" aux_unification add_vars2avoid_TCC2 0 (add_vars2avoid_TCC2-1 nil 3830547881 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (add_vars2avoid termination "aux_unification.add_vars2avoid(list_adt[[unification.unif_prb, substitution.sub]].cdr(aux_unification.lst_unif_prb_and_subs), aux_unification.set_vars2avoid)" "nil")))("aux_unification" aux_unification add_vars2avoid_TCC3 0 (add_vars2avoid_TCC3-1 nil 3830547881 ("" (subtype-tcc) nil nil) nil nil (add_vars2avoid subtype "aux_unification.lst_unif_prb_and_subs" "(list_adt[[unification.unif_prb, substitution.sub]].cons?)")))("aux_unification" aux_unification add_vars2avoid_len 0 (add_vars2avoid_len-1 nil 3831148412 ("" (induct "lst_unif_prb_and_subs" 1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (add_vars2avoid def-decl "list[[unif_prb, sub, finite_set[variable]]]" aux_unification nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil)) shostak))("aux_unification" aux_unification add_vars2avoid_nth_1_TCC1 0 (add_vars2avoid_nth_1_TCC1-1 nil 3831147014 ("" (subtype-tcc) nil nil) nil nil (add_vars2avoid_nth_1 subtype "aux_unification.i" "below[length[[unif_prb, sub, finite_set[variable]]](add_vars2avoid(lst_unif_prb_and_subs, set_vars2avoid))]")))("aux_unification" aux_unification add_vars2avoid_nth_1 0 (add_vars2avoid_nth_1-1 nil 3831147074 ("" (measure-induct "length(lst_unif_prb_and_subs)" "lst_unif_prb_and_subs" 1) (("1" (skolem 1 "lst_unif_prb_and_subs") (("1" (prop) (("1" (skeep) (("1" (expand "add_vars2avoid" 1 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2 1) (("1" (grind) nil nil)) nil) ("2" (expand "nth" 2 1) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (expand "nth" 1) (("1" (assert) (("1" (expand "add_vars2avoid" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_vars2avoid" 2 2) (("2" (lift-if) (("2" (assert) (("2" (expand "nth" 2 2) (("2" (inst -1 "cdr(lst_unif_prb_and_subs)") (("2" (prop) (("1" (inst -1 "i-1" "set_vars2avoid") (("1" (prop) (("1" (expand "member" 2) (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "add_vars2avoid_len") nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (add_vars2avoid def-decl "list[[unif_prb, sub, finite_set[variable]]]" aux_unification nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (member def-decl "bool" list_props nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (add_vars2avoid_len formula-decl nil aux_unification nil)) shostak))("apply_ac_step" apply_ac_step add_subs_TCC1 0 (add_subs_TCC1-1 nil 3831662388 ("" (termination-tcc) nil nil) nil nil (add_subs termination "apply_ac_step.add_subs(list_adt[ac_sol_simp].cdr(apply_ac_step.ac_sol_simp_lst), apply_ac_step.sigma)" "nil")))("apply_ac_step" apply_ac_step vars_TCC1 0 (vars_TCC2-1 nil 3831661915 ("" (subtype-tcc) nil nil) nil nil (vars subtype "apply_ac_step.ac_sol_simp_lst" "(list_adt[ac_sol_simp].cons?)")))("apply_ac_step" apply_ac_step vars_TCC2 0 (vars_TCC1-1 nil 3831661915 ("" (termination-tcc) nil nil) nil nil (vars termination "apply_ac_step.vars(list_adt[ac_sol_simp].cdr(apply_ac_step.ac_sol_simp_lst))" "nil")))("apply_ac_step" apply_ac_step vars_TCC3 0 (vars_TCC3-1 nil 3831670456 ("" (subtype-tcc) nil nil) nil nil (vars subtype "apply_ac_step.ac_sol_simp_lst" "(list_adt[ac_sol_simp].cons?)")))("apply_ac_step" apply_ac_step add_to_ac_sol_simp_lst_TCC1 0 (add_to_ac_sol_simp_lst_TCC1-1 nil 3831670456 ("" (termination-tcc) nil nil) nil nil (add_to_ac_sol_simp_lst termination "apply_ac_step.add_to_ac_sol_simp_lst(apply_ac_step.unif_prb, apply_ac_step.sigma, apply_ac_step.vars2avoid, apply_ac_step.ac_sol_simp_lst)" "nil")))("apply_ac_step" apply_ac_step add_to_ac_results_subs_TCC1 0 (add_to_ac_results_subs_TCC1-1 nil 3831661915 ("" (subtype-tcc) nil nil) nil nil (add_to_ac_results_subs subtype "apply_ac_step.ac_results_subs" "(list_adt[[unification.unif_prb, substitution.sub]].cons?)")))("apply_ac_step" apply_ac_step add_to_ac_results_subs_TCC2 0 (add_to_ac_results_subs_TCC2-1 nil 3831661915 ("" (termination-tcc) nil nil) nil nil (add_to_ac_results_subs termination "apply_ac_step.add_to_ac_results_subs(list_adt[[unification.unif_prb, substitution.sub]].cdr(apply_ac_step.ac_results_subs), apply_ac_step.vars2avoid)" "nil")))("apply_ac_step" apply_ac_step add_to_ac_results_subs_TCC3 0 (add_to_ac_results_subs_TCC3-1 nil 3831661915 ("" (subtype-tcc) nil nil) nil nil (add_to_ac_results_subs subtype "apply_ac_step.ac_results_subs" "(list_adt[[unification.unif_prb, substitution.sub]].cons?)")))("apply_ac_step" apply_ac_step apply_ac_step_mem_null 0 (apply_ac_step_mem_null-1 nil 3831673179 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 ("unif_prb")) (("" (prop) (("" (hide -1) (("" (skeep) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (assert) (("" (name-replace "unif_pair" "car(unif_prb)") (("" (name-replace "t" "unif_pair`1") (("" (name-replace "s" "unif_pair`2") (("" (name-replace "cur_vars2avoid" "union(vars(unif_prb), union(vars2avoid, vars(ac_sol_simp_lst)))") (("" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (name-replace "vars2avoid_" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unif_prb), vars2avoid_, ac_sol_simp_lst)") (("1" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (lemma "mem_flatten_map2[[unif_prb, finite_set[variable], list[ac_sol_simp]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "input") (("2" (flatten) (("2" (reveal -12) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst? -1) (("1" (inst -1 "input`3" "input`2") (("1" (prop) (("1" (skolem -1 ("ac_sol1" "ac_sol2")) (("1" (flatten) (("1" (expand "input_lst" -6) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg apply_ac_step_vars_not_ac 0 (apply_ac_step_vars_not_ac-1 nil 3831662672 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -2) (("" (lift-if) (("" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split) (("1" (hide-all-but -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unif_prb)") (("1" (name-replace "t" "unif_pair`1") (("1" (name-replace "s" "unif_pair`2") (("1" (name-replace "cur_vars2avoid" "union(vars(unif_prb), union(vars2avoid, vars(null[ac_sol_simp])))") (("1" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("1" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unif_prb), new_vars2avoid, null)") (("2" (lemma "mem_flatten_map2[[unif_prb, finite_set[variable], list[ac_sol_simp]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input") (("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg mimic_var_aux_append 0 (mimic_var_aux_append-1 nil 3831913821 ("" (induct "sigma") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "append" 1 1) (("2" (expand "mimic_var_aux" 1 1) (("2" (lift-if) (("2" (split) (("1" (prop) (("1" (expand "mimic_var_aux" 1 3) (("1" (lift-if) (("1" (assert) (("1" (inst -2 "V(subs(hd, variable(X)))" "delta") nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mimic_var_aux" 2 3) (("2" (assert) (("2" (inst -1 "X" "delta") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (mimic_var_aux def-decl "variable" termination_alg nil) (append def-decl "list[T]" list_props nil) (basic_sub type-eq-decl nil substitution nil) (constant type-eq-decl nil term_properties nil) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list_induction formula-decl nil list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil)) shostak))("termination_alg" termination_alg apply_ac_step_vars_not_ac 0 (apply_ac_step_vars_not_ac-1 nil 3831662672 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1 1) (("1" (postpone) nil nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (hide -2) (("2" (skolem -1 "input") (("2" (prop) (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (reveal -11) (("2" (lemma "input_apply_ac_step_mem") (("2" (hide -2) (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 ("unif_prb1" "delta1")) (("2" (reveal -12) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol" "input`2" "input`3" "input`4") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (hide -3 -4 -5 -6) (("1" (expand "subset?" 3) (("1" (skolem 3 "Y") (("1" (expand "subset?" -1) (("1" (inst -1 "Y") (("1" (prop) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("unification" unification apply_sub_no_var_pair_aux 0 (apply_sub_no_var_pair_aux-1 nil 3832098779 ("" (induct "sigma") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (inst -1 "t") (("2" (assert) (("2" (flatten) (("2" (prop) (("1" (expand "subs" -1) (("1" (grind) (("1" (case "hd = (hd`1, hd`2)") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("termination_alg" termination_alg vars_not_ac_var_solve_ac_TCC1 0 (vars_not_ac_var_solve_ac_TCC1-1 nil 3832144188 ("" (subtype-tcc) nil nil) nil nil (vars_not_ac_var_solve_ac subtype "termination_alg.t" "(term_adt[constant, variable, f_symbol, ac_symbol].ac_app?)")))("termination_alg" termination_alg apply_ac_step_vars_not_ac3 0 (apply_ac_step_vars_not_ac3-1 nil 3831907014 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "unseen_unif_prb") (("" (prop) (("" (skeep) (("" (hide -1) (("" (hide -2 -3) (("" (expand "apply_ac_step" -1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (prop) (("1" (replace -1 1) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "member" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "unif_pair" "car(unseen_unif_prb)") (("2" (name-replace "t" "unif_pair`1") (("2" (name-replace "s" "unif_pair`2") (("2" (name-replace "cur_vars2avoid" "union(vars(unseen_unif_prb), union(vars2avoid, vars(seen_unif_prb)))") (("2" (name-replace "lst_vars2avoid" "finset2list[variable](cur_vars2avoid)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t)))") (("2" (name-replace "new_vars2avoid" "vars(sec_proj(solve_ac(t, s, lst_vars2avoid, ac_sym(t))))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(unseen_unif_prb), seen_unif_prb, null, new_vars2avoid)") (("2" (lemma "mem_flatten_map2[[unif_prb, unif_prb, sub, finite_set[variable]], ac_sol_simp]") (("2" (inst? -1) (("2" (assert) (("2" (skolem -1 "input") (("2" (hide -2) (("2" (prop) (("2" (lemma "apply_ac_step_sigma_null") (("2" (inst -1 "ac_sol" "input`2" "input`3" "input`1" "input`4") (("2" (assert) (("2" (skolem -1 "ac_sol1") (("2" (flatten) (("2" (replace -2) (("2" (hide -2 -3 -4 -6) (("2" (reveal -19) (("2" (inst -1 "input`1") (("2" (prop) (("1" (inst -1 "ac_sol1" "input`2" "input`4") (("1" (assert) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil))("unification" unification apply_sub_no_pair 0 (apply_sub_no_pair-1 nil 3832677979 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "apply_sub" 1) (("2" (expand "no_pair?" 1) (("2" (skeep) (("2" (expand "member" -3) (("2" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))