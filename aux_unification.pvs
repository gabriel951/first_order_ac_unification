%
% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%

% File: aux_unification.pvs
% Description: auxiliary functions called in the unification algorithm 

%%%%%%%%%%%%%%%%%%%%%%%

aux_unification: THEORY
BEGIN
	IMPORTING substitution, diophantine, list_theory[number], list_theory[Args]

sigma: VAR Sub


% a unification pair (t, s) is composed of terms t and s that must be unified
Unif_pair: TYPE = [Term, Term]

% a unification problem is a list of unification pairs
Unif_prb: TYPE = list[Unif_pair]
unif_prb: VAR Unif_prb

% one particular ac solution is a pair of list of terms "Old_Args" and "New_Args"
% we will try to unify "Old_Args[i]" with "New_Args[i]"
Ac_sol: TYPE = [Args, Args]

sym: VAR string

t, t1, t2: VAR Term
args: VAR Args
lst_args: VAR list[Args]

mult_t1, mult_t2, row, col: VAR list[nat]
bound, i, n, num_col: VAR nat
num: VAR number

dio_sol_matrix, dio_matrix: VAR Dio_matrix
submatrix_sol_lst, dio_matrix_lst: VAR list[Dio_matrix]

vars2avoid: VAR list[Variable]

ac_sol: VAR Ac_sol
ac_sol_lst: VAR list[Ac_sol]
ac_sol_simp: VAR [Sub, Ac_sol]
ac_sol_simp_lst: VAR list[[Sub, Ac_sol]]

% this corresponds to function elimcom in Fages paper
elim_com_arg(t1, t2, sym): [list[Term], list[nat], list[nat]] =
    LET 
    % get the arguments of t1 and how many times they appear
    (args_t1, coef_t1) = get_args_coef_ac(t1, sym),
    % get the arguments of t2 and how many times they appear
    (args_t2, coef_t2) = get_args_coef_ac(t2, sym),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t1
    (new_args_t1, new_coef_t1) = select_args(args_t1, coef_t1, args_t2, coef_t2),
    % get the arguments that appear more in t1 than in t2 and how many times
    % they appear more in t2
    (new_args_t2, new_coef_t2) = select_args(args_t2, coef_t2, args_t1, coef_t1)
    IN (append(new_args_t1, new_args_t2), new_coef_t1, new_coef_t2)

elim_com_arg_pos: LEMMA
   member(num, elim_com_arg(t1, t2, sym)`2) IMPLIES num > 0 
   
elim_com_arg_pos2: LEMMA
   member(num, elim_com_arg(t1, t2, sym)`3) IMPLIES num > 0 

% check if column i is empty (all coeficients equal to 0)
% you must make sure dio_matrix is a matrix and i < num_col_dio_matrix 
empty_col?(dio_matrix)(i): bool =
    LET col_i = get_col_i[nat](dio_matrix, i, 0) IN 
    	IF (FORALL n: member(n, col_i) => n = 0) THEN TRUE
    	ELSE FALSE
    	ENDIF

% Constraint 1: Every column has at least one coefficient greater than 0 
const1?(dio_matrix, num_col): bool =
     LET empty_col_lst = map(empty_col?(dio_matrix), from_min2max[nat](1, num_col)) IN
     IF member(TRUE, empty_col_lst) THEN FALSE
     ELSE TRUE 
     ENDIF
     
% Constraint 2: One coefficient is equal to one, the others are zero 
const2?(col): bool =
    IF count(1, col) = 1 AND count(0, col) = length(col) - 1 THEN TRUE
    ELSE FALSE
    ENDIF

% returns false if column "i" corresponds to a non-variable argument and does not satisfy constraint 2
% returns true otherwise
if_non_var_const2_col?(dio_matrix, args)(i): bool = 
    IF i > length(args) OR i = 0 THEN FALSE 
    ELSE LET arg = nth(args, i-1) IN 
    	     IF var?(arg) THEN TRUE
	     ELSE LET col_i = get_col_i[nat](dio_matrix, i, 0) IN
	     	      const2?(col_i)
	     ENDIF
    ENDIF

% return true if all columns that correspond to a non-variable argument satisfy constraint 2
if_non_var_const2?(dio_matrix, args): bool =
     LET lst_non_var_const2 = map(if_non_var_const2_col?(dio_matrix, args),
     	 		     	   from_min2max[nat](1, length(args))) IN
     IF member(FALSE, lst_non_var_const2) THEN FALSE
     ELSE TRUE
     ENDIF

% a nice submatrix is one that satisfies constraint 1 and for every column that is not a variable
% satisfies constraint 2
nice_submatrix?(dio_matrix, args): bool =
     const1?(dio_matrix, length(args)) AND if_non_var_const2?(dio_matrix, args)

% receives a list of dio matrix
% returns a list of the ones that satisfy the property of being nice
get_nice_submatrices(dio_matrix_lst, args): RECURSIVE list[Dio_matrix] =
    IF null?(dio_matrix_lst) THEN null
    ELSE LET dio_matrix = car(dio_matrix_lst) IN
    	 IF nice_submatrix?(dio_matrix, args) THEN
	    cons(dio_matrix, get_nice_submatrices(cdr(dio_matrix_lst), args))
	 ELSE get_nice_submatrices(cdr(dio_matrix_lst), args)
	 ENDIF
    ENDIF
MEASURE dio_matrix_lst BY << 


% extract the relevant submatrices. Each submatrix corresponds to one ac-solution
% this corresponds to function partit in Fages article
extract_submatrices(dio_sol_matrix, args): list[Dio_matrix] =
    % check that the dio_sol_matrix is not only a list of lists but also a matrix
    IF nonmatrix?(dio_sol_matrix) THEN null
    ELSE LET all_submatrices = get_all_sublists(dio_sol_matrix) 
    	     IN get_nice_submatrices(all_submatrices, args)
    ENDIF
    	   
% add to lst_args[i] the term "t" the amount of times specified in row[i] for each i
add_new_arg(lst_args, row, t): RECURSIVE list[Args] = 
    IF null?(lst_args) OR null?(row) THEN lst_args
    ELSE LET args = car(lst_args), 
    	     args2 = get_repeat_lst(t, car(row)), 
	     new_args = append(args, args2) IN 
	     cons(new_args, add_new_arg(cdr(lst_args), cdr(row), t))
    ENDIF
MEASURE row BY << 

% return a variable that is not in vars2avoid
get_new_var(vars2avoid): Variable = select_greater[number](vars2avoid, 0) + 1

% the initial call to this function should be with lst_args = [null, ..., null]
% each row in dio_matrix gives rise to a new variable 
% add the new_variable to lst_args[i] the amount of times indicated in row[i],
% i ranges from 1 <= "i" <= length(lst_args)
get_pre_new_args(lst_args, dio_matrix, vars2avoid): RECURSIVE [list[Args], list[Variable]] = 
     IF null?(dio_matrix) THEN (lst_args, vars2avoid)
     ELSE LET row = car(dio_matrix), 
     	      new_var = get_new_var(vars2avoid), 
	      new_lst_args = add_new_arg(lst_args, row, variable(new_var)), 
	      new_vars2avoid = cons(new_var, vars2avoid) 
	      IN get_pre_new_args(new_lst_args, cdr(dio_matrix), new_vars2avoid)
     ENDIF
MEASURE dio_matrix BY << 

% this corresponds to function trans in Fages paper
% some simplification is done
dio_matrix2ac_sol(args, vars2avoid, sym)(dio_matrix): [Ac_sol, list[Variable]] = 
     LET num_col = length(args), 
     % get list of list of args
     null_lst = get_repeat_lst[Args](null, num_col), 
     (pre_new_args, new_vars2avoid) = get_pre_new_args(null_lst, dio_matrix, vars2avoid),
     % for each "args" in pre_new_args, make an ac term whose args are "args"
     new_args = map(get_ac_from_args(sym), pre_new_args), 
     % pareate
     ac_sol = (args, new_args) IN
     (ac_sol, new_vars2avoid) 

    
% this corresponds to function "dio" in Fages paper
solve_ac(t1, t2, vars2avoid, sym): list[[Ac_sol, list[Variable]]] =
    LET
%    eliminate common arguments from t1 and t2, obtaining the different arguments on each one
%    and their multiplicity
     (args, mult_t1, mult_t2) = elim_com_arg(t1, t2, sym),
%    calculate upper bound from which we can solve the diophantine equation
     bound = calculate_upper_bound(mult_t1, mult_t2),
%    solve diophantine equation until the upper bound 
     dio_sol_matrix = dio_solver(mult_t1, mult_t2, bound),
%    extract "nice" submatrices of solutions
     submatrix_sol_lst = extract_submatrices(dio_sol_matrix, args), 
%    for every diophantine submatrix obtain the corresponding unification solution
     results = map(dio_matrix2ac_sol(args, vars2avoid, sym), submatrix_sol_lst)
     IN results


% this functions corresponds to the homonymous function "elimvar" in Fages paper
elimvar(ac_sol): [Sub, Ac_sol] =
((::), ((::), (::))) 


% apply function elimvar to every ac_sol in ac_sol_lst
% TODO: this can be replaced by a simple "map"
apply_elimvar(ac_sol_lst): RECURSIVE list[[Sub, Ac_sol]] =
    IF null?(ac_sol_lst) THEN (::)
    ELSE LET ac_sol = car(ac_sol_lst),
             ac_sol_simp = elimvar(ac_sol) 
             IN cons(ac_sol_simp, apply_elimvar(cdr(ac_sol_lst)))
    ENDIF
MEASURE ac_sol_lst BY << 


construct_input(ac_sol_simp, unif_prb, sigma, vars2avoid): [Unif_prb, Sub, set[Variable]] =
((::), (::), (::))

% construct a list of inputs that will be passed to unify
construct_input_lst(ac_sol_simp_lst, unif_prb, sigma, vars2avoid): RECURSIVE list[[Unif_prb, Sub, set[Variable]]] =
    IF null?(ac_sol_simp_lst) THEN (::)
    ELSE LET input = construct_input(car(ac_sol_simp_lst), unif_prb, sigma, vars2avoid)
    	     IN cons(input, construct_input_lst(cdr(ac_sol_simp_lst), unif_prb, sigma, vars2avoid))
    ENDIF
MEASURE ac_sol_simp_lst BY << 


END aux_unification 
