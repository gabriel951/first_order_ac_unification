("aux_unification" aux_unification instantiate_step_unifies_equiv 0 (instantiate_step_unifies_equiv-1 nil 3851195315 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 "sig") (("" (prop) (("" (name-replace "delta" "instantiate_step(P, null, null)`2") (("" (reveal -1) (("" (expand "instantiate_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "del1" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lemma "instantiate_step2_no_effect") (("1" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("1" (replace -1) (("1" (inst -4 "cdr(P)") (("1" (prop) (("1" (inst -1 "sig") (("1" (assert) (("1" (expand "unifies?" -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "append_null") (("2" (expand "apply_sub" -1 2) (("2" (expand "unifies?" -3) (("2" (assert) (("2" (flatten) (("2" (reveal -1 -2 -3 -4 -5) (("2" (case "equal?(sig, append(sig, del1))") (("1" (lemma "instantiate_step_sub_append") (("1" (inst -1 "null" "del1" "apply_sub(del1, cdr(P))") (("1" (assert) (("1" (hide 1 2) (("1" (replace -6) (("1" (inst -7 "apply_sub(del1, cdr(P))") (("1" (prop) (("1" (inst -1 "sig") (("1" (prop) (("1" (name-replace "del2" "instantiate_step(apply_sub(del1, cdr(P)), null, null)`2") (("1" (case "equal?(append(sig, del1), append(append(sig, del2), del1))") (("1" (rewrite "append_assoc") (("1" (replace -3) (("1" (lemma "equal_sub_trans") (("1" (replace -4 :dir rl) (("1" (inst -1 "sig" "append(sig, del1)" "append(sig, delta)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but (-1 1)) (("2" (lemma "equal_sub_equiv") (("2" (expand "equal?" 1) (("2" (skolem 1 "x") (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (inst -1 "sig" "append(sig, del2)" "subs(del1)(variable(x))") (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_unifies") (("2" (lemma "unifies?_equal") (("2" (inst -1 "sig" "append(sig, del1)" "cdr(P)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5 -7) (("2" (expand "instantiate_step" -3) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sig" "t") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) (("1" (expand "unifies?" -6) (("1" (replace -3) (("1" (replace -4) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sig)(s)" "subs(sig)(t)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sig" "s") (("1" (beta -1) (("1" (replace -2) (("1" (assert) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (expand "unifies?" -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) nil (append def-decl "list[T]" list_props nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (instantiate_step2_no_effect formula-decl nil aux_unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_equal formula-decl nil unification nil) (equal_sub_equiv formula-decl nil substitution nil) (subs_append2 formula-decl nil substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) nil (subs const-decl "term" substitution nil) (append_assoc formula-decl nil list_props nil) (equal_sub_trans formula-decl nil substitution nil) (instantiate_step_sub_append formula-decl nil aux_unification nil) (subs_inst formula-decl nil substitution nil) (term_variable_eta formula-decl nil term_adt nil) (equal?_sym formula-decl nil equality nil) (unifies? const-decl "bool" unification nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step const-decl "[sub, bool, bool]" aux_unification nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append_null formula-decl nil list_props nil) (equal_sub_ref formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak))("aux_unification" aux_unification instantiate_step_unifies_equal 0 (instantiate_step_unifies_equal-1 nil 3851197746 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skolem 1 "sig") (("" (prop) (("" (name-replace "delta" "instantiate_step(P, null, null)`2") (("" (reveal -1) (("" (expand "instantiate_step" -1) (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "del1" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (rewrite "append_null") (("1" (use "equal_sub_ref") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lemma "instantiate_step2_no_effect") (("1" (inst -1 "null" "cdr(P)" "cons((t, s), null)" "null") (("1" (replace -1) (("1" (inst -4 "cdr(P)") (("1" (prop) (("1" (inst -1 "sig") (("1" (assert) (("1" (expand "unifies?" -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "append_null") (("2" (expand "apply_sub" -1 2) (("2" (expand "unifies?" -3) (("2" (assert) (("2" (flatten) (("2" (reveal -1 -2 -3 -4 -5) (("2" (case "equal?(sig, append(sig, del1))") (("1" (lemma "instantiate_step_sub_append") (("1" (inst -1 "null" "del1" "apply_sub(del1, cdr(P))") (("1" (assert) (("1" (hide 1 2) (("1" (replace -6) (("1" (inst -7 "apply_sub(del1, cdr(P))") (("1" (prop) (("1" (inst -1 "sig") (("1" (prop) (("1" (name-replace "del2" "instantiate_step(apply_sub(del1, cdr(P)), null, null)`2") (("1" (case "equal?(append(sig, del1), append(append(sig, del2), del1))") (("1" (rewrite "append_assoc") (("1" (replace -3) (("1" (lemma "equal_sub_trans") (("1" (replace -4 :dir rl) (("1" (inst -1 "sig" "append(sig, del1)" "append(sig, delta)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but (-1 1)) (("2" (lemma "equal_sub_equiv") (("2" (expand "equal?" 1) (("2" (skolem 1 "x") (("2" (expand "subs" 1) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (inst -1 "sig" "append(sig, del2)" "subs(del1)(variable(x))") (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_unifies") (("2" (lemma "unifies?_equal") (("2" (inst -1 "sig" "append(sig, del1)" "cdr(P)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5 -7) (("2" (expand "instantiate_step" -3) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(s)" "sig" "t") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) (("1" (expand "unifies?" -6) (("1" (replace -3) (("1" (replace -4) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (lemma "equal?_sym") (("1" (inst -1 "subs(sig)(s)" "subs(sig)(t)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (lemma "subs_inst") (("1" (inst -1 "V(t)" "sig" "s") (("1" (beta -1) (("1" (replace -2) (("1" (assert) (("1" (use "term_variable_eta") (("1" (replace -1) (("1" (expand "unifies?" -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (rewrite "append_null") (("2" (use "equal_sub_ref") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (equal? const-decl "bool" substitution nil) (append def-decl "list[T]" list_props nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (instantiate_step2_no_effect formula-decl nil aux_unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_equal formula-decl nil unification nil) (equal_sub_equiv formula-decl nil substitution nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subs_append2 formula-decl nil substitution nil) (subs def-decl "term" substitution nil) (subs const-decl "term" substitution nil) (append_assoc formula-decl nil list_props nil) (equal_sub_trans formula-decl nil substitution nil) (instantiate_step_sub_append formula-decl nil aux_unification nil) (subs_inst formula-decl nil substitution nil) (term_variable_eta formula-decl nil term_adt nil) (equal?_sym formula-decl nil equality nil) (unifies? const-decl "bool" unification nil) (V adt-accessor-decl "[(var?) -> variable]" term_adt nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step const-decl "[sub, bool, bool]" aux_unification nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append_null formula-decl nil list_props nil) (equal_sub_ref formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil))("apply_ac_step" apply_ac_step apply_ac_step_complete1 0 (apply_ac_step_complete1-1 nil 3851201713 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("delta" "Ps" "sigma" "V")) (("" (flatten) (("" (hide -1) (("" (case "null?(Pu)") (("1" (inst 1 "(Ps, sigma, V)" "null") (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "well_formed?" 1) (("4" (skeep) (("4" (expand "subs" 1) (("4" (expand "subs" 1) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "img_null") (("5" (grind) nil nil)) nil) ("6" (expand "append" 1) (("6" (propax) nil nil)) nil)) nil)) nil) ("2" (name-replace "u_pair" "car(Pu)") (("1" (name-replace "t" "u_pair`1") (("1" (name-replace "s" "u_pair`2") (("1" (case "equal?(t, s)") (("1" (reveal -1) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "Ps" "sigma") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "ac_sol" "gamma") (("1" (assert) (("1" (delete -6) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (expand "unifies?" -5) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "all_ac_prb?") (("3" (skeep) (("3" (inst -7 "unif_pair") (("3" (assert) (("3" (expand "member" 3) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "nice_input_cdr") (("4" (hide 3) (("4" (inst -1 "sigma" "append(Pu, Ps)" "V") (("4" (expand "append" -1 1) (("4" (expand "append" -1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sigma, V1)") (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9) (("1" (lemma "solve_ac_unify_complete") (("1" (inst -1 "delta" "f" "s" "t" "lst_V") (("1" (assert) (("1" (prop) (("1" (skolem -1 ("P_C" "lambda1" "V2")) (("1" (flatten) (("1" (hide -3 -4 -5 -9 -10 -11 -8) (("1" (hide -3) (("1" (name-replace "i_step_output" "instantiate_step(P_C, null, null)") (("1" (name-replace "P_CI" "i_step_output`1") (("1" (name-replace "lambda2" "i_step_output`2") (("1" (expand "more_general?" -7) (("1" (skolem -7 "delta1") (("1" (lemma "unifies?_equal") (("1" (inst -1 "delta" "append(delta1, sigma)" "append(Pu, Ps)") (("1" (assert) (("1" (hide -7) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "P_C") (("1" (case "equal?(append(lambda1, delta), append(append(lambda1, delta1), sigma))") (("1" (assert) (("1" (hide -1 -8) (("1" (lemma "unifies?_append_disjoint") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step_unifies_sub") (("1" (inst -1 "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (replace -6) (("1" (replace -4) (("1" (assert) (("1" (prop) (("1" (reveal -26) (("1" (inst -1 "apply_sub(lambda2, cdr(Pu))") (("1" (prop) (("1" (inst -1 "append(lambda1, delta)" "append(P_CI, apply_sub(lambda2, Ps))" "append(lambda2, sigma)" "V1") (("1" (prop) (("1" (skolem -1 ("ac_sol" "gamma")) (("1" (flatten) (("1" (inst 2 "ac_sol" "append(gamma, lambda1)") (("1" (prop) (("1" (delete -6) (("1" (reveal -18 -19 -20 -21 -22 -23 -24 -25 -26) (("1" (reveal -9) (("1" (expand "apply_ac_step" 1) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but (-1 -10 -11 2)) (("1" (reveal 3) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (replace -10) (("2" (replace -9) (("2" (replace -8) (("2" (replace -7) (("2" (replace -6) (("2" (replace -5) (("2" (split 1) (("1" (flatten) (("1" (hide -10 -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (lemma "instantiate_step_lst_mem") (("1" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil) ("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (reveal -26) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2 1) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ac_results" 1) (("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (hide -12 -13 -14 -15 -16 -17 -18 -19 -21) (("2" (use "input_apply_ac_step_mem2") (("2" (assert) (("2" (hide 2) (("2" (inst 1 "P_CI" "lambda2") (("2" (reveal -9 -10) (("2" (hide -13 -16 -9 -10) (("2" (lemma "instantiate_step_lst_mem") (("2" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -30) (("1" (expand "nice_input?" -1) (("1" (flatten) (("1" (hide -6) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2) (("3" (expand "member" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ac_results" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc") nil nil) ("3" (delete -6) (("3" (hide -1 -2 -6 -7 -8 -9 -10 -11 -13) (("3" (reveal -19) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (case "subset?(V1, ac_sol`3)") (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "difference" 1) (("1" (expand "member" -5) (("1" (expand "difference" -5) (("1" (flatten) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand ("member" "difference") -3) (("2" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 2) (("1" (rewrite "vars_lst_lst_vars") (("1" (inst 2 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 2 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1 2 3) (("2" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (hide -3) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -3) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (assert) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -4) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (flatten) (("1" (inst -4 "y") (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t2") (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (lemma "instantiate_step1_mem") (("2" (inst -1 "t1" "P_C") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (reveal -9) (("2" (expand "i_step_output" -1) (("2" (replace -1) (("2" (replace -3) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (expand "subset?" -8) (("1" (inst -8 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 2) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skolem 1 "z") (("3" (prop) (("3" (rewrite "mem_list2set" :dir rl) (("3" (expand "lst_V" 1) (("3" (rewrite "finset2list_mem") (("3" (expand "cur_V" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "vars" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "t" -1) (("3" (expand "s" -1) (("3" (expand "u_pair" -1) (("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -11) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "subset?" -3) (("2" (inst -3 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "contained?" 1) (("2" (expand "lambda2" 1) (("2" (expand "i_step_output" 1) (("2" (case "subset?(vars(P_C), V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "member" 2 1) (("1" (expand "vars" 2 1) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (expand "subset?" -2) (("2" (flatten) (("2" (inst -3 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (hide -2 -4 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil) ("5" (delete -6) (("5" (expand "subset?" 1) (("5" (skeep) (("5" (hide -2 -7 -8 -9) (("5" (use "vars_img_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -17) (("2" (hide -3 -4 -5 -7) (("2" (case "subset?(V1, ac_sol`3)") (("1" (expand "V1" -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "vars_lst_lst_vars" 1) (("1" (inst 1 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1) (("2" (hide -8 2 3 -1 -2) (("2" (reveal -28) (("2" (case "subset?(vars(P_C), V1)") (("1" (case "subset?(V, V1)") (("1" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -8) (("2" (flatten) (("2" (hide -13) (("2" (expand "subset?" -11) (("2" (inst -11 "y") (("2" (rewrite "vars_unif_prb" -11) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (inst 3 "t2") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (assert) (("2" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (replace -12) (("2" (replace -10) (("2" (replace -2 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -6) (("1" (flatten) (("1" (expand "subset?" -7) (("1" (inst -7 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -3) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (hide -11) (("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5 1 :dir rl) (("2" (expand "i_step_output" 1) (("2" (expand "contained?" 1) (("2" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" -4) (("1" (inst -4 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1") (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "unifies?_append") (("2" (case "disjoint?(dom(sigma), vars(img(lambda2)))") (("1" (prop) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "apply_sub(lambda2, cdr(Pu))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc" 1 :dir rl) (("2" (hide -9 2 -5 -6 -7) (("2" (lemma "unifies?_append_disjoint3") (("2" (inst -1 "sigma" "append(lambda1, delta1)" "apply_sub(lambda2, cdr(Pu))") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2 -2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "cdr(Pu)") (("1" (assert) (("1" (prop) (("1" (expand "append" -3 2) (("1" (expand "unifies?" -3) (("1" (flatten) (("1" (rewrite "unifies?_append" -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 1 "t1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_append") (("2" (prop) (("1" (rewrite "unifies?_equiv") (("1" (skolem 1 "up") (("1" (prop) (("1" (expand "P_CI" -1) (("1" (expand "i_step_output" -1) (("1" (lemma "instantiate_step1_mem_unif_pair") (("1" (inst -1 "null" "up" "P_C") (("1" (assert) (("1" (assert) (("1" (skolem -1 "up1") (("1" (rewrite "append_null") (("1" (prop) (("1" (replace -10) (("1" (replace -8) (("1" (replace -2) (("1" (hide -7) (("1" (case "unifies?(append(lambda1, delta), apply_sub(lambda2, cons(up1, null)))") (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-11 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (use "unifies?_append_disjoint3") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (expand "unifies?" 1) (("1" (expand "unifies?" 1 2) (("1" (rewrite "unifies?_equiv" -6) (("1" (inst -6 "up1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x" "P_C") (("2" (reveal -28) (("2" (prop) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (hide -7) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide-all-but (-1 1 3)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil) ("4" (rewrite "vars_unif_prb") (("4" (inst 1 "t2") (("4" (assert) (("4" (rewrite "member_unif_prb_equiv") (("4" (inst 1 "up1") (("4" (assert) (("4" (expand "member" -4) (("4" (expand "member" -4) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -9) (("2" (lemma "unifies?_append_disjoint3") (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (inst -1 "sigma" "append(lambda1, delta1)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "Ps") (("1" (assert) (("1" (prop) (("1" (hide -1) (("1" (rewrite "unifies?_append" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -21) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (hide-all-but (-2 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (flatten) (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -3 "t3") (("2" (prop) (("2" (replace -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "disjoint?" -3) (("2" (expand "empty?" -3) (("2" (inst -3 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t3") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -8) (("2" (reveal -19) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "lambda2" -3) (("2" (expand "i_step_output" -3) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (lemma "solve_ac_vars") (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (assert) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (hide -8) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (1 -1)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (hide -7) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (use "apply_sub_all_ac") (("3" (assert) (("3" (reveal -14) (("3" (expand "all_ac_prb?" -1) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "up") (("3" (flatten) (("3" (inst -1 "up") (("3" (assert) (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (reveal -15) (("5" (lemma "next_input_nice_input") (("5" (inst -1 "(Pu, Ps, sigma, V)" "_") (("5" (inst -1 "(apply_sub(lambda2, cdr(Pu)), append(P_CI, apply_sub(lambda2, Ps)), append(lambda2, sigma), V1)") (("5" (assert) (("5" (hide 2) (("5" (hide -1 -2 -3 -4 -8 -9) (("5" (reveal -16 -25 -26 -26 -28 -29 -30 -31 -32 -33) (("5" (expand "next_input?" 1) (("5" (replace -1) (("5" (replace -8) (("5" (replace -9) (("5" (replace -7) (("5" (replace -6) (("5" (replace -5) (("5" (replace -4) (("5" (replace -3) (("5" (reveal 3) (("5" (assert) (("5" (use "input_apply_ac_step_mem2") (("5" (assert) (("5" (hide 3) (("5" (inst 1 "P_CI" "lambda2") (("5" (expand "V1" 1) (("5" (expand "ac_results_subs" 1) (("5" (lemma "instantiate_step_lst_mem") (("5" (reveal -3) (("5" (inst?) (("5" (inst -2 "ac_results") (("5" (assert) (("5" (replace -14 :dir rl) (("5" (replace -12) (("5" (replace -13) (("5" (assert) (("5" (replace -5 1 :dir rl) (("5" (reveal -7) (("5" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -27) (("1" (hide -5 -6 -7 -8 -9 -10) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb" -5) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2 1) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb" -5) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 2) (("3" (prop) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 3 -4 -5 -6) (("6" (reveal -22 -16 -17) (("6" (expand "contained?" 1) (("6" (case "subset?(V, V1)") (("1" (case "subset?(V2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand ("member" "difference") -5) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "vars_lst_lst_vars") (("2" (inst 1 "V2") (("2" (assert) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -6 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lemma "more_general_equal") (("7" (inst -1 "append(lambda2, sigma)" "append(lambda1, delta)" "append(lambda1, append(delta1, sigma))") (("7" (hide 3) (("7" (assert) (("7" (split -1) (("1" (rewrite "append_assoc") (("1" (rewrite "append_assoc" :dir rl) (("1" (hide 2) (("1" (use "more_general_append") (("1" (assert) (("1" (hide 2) (("1" (expand "more_general?" 1) (("1" (inst 1 "append(lambda1, delta1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skolem 1 "x") (("2" (inst -1 "x") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (use "subs_equal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1 :dir rl) (("2" (use "instantiate_step_unifies_not_fail") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (reveal -17) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (rewrite "well_formed_unif_prb") (("3" (hide -6) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append") (("3" (flatten) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "solve_ac_vars") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (flatten) (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (reveal -13) (("2" (hide -7 -8 -5 -6) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (expand "u_pair" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skeep) (("2" (inst -1 "X") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_equal?") (("2" (inst -1 "_" "lambda1" "_") (("2" (inst?) (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -2) (("2" (expand "unifies?" -2) (("2" (prop) (("2" (reveal -9 -10) (("2" (assert) (("2" (replace -3) (("2" (replace -1 1 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -6) (("3" (expand "all_ac_prb?" -4) (("3" (expand "t") (("3" (inst -4 "u_pair") (("3" (expand "member" -4) (("3" (expand "ac_prb?" -4) (("3" (flatten) (("3" (expand "is_ac_sym?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (expand "all_ac_prb?" -4) (("4" (inst -4 "u_pair") (("4" (expand "member" -4) (("4" (expand "ac_prb?" -4) (("4" (flatten) (("4" (expand "s" 1) (("4" (expand "is_ac_sym?" 1) (("4" (assert) (("4" (expand "t" -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal 1) (("5" (propax) nil nil)) nil) ("6" (hide 3) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (expand "contained?" -7) (("6" (flatten) (("6" (expand "subset?" -7) (("6" (inst -7 "x") (("6" (assert) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "lst_V") (("6" (rewrite "finset2list_mem") (("6" (expand "cur_V") (("6" (expand ("member" "union") 1) (("6" (expand "member" 1 2) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (expand "subset?" 1) (("7" (skeep) (("7" (expand "contained?" -7) (("7" (flatten) (("7" (expand "subset?" -8) (("7" (inst -8 "x") (("7" (assert) (("7" (rewrite "mem_list2set" :dir rl) (("7" (expand "lst_V") (("7" (rewrite "finset2list_mem") (("7" (expand "cur_V" 1) (("7" (expand ("member" "union") 1) (("7" (expand "member" 1 2) (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 3) (("8" (expand "subset?" 1) (("8" (skeep) (("8" (rewrite "mem_list2set" :dir rl) (("8" (expand "lst_V" 1) (("8" (rewrite "finset2list_mem") (("8" (expand "cur_V" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand "vars" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand ("t" "s")) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 3) (("9" (expand "nice_input?" -5) (("9" (flatten) (("9" (hide -10) (("9" (rewrite "well_formed_unif_prb") (("9" (skolem 1 "t1") (("9" (prop) (("9" (rewrite "well_formed_unif_prb") (("9" (inst -10 "t1") (("9" (assert) (("9" (expand "append" 3) (("9" (expand "member" 3) (("9" (expand "member" -1) (("9" (split -1) (("1" (split) (("1" (assert) (("1" (expand "t" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "s" -1) (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" -7) (("2" (inst -7 "u_pair") (("2" (expand "member" -7) (("2" (assert) (("2" (expand "ac_prb?" -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (unif_prb type-eq-decl nil unification nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (unifies? def-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (all_ac_prb? const-decl "bool" unification nil) (well_formed? const-decl "bool" substitution nil) (nice_input? const-decl "bool" apply_ac_step nil) (contained? const-decl "bool" substitution nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) (member def-decl "bool" list_props nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (subset? const-decl "bool" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (difference const-decl "set" sets nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (subs const-decl "term" substitution nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (img_null formula-decl nil substitution nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nice_input_cdr formula-decl nil apply_ac_step nil) (union const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (solve_ac_unify_complete formula-decl nil aux_unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (ac_prb? const-decl "bool" unification nil) (unifies? const-decl "bool" unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (unifies?_append_disjoint formula-decl nil unification nil) (instantiate_step_unifies_not_fail formula-decl nil aux_unification nil) (well_formed_unif_prb formula-decl nil unification nil) (first_proj_mem formula-decl nil list_theory2 nil) (solve_ac_well_formed formula-decl nil aux_unification nil) (instantiate_step_lst_mem formula-decl nil aux_unification nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (mem_flatten_map2 formula-decl nil map_theory nil) (append_assoc formula-decl nil list_props nil) (finset2list_mem formula-decl nil list_theory nil) (mem_list2set formula-decl nil list_theory nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (sec_proj_mem formula-decl nil list_theory2 nil) (dom_append formula-decl nil substitution nil) (apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (member_unif_prb_append formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (vars_unif_prb formula-decl nil unification nil) (well_formed_append formula-decl nil substitution nil) (vars_img_append formula-decl nil substitution nil) (unifies?_append formula-decl nil unification nil) (subs_append2 formula-decl nil substitution nil) (subs_equal? formula-decl nil substitution nil) (equal?_sym formula-decl nil equality nil) (apply_sub_unifies formula-decl nil unification nil) (unifies?_append_disjoint4 formula-decl nil unification nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (unifies?_append_disjoint3 formula-decl nil unification nil) (instantiate_step1_mem_unif_pair formula-decl nil aux_unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (solve_ac_vars formula-decl nil aux_unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_null formula-decl nil list_props nil) (unifies?_equiv formula-decl nil unification nil) (disjoint? const-decl "bool" sets nil) (apply_sub_all_ac formula-decl nil unification nil) (next_input? const-decl "bool" apply_ac_step nil) (next_input_nice_input formula-decl nil apply_ac_step nil) (list2set def-decl "set[T]" list2set nil) (more_general_append formula-decl nil substitution nil) (more_general_equal formula-decl nil substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (apply_sub_len formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (instantiate_step_unifies_sub formula-decl nil aux_unification nil) (unifies?_equal formula-decl nil unification nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (first_proj def-decl "list[T1]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak))("termination_alg" termination_alg simp_vars_not_ac 0 (simp_vars_not_ac-1 nil 3837336733 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((vars_not_ac const-decl "finite_set[variable]" termination_alg nil) (union const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil)) shostak))("termination_alg" termination_alg simp_vars_not_ac_car 0 (simp_vars_not_ac_car-1 nil 3837336813 ("" (skeep) (("" (lemma "simp_vars_not_ac") (("" (inst?) (("" (lemma "card_subset[variable]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_vars_not_ac formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("termination_alg" termination_alg simp_vars_under2more_subset 0 (simp_vars_under2more_subset-1 nil 3837337207 ("" (skeep) (("" (expand "subset?" 1) (("" (skeep) (("" (expand "vars_under2more" -1) (("" (expand "member" -1 1) (("" (skolem -1 ("t" "s")) (("" (flatten) (("" (rewrite "subterms_mem_unif_prb") (("" (skolem -4 "tS") (("" (prop) (("" (rewrite "subterms_mem_unif_prb") (("" (skolem -6 "sS") (("" (prop) (("" (expand "member" 1) (("" (expand "vars_under2more" 1) (("" (inst 1 "t" "s") (("" (assert) (("" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "tS") (("1" (assert) (("1" (lemma "simplify_mem") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "simplify_mem") (("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "sS") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (subterms_mem_unif_prb formula-decl nil unification nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (simplify def-decl "unif_prb" apply_ac_step nil) (member const-decl "bool" sets nil)) shostak))("termination_alg" termination_alg simp_vars_under2more 0 (simp_vars_under2more-1 nil 3837337671 ("" (skeep) (("" (lemma "simp_vars_under2more_subset") (("" (inst?) (("" (lemma "card_subset[variable]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_vars_under2more_subset formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("termination_alg" termination_alg simp_adm_subterms_subset 0 (simp_adm_subterms_subset-1 nil 3837337830 ("" (skeep) (("" (expand "subset?" 1) (("" (skolem 1 "t") (("" (prop) (("" (expand "admissible_subterms") (("" (expand "member" -1 1) (("" (skolem -1 "tS") (("" (prop) (("" (expand "member" 1 1) (("" (inst 1 "tS") (("" (prop) (("" (lemma "simplify_mem") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil)) shostak))("termination_alg" termination_alg simp_adm_subterms 0 (simp_adm_subterms-1 nil 3837338021 ("" (skeep) (("" (lemma "simp_adm_subterms_subset") (("" (inst?) (("" (lemma "card_subset[term]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((simp_adm_subterms_subset formula-decl nil termination_alg nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (simplify def-decl "unif_prb" apply_ac_step nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (unif_prb type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil)) shostak))("unification" unification apply_sub_equal_sub 0 (apply_sub_equal_sub-1 nil 3854735463 ("" (induct "unif_prb") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (expand "apply_sub" 1 1) (("2" (expand "apply_sub" 1 3) (("2" (decompose-equality 1) (("1" (expand "apply_sub" 1) (("1" (prop) (("1" (hide -1) (("1" (lemma "equal_sub_equiv_alt") (("1" (inst?) (("1" (inst -1 "hd`1") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (inst -1 "sigma" "sigma1") (("2" (assert) (("2" (lemma "equal_sub_subset") (("2" (inst?) (("2" (inst -1 "vars(cons(hd, tail))") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("apply_ac_step" apply_ac_step nice_inp_apply_sub 0 (nice_inp_apply_sub-1 nil 3854797433 ("" (skeep) (("" (assert) (("" (prop) (("" (name-replace "sigma1" "cons((X, s), null)") (("" (reveal -1) (("" (lemma "basic_sub_info") (("" (inst?) (("" (assert) (("" (assert) (("" (replace -2) (("" (flatten) (("" (expand "nice_input?" -5) (("" (flatten) (("" (hide -9 -10) (("" (expand "nice_input?" 2) (("" (prop) (("1" (lemma "idempotent_append") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (rewrite "vars_singleton" 1) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (expand "disjoint?" -8) (("1" (expand "empty?" -8) (("1" (inst -8 "x") (("1" (expand ("member" "intersection") 2) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (delete -8) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (lemma "dom_append") (("2" (inst?) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (lemma "apply_sub_elim_var") (("1" (inst?) (("1" (assert) (("1" (lemma "idempotent_disjoint_dom_img") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" -1) (("1" (expand "empty?" -1) (("1" (inst -1 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t1p") (("2" (prop) (("2" (replace -3) (("2" (lemma "vars_subs_t") (("2" (inst -1 "sigma1" "t1p") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (replace -7) (("1" (rewrite "vars_singleton" -1) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 1) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" -11) (("2" (expand "empty?" -11) (("2" (inst -11 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t1p") (("2" (prop) (("2" (inst -15 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "contained?" 1) (("3" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (delete -8) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (lemma "dom_append") (("1" (inst?) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (replace -2) (("1" (expand ("member" "singleton") -1) (("1" (replace -1) (("1" (replace -1 :dir rl) (("1" (expand "subset?" -9) (("1" (inst -9 "x") (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "variable(x)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand ("member" "singleton") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -2) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (replace -3) (("1" (rewrite "vars_singleton" -1) (("1" (inst -9 "x") (("1" (assert) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -8) (("2" (flatten) (("2" (expand "subset?" -9) (("2" (inst -9 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "subset?" 1) (("4" (skeep) (("4" (expand "subset?" -9) (("4" (inst -9 "x") (("4" (assert) (("4" (rewrite "vars_unif_prb") (("4" (skolem -1 "t1") (("4" (prop) (("4" (rewrite "apply_sub_mem" -1) (("4" (skolem -1 "t1p") (("4" (prop) (("4" (replace -2) (("4" (lemma "vars_subs_t") (("4" (inst?) (("4" (expand "subset?" -1) (("4" (inst -1 "x") (("4" (assert) (("4" (expand ("member" "union") -1) (("4" (prop) (("1" (replace -6) (("1" (rewrite "vars_singleton" -1) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "s") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 2 "t1p") (("2" (assert) (("2" (inst -14 "t1p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -1) (("5" (rewrite "well_formed_unif_prb" 1) (("5" (skolem 1 "t1") (("5" (prop) (("5" (rewrite "apply_sub_mem" -2) (("5" (skolem -2 "t2") (("5" (flatten) (("5" (replace -3 1) (("5" (use "well_formed_subs") (("5" (assert) (("5" (prop) (("1" (expand "sigma1" 1) (("1" (use "basic_sub_well_formed") (("1" (assert) (("1" (assert) (("1" (rewrite "well_formed_unif_prb" -1) (("1" (inst -1 "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -14 "t2") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -1) (("2" (inst -1 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (reveal -1 -2) (("6" (use "well_formed_append") (("6" (assert) (("6" (replace -6 1 :dir rl) (("6" (lemma "basic_sub_well_formed") (("6" (inst?) (("6" (assert) (("6" (rewrite "well_formed_unif_prb" -1) (("6" (inst -1 "s") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (basic_sub_info formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nice_input? const-decl "bool" apply_ac_step nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (unif_prb type-eq-decl nil unification nil) (unif_pair type-eq-decl nil unification nil) (vars_unif_prb formula-decl nil unification nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (vars_singleton formula-decl nil term_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (idempotent_append formula-decl nil substitution nil) (idempotent_disjoint_dom_img formula-decl nil substitution nil) (apply_sub_elim_var formula-decl nil unification nil) (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (apply_sub def-decl "unif_prb" unification nil) (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil) (dom_append formula-decl nil substitution nil) (contained? const-decl "bool" substitution nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (singleton const-decl "(singleton?)" sets nil) (vars_img_append formula-decl nil substitution nil) (well_formed_unif_prb formula-decl nil unification nil) nil (basic_sub_well_formed formula-decl nil substitution nil) (well_formed_subs formula-decl nil substitution nil) (well_formed_append formula-decl nil substitution nil)) shostak))("apply_ac_step" apply_ac_step nice_inp_subterms 0 (nice_inp_subterms-1 nil 3854798131 ("" (skeep) (("" (expand "nice_input?") (("" (prop) (("1" (hide -5 -6) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t") (("1" (prop) (("1" (lemma "vars_subterm2") (("1" (inst?) (("1" (assert) (("1" (skolem -1 "t1") (("1" (prop) (("1" (expand "subset?" -9) (("1" (inst -9 "t1") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (inst 1 "t1S") (("1" (assert) (("1" (lemma "vars_subterm") (("1" (inst -1 "x" "t1" "t1S") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -6) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t") (("2" (prop) (("2" (lemma "vars_subterm2") (("2" (inst?) (("2" (assert) (("2" (skolem -1 "t1") (("2" (prop) (("2" (expand "subset?" -8) (("2" (inst -8 "t1") (("2" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 2 "t1S") (("1" (prop) (("1" (lemma "vars_subterm") (("1" (inst?) (("1" (inst -1 "t1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterms_mem_unif_prb") (("2" (inst 1 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -6) (("3" (expand "well_formed?" 1) (("3" (skeep) (("3" (split 1) (("1" (expand "subset?" -6) (("1" (inst -6 "t") (("1" (flatten) (("1" (assert) (("1" (expand "well_formed?" -7) (("1" (inst -7 "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "no_pair?" -) (("2" (inst -9 "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nice_input? const-decl "bool" apply_ac_step nil) (no_pair? const-decl "bool" unification nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (well_formed? const-decl "bool" unification nil) (empty? const-decl "bool" sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (vars_unif_prb formula-decl nil unification nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (vars_subterm2 formula-decl nil term_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subterms_mem_unif_prb formula-decl nil unification nil) (vars_subterm formula-decl nil term_properties nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil)) shostak))("apply_ac_step" apply_ac_step next_inp_nice_input 0 (next_inp_nice_input-1 nil 3854798368 ("" (skeep) (("" (name-replace "Pu" "input1`1") (("" (name-replace "Ps" "input1`2") (("" (name-replace "sig" "input1`3") (("" (name-replace "V" "input1`4") (("" (reveal -1 -2 -3 -4) (("" (expand "next_input?" -5) (("" (replace -1) (("" (replace -2) (("" (replace -3) (("" (replace -4) (("" (split -5) (("1" (flatten) (("1" (name-replace "t" "car(Pu)`1") (("1" (name-replace "s" "car(Pu)`2") (("1" (hide -4 -5 -6 -7) (("1" (replace -3 2) (("1" (assert) (("1" (hide -3) (("1" (lemma "nice_input_subterms") (("1" (inst -1 "sig" "append(Pu, Ps)" "append(cdr(Pu), Ps)" "V") (("1" (assert) (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "subterms_mem_unif_prb") (("1" (skolem -1 "t1S") (("1" (flatten) (("1" (rewrite "subterms_mem_unif_prb") (("1" (inst 1 "t1S") (("1" (assert) (("1" (expand "append" 1) (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_pair?" 1) (("2" (expand "nice_input?" -3) (("2" (flatten) (("2" (hide -8) (("2" (skolem 1 "t1") (("2" (flatten) (("2" (expand "well_formed?" -9) (("2" (inst -9 "t1") (("2" (flatten) (("2" (hide -9) (("2" (prop) (("2" (expand "append" 1) (("2" (expand "member" 1 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "t" "car(Pu)`1") (("2" (name-replace "s" "car(Pu)`2") (("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("2" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("2" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("2" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("2" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sig, V1)") (("2" (expand "input_lst" -2) (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (skolem -1 ("P_CI" "del")) (("2" (flatten) (("2" (hide -7) (("2" (hide -7 -8 -9 -10) (("2" (replace -2) (("2" (replace -3) (("2" (replace -4) (("2" (replace -5) (("2" (hide -2 -3 -4 -5) (("2" (expand "ac_results_subs" -1) (("2" (use "instantiate_step_mem2") (("2" (assert) (("2" (skolem -1 "P_C") (("2" (flatten) (("2" (expand "ac_results" -1) (("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (hide -11) (("2" (case "subset?(V, V1)") (("1" (hide 1) (("1" (expand "nice_input?" 2) (("1" (case "idempotent?(del)") (("1" (hide -6 -7) (("1" (prop) (("1" (use "idempotent_append") (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -1) (("1" (prop) (("1" (replace -7 -2) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "P_C") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (lemma "solve_ac_vars") (("1" (inst?) (("1" (inst -1 "x") (("1" (assert) (("1" (prop) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 3) (("1" (expand "append" 3) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (prop) (("1" (hide-all-but (3 -1)) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (prop) (("2" (assert) (("2" (expand "contained?" -11) (("2" (flatten) (("2" (delete -12) (("2" (expand "subset?" -11) (("2" (inst -11 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -3) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (flatten) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2 -4) (("1" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -8 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (replace -2 -5) (("2" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2) (("3" (rewrite "apply_sub_elim_var_t2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT member(x, vars(img(del)))") (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2 -4) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst?) (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand ("member" "intersection") 3) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -8 :dir rl) (("2" (replace -9 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2 -5) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (lemma "solve_ac_vars") (("2" (hide -11 -12) (("2" (inst?) (("2" (inst -1 "x") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -12) (("1" (expand "empty?" -12) (("1" (inst -12 "x") (("1" (expand ("member" "intersection") 3) (("1" (expand "append" 3) (("1" (expand "vars" 3) (("1" (expand ("member" "union") 3) (("1" (flatten) (("1" (hide-all-but (-1 3)) (("1" (expand ("t" "s")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V") (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (expand "contained?" -12) (("2" (flatten) (("2" (delete -13) (("2" (expand "subset?" -12) (("2" (inst -12 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (rewrite "vars_unif_prb" 1) (("3" (inst 1 "t2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2 -4) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (expand "disjoint?" -12) (("3" (expand "empty?" -12) (("3" (inst -12 "x") (("3" (expand ("member" "intersection") 3) (("3" (rewrite "vars_unif_prb" 3) (("3" (inst 3 "t2") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (replace -7 -1) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "P_C") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (use "solve_ac_vars") (("2" (assert) (("2" (prop) (("1" (expand "disjoint?" -11) (("1" (expand "empty?" -11) (("1" (inst -11 "x") (("1" (expand ("member" "intersection") 2) (("1" (expand "append" 2) (("1" (expand "vars" 2) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand ("t" "s")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V") (("2" (expand ("member" "union") 1) (("2" (expand "member" 1 2) (("2" (prop) (("2" (expand "contained?" -11) (("2" (flatten) (("2" (delete -12) (("2" (expand "subset?" -11) (("2" (inst -11 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "contained?" 1) (("3" (prop) (("1" (expand "contained?" -8) (("1" (flatten) (("1" (delete -9) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (hide -2) (("1" (replace -6 -1) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_first_proj_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "variable(x)") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 1) (("2" (expand "vars" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "subset?" -9) (("2" (inst -9 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -8) (("2" (flatten) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -2) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (replace -6 -1) (("1" (lemma "instantiate_step_vars_img") (("1" (inst -1 "P_C") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2) (("1" (expand "V1") (("1" (use "solve_ac_first_proj_sec_proj_vars") (("1" (assert) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "t") (("1" (expand "s" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -10) (("2" (inst -10 "x") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -5) (("2" (assert) (("2" (expand "member" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "contained?" -8) (("4" (flatten) (("4" (delete -9) (("4" (case "subset?(vars(img(del)), V1)") (("1" (hide -11) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (rewrite "vars_unif_prb") (("1" (skolem -2 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append" -2) (("1" (rewrite "member_unif_prb_append" -2) (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -4) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -4) (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -13) (("2" (inst -13 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb" 4) (("2" (inst 4 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 4 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (replace -8 :dir rl) (("2" (replace -9 :dir rl) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2 -5) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "vars_unif_prb" 1) (("1" (inst 1 "t2") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (hide-all-but (-1 1 4)) (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -4) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "x") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "subset?" -4) (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "subset?" -14) (("2" (inst -14 "x") (("2" (assert) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (inst 4 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (replace -6 -1) (("2" (lemma "instantiate_step_vars_img") (("2" (inst -1 "P_C") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (expand "V1" 1) (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand "member" 1) (("2" (expand "union" 1 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand "t" -1) (("2" (expand "s" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "contained?" -8) (("5" (flatten) (("5" (delete -9) (("5" (case "well_formed?(del)") (("1" (rewrite "well_formed_unif_prb") (("1" (skolem 1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 1) (("1" (use "well_formed_subs") (("1" (assert) (("1" (rewrite "well_formed_unif_prb") (("1" (inst -13 "t2") (("1" (assert) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "member" 4 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (replace -7 :dir rl) (("2" (replace -8 :dir rl) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (hide 1) (("2" (replace -2) (("2" (use "well_formed_subs") (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -15) (("2" (prop) (("1" (rewrite "well_formed_unif_prb") (("1" (inst -1 "t2") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -14 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (hide-all-but (4 5)) (("2" (expand "t" 2) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -14 "s") (("3" (assert) (("3" (hide-all-but (4 5)) (("3" (rewrite "member_unif_prb_append") (("3" (prop) (("3" (expand "s" 2) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (flatten) (("3" (replace -2 1) (("3" (use "well_formed_subs") (("3" (assert) (("3" (rewrite "well_formed_unif_prb") (("3" (inst -13 "t2") (("3" (assert) (("3" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5) (("2" (lemma "instantiate_step_well_formed") (("2" (inst -1 "P_C") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (rewrite "well_formed_unif_prb" -10) (("2" (hide-all-but (-10 1 4)) (("2" (prop) (("1" (inst -1 "t") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "t" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "s") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "s" 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "contained?" -8) (("6" (flatten) (("6" (delete -9) (("6" (reveal -3) (("6" (use "well_formed_append") (("6" (assert) (("6" (lemma "instantiate_step_well_formed") (("6" (inst -1 "P_C") (("6" (assert) (("6" (lemma "solve_ac_well_formed") (("6" (inst?) (("6" (assert) (("6" (hide 2 3 4) (("6" (rewrite "well_formed_unif_prb" -11) (("6" (prop) (("1" (inst -11 "t") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (expand "t" 1) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -11 "s") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "s" 3) (("2" (expand "member" 3 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (replace -4) (("2" (use "instantiate_step_idempotent3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 4 -10) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" -3) (("2" (lift-if) (("2" (assert) (("2" (expand "member" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nice_input_subterms formula-decl nil apply_ac_step nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (no_pair? const-decl "bool" unification nil) (well_formed? const-decl "bool" unification nil) (nice_input? const-decl "bool" apply_ac_step nil) (subset? const-decl "bool" sets nil) (member def-decl "bool" unification nil) (subterms_mem_unif_prb formula-decl nil unification nil) (append def-decl "list[T]" list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (input_lst skolem-const-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (ac_results_subs skolem-const-decl "list[[unif_prb, sub]]" apply_ac_step nil) (idempotent? const-decl "bool" substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (lst_V skolem-const-decl "list[nat]" apply_ac_step nil) (cur_V skolem-const-decl "finite_set[variable]" apply_ac_step nil) (contained? const-decl "bool" substitution nil) (finset2list_mem formula-decl nil list_theory nil) (s skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" apply_ac_step nil) (t skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" apply_ac_step nil) (solve_ac_vars formula-decl nil aux_unification nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (idempotent_append formula-decl nil substitution nil) (dom_append formula-decl nil substitution nil) (member_unif_prb_append formula-decl nil unification nil) (apply_sub_elim_var_t2 formula-decl nil substitution nil) (apply_sub_mem formula-decl nil unification nil) (instantiate_step1_mem formula-decl nil aux_unification nil) (vars_unif_prb formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (vars_subs_t formula-decl nil substitution nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (vars def-decl "finite_set[variable]" term_properties nil) (NOT const-decl "[bool -> bool]" booleans nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (vars def-decl "finite_set[variable]" term_properties nil) (mem_list2set formula-decl nil list_theory nil) (V1 skolem-const-decl "finite_set[variable]" apply_ac_step nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (member def-decl "bool" list_props nil) (vars_img_append formula-decl nil substitution nil) (well_formed? const-decl "bool" substitution nil) (well_formed_subs formula-decl nil substitution nil) (solve_ac_well_formed formula-decl nil aux_unification nil) (well_formed_unif_prb formula-decl nil unification nil) (instantiate_step_well_formed formula-decl nil aux_unification nil) (well_formed_append formula-decl nil substitution nil) (instantiate_step_idempotent3 formula-decl nil aux_unification nil) (ac_results skolem-const-decl "list[unif_prb]" apply_ac_step nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) (vars def-decl "finite_set[variable]" term_properties nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (union const-decl "set" sets nil) (vars def-decl "finite_set[variable]" unification nil) (next_input? const-decl "bool" apply_ac_step nil) (finite_union application-judgement "finite_set" finite_sets nil)) shostak))("apply_ac_step" apply_ac_step nice_inp_apply_ac_step 0 (nice_inp_apply_ac_step-1 nil 3854800608 ("" (skeep) (("" (postpone) nil nil)) nil) nil shostak))("apply_ac_step" apply_ac_step apply_ac_complete 0 (apply_ac_complete-1 nil 3854800967 ("" (measure-induct "length(unseen_unif_prb)" "unseen_unif_prb") (("" (skolem 1 "Pu") (("" (prop) (("" (skolem 1 ("delta" "Ps" "sigma" "V")) (("" (flatten) (("" (hide -1) (("" (case "null?(Pu)") (("1" (inst 1 "(Ps, sigma, V)" "null") (("1" (prop) (("1" (expand "apply_ac_step" 1) (("1" (lift-if) (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" -2) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "well_formed?" 1) (("4" (skeep) (("4" (expand "subs" 1) (("4" (expand "subs" 1) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "img_null") (("5" (grind) nil nil)) nil) ("6" (expand "append" 1) (("6" (propax) nil nil)) nil)) nil)) nil) ("2" (name-replace "u_pair" "car(Pu)") (("1" (name-replace "t" "u_pair`1") (("1" (name-replace "s" "u_pair`2") (("1" (case "equal?(t, s)") (("1" (reveal -1) (("1" (inst -1 "cdr(Pu)") (("1" (prop) (("1" (inst?) (("1" (inst -1 "Ps" "sigma") (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (inst 2 "ac_sol" "gamma") (("1" (assert) (("1" (delete -6) (("1" (expand "apply_ac_step" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (expand "unifies?" -5) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "all_ac_prb?") (("3" (skeep) (("3" (inst -7 "unif_pair") (("3" (assert) (("3" (expand "member" 3) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "nice_input_cdr") (("4" (hide 3) (("4" (inst -1 "sigma" "append(Pu, Ps)" "V") (("4" (expand "append" -1 1) (("4" (expand "append" -1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (name-replace "f" "ac_sym(t)") (("1" (name-replace "ac_results" "first_proj(solve_ac(t, s, lst_V, f))") (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (name-replace "ac_results_subs" "instantiate_step(ac_results)") (("1" (name-replace "input_lst" "input_apply_ac_step(ac_results_subs, cdr(Pu), Ps, sigma, V1)") (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9) (("1" (lemma "solve_ac_unify_complete") (("1" (inst -1 "delta" "f" "s" "t" "lst_V") (("1" (assert) (("1" (prop) (("1" (skolem -1 ("P_C" "lambda1" "V2")) (("1" (flatten) (("1" (hide -3 -4 -5 -9 -10 -11 -8) (("1" (hide -3) (("1" (name-replace "i_step_output" "instantiate_step(P_C, null, null)") (("1" (name-replace "P_CI" "i_step_output`1") (("1" (name-replace "lambda2" "i_step_output`2") (("1" (expand "more_general?" -7) (("1" (skolem -7 "delta1") (("1" (lemma "unifies?_equal") (("1" (inst -1 "delta" "append(delta1, sigma)" "append(Pu, Ps)") (("1" (assert) (("1" (hide -7) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, delta)" "append(append(lambda1, delta1), sigma)" "P_C") (("1" (case "equal?(append(lambda1, delta), append(append(lambda1, delta1), sigma))") (("1" (assert) (("1" (hide -1 -8) (("1" (lemma "unifies?_append_disjoint") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (lemma "instantiate_step_unifies_sub") (("1" (inst -1 "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (replace -6) (("1" (replace -4) (("1" (assert) (("1" (prop) (("1" (reveal -26) (("1" (inst -1 "apply_sub(lambda2, cdr(Pu))") (("1" (prop) (("1" (inst -1 "append(lambda1, delta)" "append(P_CI, apply_sub(lambda2, Ps))" "append(lambda2, sigma)" "V1") (("1" (prop) (("1" (skolem -1 ("ac_sol" "gamma")) (("1" (flatten) (("1" (inst 2 "ac_sol" "append(gamma, lambda1)") (("1" (prop) (("1" (delete -6) (("1" (reveal -18 -19 -20 -21 -22 -23 -24 -25 -26) (("1" (reveal -9) (("1" (expand "apply_ac_step" 1) (("1" (replace -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but (-1 -10 -11 2)) (("1" (reveal 3) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (replace -10) (("2" (replace -9) (("2" (replace -8) (("2" (replace -7) (("2" (replace -6) (("2" (replace -5) (("2" (split 1) (("1" (flatten) (("1" (hide -10 -11 -12 -13 -14 -15 -16 -17 -18 -19) (("1" (lemma "instantiate_step_lst_mem") (("1" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("1" (assert) (("1" (prop) (("1" (expand "member" -1) (("1" (propax) nil nil)) nil) ("2" (use "solve_ac_well_formed") (("2" (assert) (("2" (reveal -26) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2 1) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ac_results" 1) (("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (rewrite "mem_flatten_map2") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (hide -12 -13 -14 -15 -16 -17 -18 -19 -21) (("2" (use "input_apply_ac_step_mem2") (("2" (assert) (("2" (hide 2) (("2" (inst 1 "P_CI" "lambda2") (("2" (reveal -9 -10) (("2" (hide -13 -16 -9 -10) (("2" (lemma "instantiate_step_lst_mem") (("2" (inst -1 "ac_results" "append(lambda1, delta1)" "P_C") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -30) (("1" (expand "nice_input?" -1) (("1" (flatten) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (delete -4) (("1" (hide -6) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "well_formed_unif_prb") (("3" (inst -5 "s") (("3" (assert) (("3" (expand "append" 2) (("3" (expand "member" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ac_results" 1) (("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc") nil nil) ("3" (delete -6) (("3" (hide -1 -2 -6 -7 -8 -9 -10 -11 -13) (("3" (reveal -19) (("3" (expand "subset?" 1) (("3" (skeep) (("3" (case "subset?(V1, ac_sol`3)") (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand "member" 1) (("1" (expand "difference" 1) (("1" (expand "member" -5) (("1" (expand "difference" -5) (("1" (flatten) (("1" (assert) (("1" (expand "V1" 1) (("1" (use "solve_ac_sec_proj_vars") (("1" (assert) (("1" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V") (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2) (("1" (expand "member" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "member" 1) (("2" (expand "difference" 1) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (expand ("member" "difference") -3) (("2" (prop) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "V1" 2) (("1" (rewrite "vars_lst_lst_vars") (("1" (inst 2 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 2 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand "member" 1) (("2" (expand "union" 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1 2 3) (("2" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (hide -3) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (prop) (("1" (replace -2 -3) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (assert) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (expand "subset?" -4) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (flatten) (("1" (inst -4 "y") (("1" (rewrite "vars_unif_prb") (("1" (inst 1 "t2") (("1" (expand "member" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (lemma "instantiate_step1_mem") (("2" (inst -1 "t1" "P_C") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (reveal -9) (("2" (expand "i_step_output" -1) (("2" (replace -1) (("2" (replace -3) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -7) (("1" (flatten) (("1" (expand "subset?" -8) (("1" (inst -8 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 2) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "subset?" 1) (("3" (skolem 1 "z") (("3" (prop) (("3" (rewrite "mem_list2set" :dir rl) (("3" (expand "lst_V" 1) (("3" (rewrite "finset2list_mem") (("3" (expand "cur_V" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "vars" 1) (("3" (expand ("member" "union") 1) (("3" (prop) (("3" (expand "t" -1) (("3" (expand "s" -1) (("3" (expand "u_pair" -1) (("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -11) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -28) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (expand "subset?" -3) (("2" (inst -3 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "contained?" 1) (("2" (expand "lambda2" 1) (("2" (expand "i_step_output" 1) (("2" (case "subset?(vars(P_C), V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "member" 2 1) (("1" (expand "vars" 2 1) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (expand "subset?" -2) (("2" (flatten) (("2" (inst -3 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (expand "V1" 1) (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (hide -2 -4 2) (("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s")) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil) ("5" (delete -6) (("5" (expand "subset?" 1) (("5" (skeep) (("5" (hide -2 -7 -8 -9) (("5" (use "vars_img_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -17) (("2" (hide -3 -4 -5 -7) (("2" (case "subset?(V1, ac_sol`3)") (("1" (expand "V1" -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "vars_lst_lst_vars" 1) (("1" (inst 1 "V2") (("1" (assert) (("1" (rewrite "sec_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (use "apply_ac_step_vars2avoid") (("2" (assert) (("2" (hide -1) (("2" (hide -8 2 3 -1 -2) (("2" (reveal -28) (("2" (case "subset?(vars(P_C), V1)") (("1" (case "subset?(V, V1)") (("1" (case "contained?(lambda2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (prop) (("1" (rewrite "member_unif_prb_append") (("1" (rewrite "member_unif_prb_append") (("1" (prop) (("1" (rewrite "apply_sub_mem") (("1" (skolem -1 "t2") (("1" (flatten) (("1" (replace -2) (("1" (use "vars_subs_t") (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -8) (("2" (flatten) (("2" (expand "contained?" -10) (("2" (flatten) (("2" (delete -11) (("2" (hide -13) (("2" (expand "subset?" -11) (("2" (inst -11 "y") (("2" (rewrite "vars_unif_prb" -11) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (inst 3 "t2") (("2" (assert) (("2" (expand "append" 3) (("2" (expand "member" 3) (("2" (assert) (("2" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "P_CI" -1) (("2" (expand "i_step_output" -1) (("2" (use "instantiate_step1_mem") (("2" (assert) (("2" (assert) (("2" (skolem -1 "t2") (("2" (flatten) (("2" (replace -12) (("2" (replace -10) (("2" (replace -2 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -6) (("1" (flatten) (("1" (expand "subset?" -7) (("1" (inst -7 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (rewrite "vars_unif_prb" 3) (("2" (inst 3 "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "apply_sub_mem") (("3" (skolem -1 "t2") (("3" (prop) (("3" (replace -2 -3) (("3" (use "vars_subs_t") (("3" (expand "subset?" -1) (("3" (inst -1 "y") (("3" (assert) (("3" (expand ("member" "union") -1) (("3" (prop) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (prop) (("1" (rewrite "vars_unif_prb" 3) (("1" (inst 3 "t2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "dom_append") (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "contained?" -3) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -6) (("2" (flatten) (("2" (expand "contained?" -8) (("2" (flatten) (("2" (delete -9) (("2" (hide -11) (("2" (expand "subset?" -8) (("2" (inst -8 "y") (("2" (assert) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "member" 2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -16) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -5 1 :dir rl) (("2" (expand "i_step_output" 1) (("2" (expand "contained?" 1) (("2" (prop) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (use "instantiate_step_dom2") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "subset?" -4) (("1" (inst -4 "y") (("1" (assert) (("1" (rewrite "vars_unif_prb" 2) (("1" (inst 2 "variable(y)") (("1" (assert) (("1" (expand "vars" 2) (("1" (expand "member" 2) (("1" (expand "singleton" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (expand "subset?" 1) (("1" (skolem 1 "y") (("1" (prop) (("1" (inst -1 "y") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1") (("2" (expand "subset?" 1) (("2" (skolem 1 "y") (("2" (prop) (("2" (use "solve_ac_first_proj_sec_proj_vars") (("2" (assert) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "subset?" 1) (("2" (skolem 1 "z") (("2" (prop) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (hide-all-but (-1 1)) (("2" (expand ("t" "s") -1) (("2" (expand "u_pair" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "unifies?_append") (("2" (case "disjoint?(dom(sigma), vars(img(lambda2)))") (("1" (prop) (("1" (lemma "unifies?_equal") (("1" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "apply_sub(lambda2, cdr(Pu))") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (lemma "subs_equal?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "append_assoc" 1 :dir rl) (("2" (hide -9 2 -5 -6 -7) (("2" (lemma "unifies?_append_disjoint3") (("2" (inst -1 "sigma" "append(lambda1, delta1)" "apply_sub(lambda2, cdr(Pu))") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2 -2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "cdr(Pu)") (("1" (assert) (("1" (prop) (("1" (expand "append" -3 2) (("1" (expand "unifies?" -3) (("1" (flatten) (("1" (rewrite "unifies?_append" -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (hide-all-but (-2 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 1 "t1") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -6) (("1" (expand "empty?" -6) (("1" (inst -6 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -23) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (expand "disjoint?" -2) (("2" (expand "empty?" -2) (("2" (inst -2 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t2") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (prop) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "unifies?_append") (("2" (prop) (("1" (rewrite "unifies?_equiv") (("1" (skolem 1 "up") (("1" (prop) (("1" (expand "P_CI" -1) (("1" (expand "i_step_output" -1) (("1" (lemma "instantiate_step1_mem_unif_pair") (("1" (inst -1 "null" "up" "P_C") (("1" (assert) (("1" (assert) (("1" (skolem -1 "up1") (("1" (rewrite "append_null") (("1" (prop) (("1" (replace -10) (("1" (replace -8) (("1" (replace -2) (("1" (hide -7) (("1" (case "unifies?(append(lambda1, delta), apply_sub(lambda2, cons(up1, null)))") (("1" (expand "apply_sub" -1) (("1" (expand "unifies?" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-11 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (use "unifies?_append_disjoint3") (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (expand "unifies?" 1) (("1" (expand "unifies?" 1 2) (("1" (rewrite "unifies?_equiv" -6) (("1" (inst -6 "up1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -2 "t2") (("2" (prop) (("2" (replace -3 -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -9) (("1" (expand "empty?" -9) (("1" (inst -9 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -10 -11 -12 -13 -14) (("2" (lemma "solve_ac_vars") (("2" (inst?) (("2" (inst -1 "x" "P_C") (("2" (reveal -28) (("2" (prop) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (expand "contained?" -4) (("1" (flatten) (("1" (delete -5) (("1" (hide -7) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (hide-all-but (-1 1 3)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil) ("4" (rewrite "vars_unif_prb") (("4" (inst 1 "t2") (("4" (assert) (("4" (rewrite "member_unif_prb_equiv") (("4" (inst 1 "up1") (("4" (assert) (("4" (expand "member" -4) (("4" (expand "member" -4) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "unifies?_equal") (("2" (inst -1 "append(lambda1, append(delta1, sigma))" "append(lambda1, delta)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide-all-but (-9 1)) (("1" (expand "equal?") (("1" (skeep) (("1" (inst -1 "X") (("1" (expand "subs") (("1" (use "equal?_sym") (("1" (assert) (("1" (hide 2) (("1" (rewrite "subs_append2") (("1" (rewrite "subs_append2") (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -9) (("2" (lemma "unifies?_append_disjoint3") (("2" (rewrite "append_assoc" 1 :dir rl) (("2" (inst -1 "sigma" "append(lambda1, delta1)" "_") (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (hide 2) (("1" (rewrite "apply_sub_unifies") (("1" (use "unifies?_equal") (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint4") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "unifies?_append_disjoint3") (("1" (inst -1 "sigma" "delta1" "Ps") (("1" (assert) (("1" (prop) (("1" (hide -1) (("1" (rewrite "unifies?_append" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -21) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (hide-all-but (-2 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (flatten) (("2" (inst 1 "t1") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (rewrite "vars_unif_prb") (("2" (skolem -3 "t2") (("2" (prop) (("2" (rewrite "apply_sub_mem") (("2" (skolem -3 "t3") (("2" (prop) (("2" (replace -4) (("2" (use "vars_subs_t") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "disjoint?" -7) (("1" (expand "empty?" -7) (("1" (inst -7 "x") (("1" (expand ("member" "intersection") 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (expand "contained?" -4) (("2" (flatten) (("2" (delete -5) (("2" (hide -7) (("2" (expand "disjoint?" -3) (("2" (expand "empty?" -3) (("2" (inst -3 "x") (("2" (expand ("member" "intersection") 1) (("2" (rewrite "vars_unif_prb") (("2" (inst 1 "t3") (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -8) (("2" (reveal -19) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (prop) (("2" (expand "lambda2" -3) (("2" (expand "i_step_output" -3) (("2" (use "instantiate_step_vars_img") (("2" (assert) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -4) (("2" (lemma "solve_ac_vars") (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (assert) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (expand "contained?" -5) (("1" (flatten) (("1" (delete -6) (("1" (hide -8) (("1" (expand "disjoint?" -4) (("1" (expand "empty?" -4) (("1" (inst -4 "x") (("1" (expand ("member" "intersection") 1) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide-all-but (1 -1)) (("1" (expand ("t" "s")) (("1" (expand "u_pair") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (expand "contained?" -4) (("2" (flatten) (("2" (delete -5) (("2" (hide -7) (("2" (expand "lst_V" 1) (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (use "apply_sub_all_ac") (("3" (assert) (("3" (reveal -14) (("3" (expand "all_ac_prb?" -1) (("3" (expand "all_ac_prb?" 1) (("3" (skolem 1 "up") (("3" (flatten) (("3" (inst -1 "up") (("3" (assert) (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (rewrite "well_formed_append") (("4" (reveal -12) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (reveal -15) (("5" (lemma "next_input_nice_input") (("5" (inst -1 "(Pu, Ps, sigma, V)" "_") (("5" (inst -1 "(apply_sub(lambda2, cdr(Pu)), append(P_CI, apply_sub(lambda2, Ps)), append(lambda2, sigma), V1)") (("5" (assert) (("5" (hide 2) (("5" (hide -1 -2 -3 -4 -8 -9) (("5" (reveal -16 -25 -26 -26 -28 -29 -30 -31 -32 -33) (("5" (expand "next_input?" 1) (("5" (replace -1) (("5" (replace -8) (("5" (replace -9) (("5" (replace -7) (("5" (replace -6) (("5" (replace -5) (("5" (replace -4) (("5" (replace -3) (("5" (reveal 3) (("5" (assert) (("5" (use "input_apply_ac_step_mem2") (("5" (assert) (("5" (hide 3) (("5" (inst 1 "P_CI" "lambda2") (("5" (expand "V1" 1) (("5" (expand "ac_results_subs" 1) (("5" (lemma "instantiate_step_lst_mem") (("5" (reveal -3) (("5" (inst?) (("5" (inst -2 "ac_results") (("5" (assert) (("5" (replace -14 :dir rl) (("5" (replace -12) (("5" (replace -13) (("5" (assert) (("5" (replace -5 1 :dir rl) (("5" (reveal -7) (("5" (prop) (("1" (use "solve_ac_well_formed") (("1" (assert) (("1" (reveal -27) (("1" (hide -5 -6 -7 -8 -9 -10) (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb" -5) (("2" (inst -5 "t") (("2" (assert) (("2" (expand "append" 2 1) (("2" (expand "member" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (expand "contained?" -3) (("3" (flatten) (("3" (delete -4) (("3" (rewrite "well_formed_unif_prb" -5) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append" 2) (("3" (prop) (("3" (expand "member" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 3 -4 -5 -6) (("6" (reveal -22 -16 -17) (("6" (expand "contained?" 1) (("6" (case "subset?(V, V1)") (("1" (case "subset?(V2, V1)") (("1" (prop) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (use "dom_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (prop) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (expand ("member" "difference") -5) (("1" (prop) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -7) (("2" (inst -7 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (prop) (("1" (expand "subset?" -6) (("1" (inst -6 "x") (("1" (assert) (("1" (expand "subset?" -3) (("1" (inst -3 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "contained?" -7) (("2" (flatten) (("2" (expand "subset?" -8) (("2" (inst -8 "x") (("2" (assert) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "vars_lst_lst_vars") (("2" (inst 1 "V2") (("2" (assert) (("2" (rewrite "sec_proj_mem") (("2" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "V1" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (use "solve_ac_sec_proj_vars") (("2" (prop) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (expand "lst_V" 1) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" 1) (("1" (expand ("member" "union") 1) (("1" (expand "member" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -6 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lemma "more_general_equal") (("7" (inst -1 "append(lambda2, sigma)" "append(lambda1, delta)" "append(lambda1, append(delta1, sigma))") (("7" (hide 3) (("7" (assert) (("7" (split -1) (("1" (rewrite "append_assoc") (("1" (rewrite "append_assoc" :dir rl) (("1" (hide 2) (("1" (use "more_general_append") (("1" (assert) (("1" (hide 2) (("1" (expand "more_general?" 1) (("1" (inst 1 "append(lambda1, delta1)") (("1" (rewrite "append_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skolem 1 "x") (("2" (inst -1 "x") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (use "subs_equal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "apply_sub_len") (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1 :dir rl) (("2" (use "instantiate_step_unifies_not_fail") (("2" (assert) (("2" (assert) (("2" (use "solve_ac_well_formed") (("2" (reveal -17) (("2" (prop) (("1" (rewrite "first_proj_mem" 1) (("1" (inst 1 "(P_C, V2)") nil nil)) nil) ("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (rewrite "well_formed_unif_prb") (("2" (inst -5 "t") (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (flatten) (("2" (expand "member" 2) (("2" (expand "t" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nice_input?" -1) (("3" (flatten) (("3" (expand "contained?" -3) (("3" (flatten) (("3" (delete -4) (("3" (rewrite "well_formed_unif_prb") (("3" (hide -6) (("3" (inst -5 "s") (("3" (assert) (("3" (rewrite "member_unif_prb_append") (("3" (flatten) (("3" (expand "member" 2) (("3" (expand "s" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "solve_ac_vars") (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -2) (("2" (flatten) (("2" (inst -1 "x" "f" "s" "t" "P_C" "lst_V") (("2" (reveal -13) (("2" (hide -7 -8 -5 -6) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "contained?" -3) (("2" (flatten) (("2" (delete -4) (("2" (hide -6) (("2" (prop) (("1" (expand "disjoint?" -3) (("1" (expand "empty?" -3) (("1" (inst -3 "x") (("1" (expand ("member" "intersection") 1) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "vars" 1) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (expand "t" -1) (("1" (expand "s" -1) (("1" (expand "u_pair" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V") (("2" (rewrite "finset2list_mem") (("2" (expand "cur_V" 1) (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_proj_mem") (("3" (inst 1 "(P_C, V2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand "equal?") (("2" (skeep) (("2" (inst -1 "X") (("2" (expand "subs") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (lemma "subs_equal?") (("2" (inst -1 "_" "lambda1" "_") (("2" (inst?) (("2" (assert) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -2) (("2" (expand "unifies?" -2) (("2" (prop) (("2" (reveal -9 -10) (("2" (assert) (("2" (replace -3) (("2" (replace -1 1 :dir rl) (("2" (replace -2 1 :dir rl) (("2" (expand "unifies?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -6) (("3" (expand "all_ac_prb?" -4) (("3" (expand "t") (("3" (inst -4 "u_pair") (("3" (expand "member" -4) (("3" (expand "ac_prb?" -4) (("3" (flatten) (("3" (expand "is_ac_sym?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (reveal -6) (("4" (expand "all_ac_prb?" -4) (("4" (inst -4 "u_pair") (("4" (expand "member" -4) (("4" (expand "ac_prb?" -4) (("4" (flatten) (("4" (expand "s" 1) (("4" (expand "is_ac_sym?" 1) (("4" (assert) (("4" (expand "t" -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal 1) (("5" (propax) nil nil)) nil) ("6" (hide 3) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (expand "contained?" -7) (("6" (flatten) (("6" (expand "subset?" -7) (("6" (inst -7 "x") (("6" (assert) (("6" (rewrite "mem_list2set" :dir rl) (("6" (expand "lst_V") (("6" (rewrite "finset2list_mem") (("6" (expand "cur_V") (("6" (expand ("member" "union") 1) (("6" (expand "member" 1 2) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 3) (("7" (expand "subset?" 1) (("7" (skeep) (("7" (expand "contained?" -7) (("7" (flatten) (("7" (expand "subset?" -8) (("7" (inst -8 "x") (("7" (assert) (("7" (rewrite "mem_list2set" :dir rl) (("7" (expand "lst_V") (("7" (rewrite "finset2list_mem") (("7" (expand "cur_V" 1) (("7" (expand ("member" "union") 1) (("7" (expand "member" 1 2) (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 3) (("8" (expand "subset?" 1) (("8" (skeep) (("8" (rewrite "mem_list2set" :dir rl) (("8" (expand "lst_V" 1) (("8" (rewrite "finset2list_mem") (("8" (expand "cur_V" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand "vars" 1) (("8" (expand ("member" "union") 1) (("8" (prop) (("8" (expand ("t" "s")) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 3) (("9" (expand "nice_input?" -5) (("9" (flatten) (("9" (hide -10) (("9" (expand "contained?" -7) (("9" (flatten) (("9" (delete -8) (("9" (rewrite "well_formed_unif_prb") (("9" (skolem 1 "t1") (("9" (prop) (("9" (rewrite "well_formed_unif_prb") (("9" (inst -10 "t1") (("9" (assert) (("9" (expand "append" 3) (("9" (expand "member" 3) (("9" (expand "member" -1) (("9" (split -1) (("1" (split) (("1" (assert) (("1" (expand "t" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "s" -1) (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "all_ac_prb?" -7) (("2" (inst -7 "u_pair") (("2" (expand "member" -7) (("2" (assert) (("2" (expand "ac_prb?" -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finset2list def-decl "list[T]" list_theory nil) nil (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (unifies?_equal formula-decl nil unification nil) nil (instantiate_step_unifies_sub formula-decl nil aux_unification nil) (apply_sub def-decl "unif_prb" unification nil) (apply_sub_len formula-decl nil unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (more_general_equal formula-decl nil substitution nil) (more_general_append formula-decl nil substitution nil) (list2set def-decl "set[T]" list2set nil) (next_input_nice_input formula-decl nil apply_ac_step nil) nil (next_input? const-decl "bool" apply_ac_step nil) (apply_sub_all_ac formula-decl nil unification nil) (disjoint? const-decl "bool" sets nil) (unifies?_equiv formula-decl nil unification nil) (append_null formula-decl nil list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (solve_ac_vars formula-decl nil aux_unification nil) (member_unif_prb_equiv formula-decl nil unification nil) (instantiate_step1_mem_unif_pair formula-decl nil aux_unification nil) (unifies?_append_disjoint3 formula-decl nil unification nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (unifies?_append_disjoint4 formula-decl nil unification nil) (apply_sub_unifies formula-decl nil unification nil) (equal?_sym formula-decl nil equality nil) (subs_equal? formula-decl nil substitution nil) (subs_append2 formula-decl nil substitution nil) (unifies?_append formula-decl nil unification nil) (vars_img_append formula-decl nil substitution nil) (well_formed_append formula-decl nil substitution nil) (vars_unif_prb formula-decl nil unification nil) nil (instantiate_step1_mem formula-decl nil aux_unification nil) (solve_ac_first_proj_sec_proj_vars formula-decl nil aux_unification nil) nil nil (apply_sub_mem formula-decl nil unification nil) (vars_subs_t formula-decl nil substitution nil) (member_unif_prb_append formula-decl nil unification nil) (instantiate_step_dom2 formula-decl nil aux_unification nil) nil (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (instantiate_step_vars_img formula-decl nil aux_unification nil) nil (apply_ac_step_vars2avoid formula-decl nil apply_ac_step nil) (dom_append formula-decl nil substitution nil) (sec_proj_mem formula-decl nil list_theory2 nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (mem_list2set formula-decl nil list_theory nil) (finset2list_mem formula-decl nil list_theory nil) nil nil nil (append_assoc formula-decl nil list_props nil) (mem_flatten_map2 formula-decl nil map_theory nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (instantiate_step_lst_mem formula-decl nil aux_unification nil) nil (solve_ac_well_formed formula-decl nil aux_unification nil) nil (well_formed_unif_prb formula-decl nil unification nil) nil nil (first_proj_mem formula-decl nil list_theory2 nil) (instantiate_step_unifies_not_fail formula-decl nil aux_unification nil) (unifies?_append_disjoint formula-decl nil unification nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (unifies? const-decl "bool" unification nil) (ac_prb? const-decl "bool" unification nil) (is_ac_sym? const-decl "bool" term_properties nil) (solve_ac_unify_complete formula-decl nil aux_unification nil) (input_apply_ac_step def-decl "list[[unif_prb, unif_prb, sub, finite_set[variable]]]" apply_ac_step nil) nil (sec_proj def-decl "list[T2]" list_theory2 nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (finite_union application-judgement "finite_set" finite_sets nil) (union const-decl "set" sets nil) nil (nice_input_cdr formula-decl nil apply_ac_step nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (null adt-constructor-decl "(null?)" list_adt nil) (img_null formula-decl nil substitution nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (empty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) nil nil (subs const-decl "term" substitution nil) (member const-decl "bool" sets nil) (finite_difference application-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) nil (difference const-decl "set" sets nil) (dom const-decl "finite_set[variable]" substitution nil) (subset? const-decl "bool" sets nil) (apply_ac_step def-decl "list[ac_sol_simp]" apply_ac_step nil) (member def-decl "bool" list_props nil) (ac_sol_simp type-eq-decl nil apply_ac_step nil) nil (contained? const-decl "bool" substitution nil) (nice_input? const-decl "bool" apply_ac_step nil) (well_formed? const-decl "bool" substitution nil) (all_ac_prb? const-decl "bool" unification nil) (append def-decl "list[T]" list_props nil) (unifies? def-decl "bool" unification nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (unif_prb type-eq-decl nil unification nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (unif_pair type-eq-decl nil unification nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("rename_input" rename_input ren_input_inst_step_TCC1 0 (ren_input_inst_step_TCC1-1 nil 3855430118 ("" (subtype-tcc) nil nil) nil nil (ren_input_inst_step subtype "(unification.apply_sub(rename_input.sig1, rename_input.P1), list_props[basic_sub].append(rename_input.sig1, rename_input.input`2), rename_input.input`3)" "nice_input")))("rename_input" rename_input ren_input_inst_step_TCC2 0 (ren_input_inst_step_TCC2-1 nil 3855430118 ("" (subtype-tcc) nil nil) nil nil (ren_input_inst_step subtype "(unification.apply_sub(rename_input.sig1_, rename_input.P1_), list_props[basic_sub].append(rename_input.sig1_, rename_input.input_`2), rename_input.input_`3)" "nice_input")))("list_theory" list_theory mem_finset2list2set_TCC1 0 (mem_finset2list2set_TCC1-1 nil 3855858256 ("" (subtype-tcc) nil nil) nil nil (mem_finset2list2set subtype "list2set[list_theory.T].list2set(list_theory.lst)" "finite_set[T]")))("list_theory" list_theory mem_finset2list2set 0 (mem_finset2list2set-1 nil 3855858259 ("" (skeep) (("" (postpone) nil nil)) nil) nil shostak))("substitution" substitution subs_map_append 0 (subs_map_append-1 nil 3855861103 ("" (induct "args") (("1" (grind) nil nil) ("2" (skolem 1 ("hd" "tail")) (("2" (prop) (("2" (skeep) (("2" (inst -1 "delta" "sigma") (("2" (expand "subs" 1 3) (("2" (expand "subs" 1 1) (("2" (expand "subs" 1 3) (("2" (replace -1) (("2" (decompose-equality 1) (("2" (rewrite "subs_append2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) nil (args type-eq-decl nil term_properties nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (subs def-decl "args" substitution nil) (append def-decl "list[T]" list_props nil) (variable type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (int nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (list_induction formula-decl nil list_adt nil) (subs_append2 formula-decl nil substitution nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) nil) shostak))("aux_unification" aux_unification get_pre_new_args_subs_TCC1 0 (get_pre_new_args_subs_TCC1-1 nil 3855856486 ("" (subtype-tcc) nil nil) nil nil (get_pre_new_args_subs subtype "list2set[variable].list2set(aux_unification.lst_V)" "finite_set[nat]")))("aux_unification" aux_unification get_pre_new_args_subs 0 (get_pre_new_args_subs-1 nil 3855857230 ("" (measure-induct "length(dio)" "dio") (("1" (skolem 1 "D") (("1" (prop) (("1" (skeep) (("1" (expand "get_pre_new_args" 1 2) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (name-replace "t" "variable(get_new_var(lst_V))") (("2" (reveal -1) (("2" (case "subs(sigma)(t)=t") (("1" (replace -1 :dir rl) (("1" (rewrite "add_new_arg_subs") (("1" (expand "get_pre_new_args" 2 1) (("1" (assert) (("1" (replace -2) (("1" (replace -1) (("1" (inst -3 "cdr(D)") (("1" (prop) (("1" (inst?) (("1" (prop) (("1" (hide -3 3) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "finset2list_mem") (("1" (rewrite "mem_list2set" :dir rl) (("1" (reveal -1) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "finset2list_mem") (("1" (rewrite "mem_list2set" :dir rl) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "sigma" "t") (("2" (prop) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skeep) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (expand "t" -2) (("2" (expand "vars" -2) (("2" (expand "singleton" -2) (("2" (expand "member" -2 1) (("2" (expand "get_new_var" -2) (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "finset2list_mem") (("2" (rewrite "mem_list2set" :dir rl) (("2" (use "select_greater_lt[nat]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "is_fin_lst2set_2") nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (dio_matrix type-eq-decl nil diophantine nil) (int nonempty-type-eq-decl nil integers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (variable type-eq-decl nil term_properties nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (list2set def-decl "set[T]" list2set nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) nil (TRUE const-decl "bool" booleans nil) (args type-eq-decl nil term_properties nil) (constant type-eq-decl nil term_properties nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (dom const-decl "finite_set[variable]" substitution nil) (finset2list def-decl "list[T]" list_theory nil) (= const-decl "[T, T -> boolean]" equalities nil) nil (subs def-decl "args" substitution nil) (get_pre_new_args def-decl "[list[args], list[variable]]" aux_unification nil) (get_new_var const-decl "variable" aux_unification nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) nil (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (add_new_arg_subs formula-decl nil aux_unification nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (mem_list2set formula-decl nil list_theory nil) (subs const-decl "term" substitution nil) (member const-decl "bool" sets nil) (member def-decl "bool" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (finset2list_mem formula-decl nil list_theory nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (add_new_arg def-decl "list[args]" aux_unification nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (subs_no_effect_t formula-decl nil substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) nil (singleton const-decl "(singleton?)" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (select_greater_lt formula-decl nil list_theory nil) nil (disjoint? const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (is_fin_lst2set_2 formula-decl nil list_theory nil)) shostak))("aux_unification" aux_unification if_non_var_const2_ren 0 (if_non_var_const2_ren-1 nil 3855946043 ("" (postpone) nil nil) nil shostak))("aux_unification" aux_unification solve_ac_sec_proj_vars2_TCC1 0 (solve_ac_sec_proj_vars2_TCC1-1 nil 3856529544 ("" (subtype-tcc) nil nil) nil nil (solve_ac_sec_proj_vars2 subtype "aux_unification.mult_t1" "list[posnat]")))("aux_unification" aux_unification solve_ac_sec_proj_vars2_TCC2 0 (solve_ac_sec_proj_vars2_TCC2-1 nil 3856529544 ("" (subtype-tcc) nil nil) nil nil (solve_ac_sec_proj_vars2 subtype "aux_unification.mult_t2" "list[posnat]")))("aux_unification" aux_unification solve_ac_sec_proj_vars2 0 (solve_ac_sec_proj_vars2-1 nil 3856529752 ("" (skeep) (("" (assert) (("" (name-replace "Z" "select_greater[nat](lst_V)") (("" (prop) (("" (expand "subset?" 1) (("" (skeep) (("" (rewrite "mem_list2set" :dir rl) (("" (name-replace "args" "elim_com_arg(t, s, f)`1") (("" (name-replace "mult_t1" "elim_com_arg(t, s, f)`2") (("" (name-replace "mult_t2" "elim_com_arg(t, s, f)`3") (("" (reveal -1 -2 -3 -4) (("" (rewrite "vars_lst_lst_vars") (("" (inst 1 "dio_matrix2ac_sol(args, lst_V, f)(dio)`2") (("" (prop) (("1" (expand "dio_matrix2ac_sol" 1) (("1" (lemma "get_pre_new_args2") (("1" (inst?) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (rewrite "member_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sec_proj_mem") (("2" (inst 1 "dio_matrix2ac_sol(args, lst_V, f)(dio)") (("2" (expand "solve_ac" 1) (("2" (rewrite "map_member4") (("2" (inst 1 "dio") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (string type-eq-decl nil strings nil) (args type-eq-decl nil term_properties nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (vars_lst_lst_vars formula-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (get_pre_new_args2 formula-decl nil aux_unification nil) (member_append formula-decl nil list_theory nil) (get_repeat_lst def-decl "list[T]" list_theory nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (map_member4 formula-decl nil map_theory nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (dio_solver def-decl "dio_matrix" diophantine nil) (calculate_upper_bound const-decl "nat" diophantine nil) (sec_proj_mem formula-decl nil list_theory2 nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (mem_list2set formula-decl nil list_theory nil) (from_min2max def-decl "list[nat]" list_theory nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (dio_matrix type-eq-decl nil diophantine nil) (subset? const-decl "bool" sets nil) (variable type-eq-decl nil term_properties nil) (select_greater def-decl "nat" list_theory nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("rename_input" rename_input ren_get_pre_new_args1_TCC1 0 (ren_get_pre_new_args1_TCC1-1 nil 3856534362 ("" (skeep) (("" (expand "length" 2) (("" (assert) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (ren_get_pre_new_args1 subtype "(number_fields.-)(list_props[list[nat]].length(rename_input.dio), 1)" "nat")))("rename_input" rename_input ren_get_pre_new_args1 0 (ren_get_pre_new_args1-1 nil 3855846778 ("" (measure-induct "length(dio)" "dio") (("1" (skolem 1 ("D")) (("1" (prop) (("1" (skeep) (("1" (hide 1) (("1" (expand "get_pre_new_args" 1 2) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand "get_pre_new_args" 1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "lst_V1" "cons(get_new_var(lst_V), lst_V)") (("2" (expand "get_pre_new_args" 2 1) (("2" (assert) (("2" (name-replace "lst_V1_" "cons(get_new_var(lst_V_), lst_V_)") (("2" (name-replace "Z" "select_greater[nat](lst_V)") (("2" (name-replace "Z_" "select_greater[nat](lst_V_)") (("2" (name-replace "rho" "shift(lst_V, lst_V_, length(D)-1)") (("1" (name-replace "t_" "variable(get_new_var(lst_V_))") (("1" (name-replace "t" "variable(get_new_var(lst_V))") (("1" (case "t_ = subs(rho)(t)") (("1" (replace -1) (("1" (rewrite "add_new_arg_subs") (("1" (inst -2 "cdr(D)") (("1" (prop) (("1" (inst -1 "lst_V1" "lst_V1_" "add_new_arg(lst_args, car(D), t)") (("1" (prop) (("1" (expand "lst_V1" -1 1) (("1" (expand "lst_V1_" -1 1) (("1" (lemma "get_new_var_shift") (("1" (inst -1 "lst_V" "lst_V_" "length(D) -1") (("1" (reveal -6 -9 -10) (("1" (replace -1) (("1" (assert) (("1" (reveal -7 -8) (("1" (replace -1) (("1" (replace -2) (("1" (replace -4) (("1" (replace -5) (("1" (split -6) (("1" (case "length(cdr(D)) - 1 = length(D) - 2") (("1" (replace -1) (("1" (name-replace "rho1" "shift(lst_V1, lst_V1_, length(D) - 2)") (("1" (hide -1) (("1" (replace -1 2) (("1" (rewrite "subs_map_append_lst_args") (("1" (rewrite "subs_map_append_lst_args") (("1" (replace -7 :dir rl) (("1" (name-replace "lst_args1" "map(subs(rho1))(add_new_arg(lst_args, car(D), t))") (("1" (hide -7) (("1" (use "get_pre_new_args_subs_sel") (("1" (assert) (("1" (hide 3) (("1" (expand "lst_V1_" 1) (("1" (use "dom_basic_sub") (("1" (expand "get_new_var" 1) (("1" (replace -3) (("1" (expand "select_greater" 1 2) (("1" (replace -3) (("1" (expand "max" 1) (("1" (hide -1) (("1" (use "dom_basic_sub2") (("1" (prop) (("1" (replace -1) (("1" (expand "select_greater" 1) (("1" (expand "finset2list" 1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "choose_singleton") (("2" (rewrite "rest_singleton" 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand "select_greater" 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (assert) (("2" (expand "length" 1) (("2" (lift-if) (("2" (assert) (("2" (expand "length" 1) (("2" (split 1) (("1" (expand "get_pre_new_args" 2) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (propax) nil nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (assert) (("2" (expand "length" 1 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (expand "get_pre_new_args" 3) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (expand "length" 1 1) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal -6 -7) (("2" (expand "lst_V1_") (("2" (expand "lst_V1" 1 1) (("2" (expand "get_new_var" 1) (("2" (replace -1) (("2" (replace -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "get_pre_new_args") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (expand "t_" 1) (("2" (expand "t" 1) (("2" (expand "rho" 1) (("2" (expand "get_new_var" 1) (("2" (lemma "shift_cor") (("2" (reveal -5 -6) (("2" (replace -1) (("2" (replace -2) (("2" (expand "shift" 1) (("2" (replace -1) (("2" (replace -2) (("2" (inst?) (("1" (grind) nil nil) ("2" (assert) (("2" (expand "length" 1 1) (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get_new_var const-decl "variable" aux_unification nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (shift_cor formula-decl nil substitution nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (add_new_arg def-decl "list[args]" aux_unification nil) (get_new_var_shift formula-decl nil aux_unification nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subs_map_append_lst_args formula-decl nil substitution nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (null adt-constructor-decl "(null?)" list_adt nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (dom_basic_sub2 formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finset2list def-decl "list[T]" list_theory nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (rest_singleton formula-decl nil sets_lemmas nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (emptyset const-decl "set" sets nil) (choose_singleton formula-decl nil sets_lemmas nil) (select_greater const-decl "nat" more_list_theory_props nil) (dom_basic_sub formula-decl nil substitution nil) (get_pre_new_args_subs_sel formula-decl nil aux_unification nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_new_arg_subs formula-decl nil aux_unification nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (subs def-decl "args" substitution nil) (get_pre_new_args def-decl "[list[args], list[variable]]" aux_unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil) (constant type-eq-decl nil term_properties nil) (args type-eq-decl nil term_properties nil) (TRUE const-decl "bool" booleans nil) (term type-decl nil term_adt nil) (ac_symbol type-eq-decl nil term_properties nil) (f_symbol type-eq-decl nil term_properties nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (variable type-eq-decl nil term_properties nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (select_greater def-decl "nat" list_theory nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (dio_matrix type-eq-decl nil diophantine nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak))("aux_unification" aux_unification solve_ac_sec_proj_vars_dif 0 (solve_ac_sec_proj_vars_dif-1 nil 3856856689 ("" (skeep) (("" (assert) (("" (flatten) (("" (name-replace "Z" "select_greater[nat](lst_V)") (("" (name-replace "Z_" "select_greater[nat](lst_V_)") (("" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("" (name-replace "V1_" "vars(sec_proj(solve_ac(subs(rho)(t), subs(rho)(s), lst_V_, f)))") (("" (name-replace "Z1" "select_greater[nat](finset2list[nat](V1))") (("" (name-replace "Z1_" "select_greater[nat](finset2list[nat](V1_))") (("" (reveal -1 -2 -3 -4 -5 -6) (("" (case "NOT null?(solve_ac(subs(rho)(t), subs(rho)(s), lst_V_, f))") (("1" (case "Z1 + Z_ - Z <= Z1_") (("1" (case "Z1 + Z_ - Z >= Z1_") (("1" (assert) nil nil) ("2" (hide -1 4) (("2" (use "select_greater_mem[nat]") (("2" (assert) (("2" (prop) (("1" (replace -2) (("1" (rewrite "finset2list_mem") (("1" (expand "V1_" -1) (("1" (rewrite "vars_lst_lst_vars" -1) (("1" (skolem -1 "lst_vars") (("1" (prop) (("1" (rewrite "sec_proj_mem") (("1" (skolem -2 "pair") (("1" (flatten) (("1" (expand "solve_ac" -2) (("1" (name-replace "eca" "elim_com_arg(subs(rho)(t), subs(rho)(s), f)") (("1" (rewrite "map_member4") (("1" (skolem -2 "dio") (("1" (flatten) (("1" (reveal -1) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "solve_ac_sec_proj_vars_select_gt") (("2" (inst -1 "f" "lst_V_" "subs(rho)(s)" "subs(rho)(t)") (("2" (assert) (("2" (replace -5) (("2" (replace -7) (("2" (expand "select_greater" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("rename_input" rename_input ren_input_solve_ac2 0 (ren_input_solve_ac2-1 nil 3856533481 ("" (skeep) (("" (assert) (("" (flatten) (("" (hide -5 -6 -1 -2) (("" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("" (name-replace "V1_" "vars(sec_proj(solve_ac(subs(rho)(t), subs(rho)(s), lst_V_, f)))") (("" (case "null?(first_proj(solve_ac(subs(rho)(t), subs(rho)(s), lst_V_, f)))") (("1" (expand "member" -7) (("1" (assert) nil nil)) nil) ("2" (lemma "solve_ac_sec_proj_vars_not_null") (("2" (inst -1 "f" "lst_V_" "subs(rho)(s)" "subs(rho)(t)") (("2" (assert) (("2" (reveal -2 -3) (("2" (replace -1) (("2" (hide -1 -2) (("2" (prop) (("1" (name-replace "Z_" "select_greater[nat](lst_V_)") (("1" (name-replace "Z1_" "select_greater[nat](finset2list[nat](V1_))") (("1" (hide -1) (("1" (hide 1) (("1" (name-replace "t_" "subs(rho)(t)") (("1" (name-replace "s_" "subs(rho)(s)") (("1" (rewrite "first_proj_mem") (("1" (skolem -6 "pair") (("1" (flatten) (("1" (expand "solve_ac" -6) (("1" (rewrite "map_member4") (("1" (skolem -6 "dio") (("1" (flatten) (("1" (name-replace "args_" "elim_com_arg(t_, s_, f)`1") (("1" (name-replace "mult_t1" "elim_com_arg(t_, s_, f)`2") (("1" (name-replace "mult_t2" "elim_com_arg(t_, s_, f)`3") (("1" (hide -6) (("1" (lemma "ren_input_elim_com_arg") (("1" (inst -1 "FV" "f" "(append(Pu, Ps), sig, V)" "(append(Pu_, Ps_), sig_, V_)" "rho" "s" "t") (("1" (prop) (("1" (hide -1 -2 -3) (("1" (replace -6 -7) (("1" (hide -6) (("1" (reveal -13) (("1" (name-replace "Z1" "select_greater[nat](finset2list[nat](V1))") (("1" (reveal -14) (("1" (name-replace "Z" "select_greater[nat](lst_V)") (("1" (lemma "solve_ac_sec_proj_vars_not_null") (("1" (inst -1 "f" "lst_V" "s" "t") (("1" (assert) (("1" (reveal -17) (("1" (replace -3) (("1" (replace -1) (("1" (replace -5) (("1" (name-replace "args" "elim_com_arg(t, s, f)`1") (("1" (case "args_ = subs(rho)(args)") (("1" (hide -1 -2 -3) (("1" (case "NOT null?(solve_ac(t, s, lst_V, f))") (("1" (assert) (("1" (hide 1) (("1" (case "Z1 - (1 + Z) >= 0") (("1" (hide -1) (("1" (hide -2 -3 -4 -5 -6) (("1" (hide -3 -4 -1) (("1" (name-replace "rho1" "shift(lst_V, lst_V_, Z1 - (1 + Z))") (("1" (expand "shift" -1) (("1" (lift-if) (("1" (prop) (("1" (reveal -2 -3 -6) (("1" (hide 2) (("1" (expand "renamed_inputs?" -3) (("1" (flatten) (("1" (expand "select_greater" -5) (("1" (replace -1 -5 :dir rl) (("1" (replace -2 -5 :dir rl) (("1" (rewrite "select_greater_finset2list2set") (("1" (rewrite "select_greater_finset2list2set") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal -4 -5) (("2" (replace -1) (("2" (reveal -23) (("2" (replace -1) (("2" (lemma "ren_dio_matrix2ac") (("2" (reveal -8) (("2" (replace -1 -9) (("2" (hide -1) (("2" (inst -1 "V" "V_" "args" "dio" "f" "lst_V" "lst_V_" "-1 -Z + Z1" "rho") (("1" (assert) (("1" (replace -2) (("1" (replace -3) (("1" (reveal 1) (("1" (replace -2) (("1" (replace -3) (("1" (assert) (("1" (expand "shift" -1) (("1" (replace -2) (("1" (replace -3) (("1" (replace -5) (("1" (case "disjoint?(dom(rho1), V)") (("1" (prop) (("1" (replace -1 -9) (("1" (hide -1) (("1" (name-replace "Pc" "dio_matrix2ac_sol(args, lst_V, f)(dio)`1") (("1" (reveal -1) (("1" (inst 3 "Pc") (("1" (prop) (("1" (rewrite "first_proj_mem") (("1" (inst 1 "dio_matrix2ac_sol(args, lst_V, f)(dio)") (("1" (assert) (("1" (expand "solve_ac" 1) (("1" (rewrite "map_member4") (("1" (inst 1 "dio") (("1" (reveal -12) (("1" (replace -1) (("1" (reveal -18 -19 -20 -14 -11 -15 -16) (("1" (hide -11 -12 -13 -14 -16) (("1" (replace -1) (("1" (expand ("t_" "s_")) (("1" (replace -3) (("1" (replace -4) (("1" (replace -6) (("1" (replace -7) (("1" (rewrite "extract_submatrices_ren" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -9) (("2" (expand "renamed_inputs?" 1) (("2" (case "renaming?(append(rho, rho1))") (("1" (inst 1 "append(rho, rho1)") (("1" (expand "renamed_inputs?" 1) (("1" (prop) (("1" (rewrite "apply_sub_append" 1) (("1" (rewrite "apply_sub_append" 1) (("1" (case "cdr(Pu_) = apply_sub(append(rho, rho1), cdr(Pu))") (("1" (replace -1 :dir rl) (("1" (replace -12 1 :dir rl) (("1" (case "Ps_ = apply_sub(append(rho, rho1), Ps)") (("1" (assert) nil nil) ("2" (hide 2 -1) (("2" (use "ren_input_append") (("2" (assert) (("2" (reveal -32 -33) (("2" (assert) (("2" (flatten) (("2" (expand "renamed_inputs?" -3) (("2" (flatten) (("2" (hide -9 -10 -11 -12 -13 -15 -16 -17 -18 -20 -21) (("2" (rewrite "apply_sub_sub_append" :dir rl) (("2" (lemma "apply_sub_no_effect") (("2" (inst -1 "rho1" "Ps") (("2" (assert) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide-all-but (-4 -14 1)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -3 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skeep) (("2" (inst 2 "t!1") (("2" (rewrite "member_unif_prb_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -5 -6 -7 -8 -10 -11) (("2" (reveal -34 -35) (("2" (use "ren_input_append") (("2" (assert) (("2" (flatten) (("2" (hide -5 -1 -4) (("2" (expand "renamed_inputs?" -1) (("2" (flatten) (("2" (rewrite "apply_sub_sub_append" :dir rl) (("2" (case "apply_sub(rho1, cdr(Pu)) = cdr(Pu)") (("1" (replace -1) (("1" (replace -2 1) (("1" (expand "apply_sub" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide -7 2) (("2" (lemma "apply_sub_no_effect") (("2" (inst?) (("2" (assert) (("2" (expand "nice_input?" -7) (("2" (flatten) (("2" (hide-all-but (-10 -14 1 4)) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -3 "x") (("2" (expand ("member" "intersection")) (("2" (prop) (("2" (expand "subset?" -3) (("2" (inst -3 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -2 "t1") (("2" (inst 2 "t1") (("2" (flatten) (("2" (assert) (("2" (expand "append" 2) (("2" (expand "member" 2) (("2" (prop) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "renamed_inputs?" -2) (("2" (flatten) (("2" (hide -8) (("2" (expand "equal_syn?") (("2" (skolem 1 "x") (("2" (prop) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "subs") (("2" (replace -4) (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (rewrite "subs_append2") (("2" (case "subs(rho1)(subs(sig)(variable(x))) = subs(sig)(variable(x))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "subs_no_effect_t") (("2" (inst -1 "rho1" "subs(sig)(variable(x))") (("2" (assert) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (skolem 1 "y") (("2" (hide 1) (("2" (expand ("member" "intersection") -1) (("2" (prop) (("2" (expand "disjoint?" -12) (("2" (expand "empty?" -12) (("2" (inst -12 "y") (("2" (expand ("member" "intersection") 1) (("2" (assert) (("2" (use "vars_subs_t") (("2" (hide -4 -13 -14 -15 -16) (("2" (expand "subset?" -1) (("2" (inst -1 "y") (("2" (assert) (("2" (expand ("member" "union") -1) (("2" (reveal -38) (("2" (reveal -2) (("2" (prop) (("1" (expand "nice_input?" -3) (("1" (flatten) (("1" (expand "subset?" -6) (("1" (inst -6 "y") (("1" (assert) (("1" (hide-all-but (2 -5 -1)) (("1" (expand "contained?" -2) (("1" (flatten) (("1" (expand "subset?" -3) (("1" (inst -3 "y") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars" -1) (("2" (expand "member" -1) (("2" (expand "singleton" -1) (("2" (replace -1) (("2" (hide-all-but (-2 -10 1)) (("2" (expand "subset?" -2) (("2" (inst -2 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "ren_input_vars_sec_proj") (("3" (inst -1 "FV" "f" "(append(Pu, Ps), sig, V)" "(append(Pu_, Ps_), sig_, V_)" "lst_V" "lst_V_" "rho" "s" "t") (("3" (assert) (("3" (reveal -33 -34) (("3" (expand "append" -3) (("3" (expand "member" -3) (("3" (assert) (("3" (expand "V1" 1) (("3" (expand "V1_" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "solve_ac_sec_proj_vars") (("4" (reveal 4) (("4" (inst -1 "f" "s" "t" "lst_V") (("4" (assert) (("4" (expand "renamed_inputs?" -3) (("4" (flatten) (("4" (hide -9 -12 -13 -14 -15 -17 -18) (("4" (expand "subset?" -6) (("4" (expand "subset?" 2) (("4" (skeep) (("4" (inst -7 "x") (("4" (assert) (("4" (expand "subset?" -1) (("4" (inst -1 "x") (("4" (prop) (("1" (expand "V1" 2) (("1" (propax) nil nil)) nil) ("2" (reveal -12) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -29 4) (("5" (lemma "solve_ac_sec_proj_vars_not_null") (("5" (inst -1 "f" "lst_V" "s" "t") (("5" (assert) (("5" (replace -2) (("5" (replace -9) (("5" (replace -8) (("5" (hide -11 -5 -3 -12 -13) (("5" (expand "subset?" 2) (("5" (skeep) (("5" (use "dom_append") (("5" (expand "subset?" -1) (("5" (inst -1 "x") (("5" (assert) (("5" (hide -4) (("5" (expand ("member" "union") -1) (("5" (prop) (("1" (expand "renamed_inputs?" -4) (("1" (flatten) (("1" (hide -4 -5 -6 -7 -9 -10) (("1" (reveal -18) (("1" (replace -3 2 :dir rl) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (replace -1) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -9 -1 :dir rl) (("2" (use "shift_dom") (("1" (assert) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (replace -3 2 :dir rl) (("1" (expand ("member" "union") 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -18) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (reveal -24) (("6" (expand "subset?" 1) (("6" (skeep) (("6" (hide -12 -13 -11 -5) (("6" (use "vars_img_append") (("6" (expand "subset?" -1) (("6" (inst -1 "x") (("6" (assert) (("6" (expand ("member" "union") -1) (("6" (prop) (("1" (expand "renamed_inputs?" -5) (("1" (flatten) (("1" (hide -5 -6 -7 -8 -9) (("1" (hide -3) (("1" (replace -2 1 :dir rl) (("1" (expand ("member" "union") 1) (("1" (prop) (("1" (hide -5) (("1" (reveal -18) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (replace -9 -1 :dir rl) (("2" (use "shift_img") (("1" (replace -10) (("1" (assert) (("1" (replace -3 1 :dir rl) (("1" (expand ("member" "union") 1) (("1" (flatten) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (reveal -33) (("1" (case "Z1 - Z + Z_ = Z1_") (("1" (assert) nil nil) ("2" (hide -2 -3 -5 -6 -7 2 3 -11) (("2" (reveal -41 -42) (("2" (lemma "ren_solve_ac_sec_proj_vars") (("2" (hide -5) (("2" (inst -1 "FV" "f" "(append(Pu, Ps), sig, V)" "(append(Pu_, Ps_), sig_, V_)" "lst_V" "lst_V_" "rho" "s" "t") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (reveal -46 -47) (("2" (expand "append" 1) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (reveal -46 -47) (("3" (expand ("member" "append") 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -44 -45) (("2" (propax) nil nil)) nil) ("3" (reveal -44 -45) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -17) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -11 -1 -10) (("7" (expand "renamed_inputs?" -1) (("7" (flatten) (("7" (hide -1 -2 -3) (("7" (reveal -35) (("7" (use "solve_ac_sec_proj_vars_not_null") (("7" (assert) (("7" (replace -2) (("7" (replace -10) (("7" (reveal -11 -12) (("7" (replace -1) (("7" (replace -13) (("7" (hide -15 -5 3) (("7" (case "Z_ - Z = 0") (("1" (use "shift_dom2") (("1" (assert) (("1" (skolem 1 ("x")) (("1" (flatten) (("1" (replace -17) (("1" (replace -1) (("1" (use "shift_img2") (("1" (assert) (("1" (replace -18) (("1" (inst -12 "x") (("1" (prop) (("1" (expand "subset?" -11) (("1" (inst -11 "x") (("1" (use "vars_img_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand ("member" "union") -1) (("1" (replace -2) (("1" (expand "vars" -1 2) (("1" (split -1) (("1" (assert) (("1" (replace -7 -10 :dir rl) (("1" (expand ("member" "union") -10) (("1" (hide-all-but (-4 -10 -12)) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (inst -1 "lst_V_" "x") (("1" (expand ("Z" "Z_")) (("1" (assert) (("1" (reveal -30) (("1" (replace -1 :dir rl) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (expand "member" -2) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but 1) (("2" (smash) (("2" (expand "empty?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -8 1)) (("2" (use "vars_img_append") (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (replace -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -3 1)) (("3" (use "dom_append2") (("3" (replace -4) (("3" (replace -3) (("3" (hide -3 -4) (("3" (prop) (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (expand "vars" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -20) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 -2 -4) (("2" (use "shift_dom2") (("1" (assert) (("1" (replace -11) (("1" (use "shift_img2") (("1" (assert) (("1" (replace -12) (("1" (skolem 2 ("x")) (("1" (flatten) (("1" (use "vars_img_append") (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -5) (("1" (expand "member" -1 1) (("1" (expand "union" -1 1) (("1" (lemma "dom_append2") (("1" (inst -1 "rho" "rho1") (("1" (split -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (expand ("member" "union") 2) (("1" (prop) (("1" (inst -8 "x") (("1" (assert) (("1" (replace -4 -5 :dir rl) (("1" (expand ("member" "union") -5) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -8) (("2" (replace -4 -5 :dir rl) (("2" (replace -2 -1) (("2" (rewrite "mem_list2set" :dir rl) (("2" (expand ("member" "union") -5) (("2" (assert) (("2" (hide-all-but (-1 -5 1 4)) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (hide -2) (("2" (lemma "select_greater_lt[nat]") (("2" (inst -1 "lst_V" "x") (("2" (assert) (("2" (reveal -31) (("2" (replace -1 :dir rl) (("2" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -8) (("2" (expand "disjoint?" 1) (("2" (expand "empty?" 1) (("2" (hide -4) (("2" (skolem 1 "y") (("2" (expand ("member" "intersection") -1) (("2" (flatten) (("2" (expand "subset?" -6) (("2" (inst -6 "y") (("2" (assert) (("2" (replace -3) (("2" (rewrite "mem_list2set" :dir rl) (("2" (hide-all-but (-1 -6 1 3)) (("2" (use "from_min2max_mem2[nat]") (("2" (assert) (("2" (hide -2) (("2" (lemma "select_greater_lt[nat]") (("2" (inst -1 "lst_V" "y") (("2" (assert) (("2" (reveal -33) (("2" (replace -1 :dir rl) (("2" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -8) (("3" (hide -4 -1 3) (("3" (expand "disjoint?" 1 1) (("3" (expand "empty?" 1) (("3" (skolem 1 "y") (("3" (expand ("member" "intersection") -1) (("3" (flatten) (("3" (expand "subset?" -5) (("3" (inst -5 "y") (("3" (assert) (("3" (replace -3 -2) (("3" (hide-all-but (-2 -5)) (("3" (rewrite "mem_list2set" :dir rl) (("3" (use "from_min2max_mem2[nat]") (("3" (assert) (("3" (expand "Z" -1) (("3" (lemma "select_greater_lt[nat]") (("3" (inst -1 "lst_V" "y") (("3" (assert) (("3" (reveal -32) (("3" (replace -1 :dir rl) (("3" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -20) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -19) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "shift_append_renaming") (("2" (reveal -10) (("2" (inst -2 "V" "V_" "-1 -Z + Z1" "rho") (("1" (assert) (("1" (case "rho1 = shift(V, V_, -1 - Z + Z1)") (("1" (assert) (("1" (expand "renamed_inputs?" -3) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "rho1" 1) (("2" (expand "shift" 1 2) (("2" (expand "shift" 1) (("2" (replace -5) (("2" (replace -6) (("2" (hide -2) (("2" (reveal -7 -8) (("2" (replace -1 1 :dir rl) (("2" (rewrite "select_greater_finset2list2set") (("2" (replace -2 1 :dir rl) (("2" (rewrite "select_greater_finset2list2set") (("2" (replace -6) (("2" (replace -7) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -9) (("3" (rewrite "apply_sub_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "args" 1 1) (("2" (hide -2 -3 -4) (("2" (lemma "elim_com_arg_vars") (("2" (reveal -28 -30 -31) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -6 "x") (("2" (expand ("member" "intersection") 1) (("2" (expand ("member" "intersection") -5) (("2" (flatten) (("2" (assert) (("2" (inst -4 "f" "t" "s") (("2" (expand "subset?" -4) (("2" (inst -4 "x") (("2" (assert) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (hide -1 -2 -3 -5 -6) (("2" (expand "subset?" -1) (("2" (inst -1 "x") (("2" (assert) (("2" (expand "append" 1) (("2" (expand "vars" 1) (("2" (expand ("member" "union") 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -7) (("3" (hide 4) (("3" (expand "renamed_inputs?" -1) (("3" (flatten) nil nil)) nil)) nil)) nil) ("4" (reveal -7) (("4" (expand "renamed_inputs?" -1) (("4" (flatten) nil nil)) nil)) nil) ("5" (hide 4) (("5" (expand "V1" -4) (("5" (use "solve_ac_sec_proj_vars_dio") (("5" (assert) (("5" (assert) (("5" (hide 2 3 -2 -3 -4 -5) (("5" (reveal -20 -21 -22 -23 -16 -17 -18 -13) (("5" (expand ("t_" "s_")) (("5" (replace -1) (("5" (replace -2) (("5" (replace -3) (("5" (replace -4) (("5" (replace -6) (("5" (replace -7) (("5" (expand "args" -5) (("5" (rewrite "extract_submatrices_ren" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (use "shift_dom") (("1" (replace -5) (("1" (expand "disjoint?" 1) (("1" (expand "empty?" 1) (("1" (skeep) (("1" (expand ("member" "intersection") -2) (("1" (flatten) (("1" (expand "subset?" -1) (("1" (inst -1 "x") (("1" (assert) (("1" (rewrite "mem_list2set" :dir rl) (("1" (use "from_min2max_mem2[nat]") (("1" (assert) (("1" (lemma "select_greater_lt[nat]") (("1" (expand "Z" -2) (("1" (inst -1 "lst_V" "x") (("1" (assert) (("1" (reveal -8) (("1" (replace -1 -5 :dir rl) (("1" (rewrite "mem_list2set" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -10) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal 2) (("2" (use "solve_ac_sec_proj_vars_select_gt") (("2" (assert) (("2" (assert) (("2" (expand "V1" -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (case "member(dio_matrix2ac_sol(args, lst_V, f)(dio), solve_ac(t, s, lst_V, f))") (("1" (expand "member" -1) (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (hide -2 -3 -4 -5) (("2" (reveal -4 -7 -8 -9 -11 -12 -13 -14) (("2" (hide -10 -15) (("2" (expand "solve_ac" 1) (("2" (rewrite "map_member4") (("2" (inst 1 "dio") (("2" (assert) (("2" (expand "args" 1 1) (("2" (expand ("t_" "s_")) (("2" (replace -6) (("2" (replace -7) (("2" (replace -1 -5) (("2" (replace -3 :dir rl) (("2" (replace -4 :dir rl) (("2" (rewrite "extract_submatrices_ren" :dir rl) (("2" (expand "args" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 -8 -3) (("2" (expand "args_" 1) (("2" (expand "args" 1) (("2" (expand ("t_" "s_") 1) (("2" (reveal -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -16) (("2" (expand "append" 1) (("2" (expand "member" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (reveal -17) (("3" (expand "append" 1) (("3" (expand "member" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "first_proj" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (variable type-eq-decl nil term_properties nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) nil (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) nil (TRUE const-decl "bool" booleans nil) (constant type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (unif_prb type-eq-decl nil unification nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (string type-eq-decl nil strings nil) (ac_sol type-eq-decl nil aux_unification nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (first_proj def-decl "list[T1]" list_theory2 nil) (member def-decl "bool" list_props nil) (select_greater def-decl "nat" list_theory nil) (first_proj_mem formula-decl nil list_theory2 nil) (dio_matrix type-eq-decl nil diophantine nil) (calculate_upper_bound const-decl "nat" diophantine nil) (dio_solver def-decl "dio_matrix" diophantine nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (extract_submatrices const-decl "list[dio_matrix]" aux_unification nil) (elim_com_arg const-decl "[args, list[nat], list[nat]]" aux_unification nil) (dio_matrix2ac_sol const-decl "ac_sol" aux_unification nil) (args type-eq-decl nil term_properties nil) (map_member4 formula-decl nil map_theory nil) (append def-decl "list[T]" list_props nil) (nice_input type-eq-decl nil rename_input nil) (nice_input? const-decl "bool" apply_ac_step nil) nil (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil nil (extract_submatrices_ren formula-decl nil aux_unification nil) nil nil (shift_append_renaming formula-decl nil substitution nil) nil nil nil (ren_input_append formula-decl nil rename_input nil) (apply_sub_sub_append formula-decl nil unification nil) (empty? const-decl "bool" sets nil) (vars_unif_prb formula-decl nil unification nil) (member_unif_prb_append formula-decl nil unification nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (apply_sub_no_effect formula-decl nil unification nil) (apply_sub def-decl "unif_prb" unification nil) (apply_sub_append formula-decl nil unification nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (equal_syn? const-decl "bool" substitution nil) (subs_no_effect_t formula-decl nil substitution nil) (vars_subs_t formula-decl nil substitution nil) (contained? const-decl "bool" substitution nil) (singleton const-decl "(singleton?)" sets nil) nil (union const-decl "set" sets nil) (subs_append2 formula-decl nil substitution nil) (var? adt-recognizer-decl "[term -> boolean]" term_adt nil) (variable adt-constructor-decl "[variable -> (var?)]" term_adt nil) (subs const-decl "term" substitution nil) nil nil (ren_input_vars_sec_proj formula-decl nil rename_input nil) (solve_ac_sec_proj_vars formula-decl nil aux_unification nil) (shift_dom formula-decl nil substitution nil) (dom_append formula-decl nil substitution nil) (ren_solve_ac_sec_proj_vars formula-decl nil rename_input nil) nil nil nil nil nil nil nil nil (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (shift_img formula-decl nil substitution nil) (vars_img_append formula-decl nil substitution nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (dom_append2 formula-decl nil substitution nil) (img const-decl "finite_set[term[constant, variable, f_symbol, ac_symbol]]" substitution nil) (finite_union application-judgement "finite_set" finite_sets nil) nil (emptyset const-decl "set" sets nil) (mem_list2set formula-decl nil list_theory nil) (from_min2max def-decl "list[nat]" list_theory nil) nil (select_greater_lt formula-decl nil list_theory nil) (from_min2max_mem2 formula-decl nil list_theory nil) (shift_img2 formula-decl nil substitution nil) (shift_dom2 formula-decl nil substitution nil) (apply_sub_len formula-decl nil unification nil) nil (elim_com_arg_vars formula-decl nil aux_unification nil) nil (solve_ac_sec_proj_vars_dio formula-decl nil aux_unification nil) (dom const-decl "finite_set[variable]" substitution nil) (disjoint? const-decl "bool" sets nil) (- const-decl "[numfield -> numfield]" number_fields nil) nil nil (int_plus_int_is_int application-judgement "int" integers nil) (ren_dio_matrix2ac formula-decl nil rename_input nil) nil (select_greater const-decl "nat" more_list_theory_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (select_greater_finset2list2set formula-decl nil more_list_theory_props nil) (solve_ac_sec_proj_vars_select_gt formula-decl nil aux_unification nil) (NOT const-decl "[bool -> bool]" booleans nil) (subs def-decl "args" substitution nil) (ren_input_elim_com_arg formula-decl nil rename_input nil) (finset2list def-decl "list[T]" list_theory nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (solve_ac_sec_proj_vars_not_null formula-decl nil aux_unification nil) (renaming type-eq-decl nil substitution nil) (renaming? const-decl "bool" substitution nil) nil (sub type-eq-decl nil substitution nil) (basic_sub type-eq-decl nil substitution nil)) shostak))("aux_unification" aux_unification instantiate_step1_subset 0 (instantiate_step1_subset-1 nil 3856949291 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 ("P")) (("" (prop) (("" (expand "instantiate_step" 1 1) (("" (case "null?(P)") (("1" (inst 1 "null") (("1" (assert) (("1" (expand "apply_sub" 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "del" "instantiate_step(t, s)`1") (("1" (name-replace "skp" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (case "fail1") (("1" (inst 2 "null") (("1" (assert) (("1" (expand "apply_sub" 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "skp") (("1" (assert) (("1" (reveal -1 -2 -3 -4 -5) (("1" (lemma "instantiate_step1_append") (("1" (inst?) (("1" (assert) (("1" (hide -2 -3 1) (("1" (prop) (("1" (name-replace "del1" "instantiate_step(P, null, null)`2") (("1" (reveal -1) (("1" (expand "instantiate_step" -1 1) (("1" (replace -3) (("1" (replace -4) (("1" (replace -1) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 3 "null") (("2" (expand "apply_sub" 3) (("2" (use "instantiate_step_fail2") (("2" (assert) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification instantiate_step_ren 0 (instantiate_step_ren-1 nil 3856963892 ("" (measure-induct "length(unif_prb)" "unif_prb") (("" (skolem 1 "P") (("" (prop) (("" (skeep) (("" (hide -1) (("" (expand "instantiate_step" 1 2) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (name-replace "t" "car(P)`1") (("1" (name-replace "s" "car(P)`2") (("1" (name-replace "delta" "instantiate_step(t, s)`1") (("1" (name-replace "skip1" "instantiate_step(t, s)`2") (("1" (name-replace "fail1" "instantiate_step(t, s)`3") (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (expand "fail1" -1) (("1" (expand "apply_sub" 1 1) (("1" (lift-if) (("1" (assert) (("1" (expand "instantiate_step" 1 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand "apply_sub" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (expand "t" -1) (("2" (expand "s" -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "instantiate_step1_append") (("1" (inst -1 "cons((t, s), null)" "cdr(P)") (("1" (assert) (("1" (prop) (("1" (replace -1) (("1" (name-replace "sig" "instantiate_step(cdr(P), cons((t, s), null), null)`2") (("1" (expand "apply_sub" 1 1) (("1" (expand "instantiate_step" 1 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("aux_unification" aux_unification instantiate_step_sub_ren_TCC1 0 (instantiate_step_sub_ren_TCC1-1 nil 3856987383 ("" (subtype-tcc) nil nil) nil nil (instantiate_step_sub_ren subtype "aux_unification.s_" "(term_adt[constant, variable, f_symbol, ac_symbol].var?)")))("aux_unification" aux_unification instantiate_step_sub_ren_TCC2 0 (instantiate_step_sub_ren_TCC2-1 nil 3856987383 ("" (subtype-tcc) nil nil) nil nil (instantiate_step_sub_ren subtype "aux_unification.t_" "(term_adt[constant, variable, f_symbol, ac_symbol].var?)")))("rename_input" rename_input ren_input_next_input_TCC1 0 (ren_input_next_input_TCC2-1 nil 3855251295 ("" (subtype-tcc) nil nil) nil nil (ren_input_next_input subtype "(list_props[unif_pair].append(rename_input.Pu1, rename_input.Ps1), rename_input.sig1, rename_input.V1)" "nice_input")))("rename_input" rename_input ren_input_next_input_TCC2 0 (ren_input_next_input_TCC3-1 nil 3855251295 ("" (subtype-tcc) nil nil) nil nil (ren_input_next_input subtype "(list_props[unif_pair].append(rename_input.Pu1_, rename_input.Ps1_), rename_input.sig1_, rename_input.V1_)" "nice_input")))("rename_input" rename_input ren_input_next_input 0 (ren_input_next_input-2 nil 3856876494 ("" (skeep) (("" (expand "renamed_inputs?" -3) (("" (skolem -3 "rho") (("" (case "Pu_ = apply_sub(rho, Pu)") (("1" (expand "next_input?" -5) (("1" (case "NOT null?(Pu)") (("1" (split -5) (("1" (flatten) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (inst 3 "cdr(Pu)" "Ps" "sig" "V") (("1" (prop) (("1" (expand "next_input?" 1 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide 2) (("2" (assert) (("2" (prop) (("1" (replace -7 -1) (("1" (lemma "all_ac_prb_renaming") (("1" (inst -1 "rho" "Pu") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "apply_sub" -7) (("2" (decompose-equality -7) (("2" (expand "apply_sub" -1) (("2" (decompose-equality -1) (("2" (replace -1) (("2" (replace -2) (("2" (lemma "ren_equal") (("2" (inst -1 "FV" "(append(Pu, Ps), sig, V)" "(append(Pu_, Ps_), sig_, V_)" "rho" "car(Pu)`2" "car(Pu)`1") (("2" (assert) (("2" (rewrite "member_unif_prb_append" 1) (("2" (rewrite "member_unif_prb_append" 1) (("2" (expand "member" 1 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (expand "renamed_inputs?") (("2" (inst 1 "rho") (("2" (expand "renamed_inputs?" 1) (("2" (flatten) (("2" (assert) (("2" (prop) (("2" (expand "apply_sub" -1 1) (("2" (rewrite "null_append") (("2" (assert) (("2" (reveal 2 3) (("2" (assert) (("2" (expand "append" -1) (("2" (decompose-equality -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -12) (("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "t_" "car(Pu_)`1") (("2" (name-replace "s_" "car(Pu_)`2") (("2" (name-replace "cur_V_" "union(vars(Pu_), union(V_, vars(Ps_)))") (("2" (name-replace "lst_V_" "finset2list[variable](cur_V_)") (("2" (name-replace "f" "ac_sym(t_)") (("2" (name-replace "ac_results_" "first_proj(solve_ac(t_, s_, lst_V_, f))") (("2" (name-replace "ac_results_subs_" "instantiate_step(ac_results_)") (("2" (name-replace "V2_" "vars(sec_proj(solve_ac(t_, s_, lst_V_, f)))") (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (skolem -1 ("Pci_" "sig2_")) (("2" (flatten) (("2" (hide -7) (("2" (expand "ac_results_subs_" -1) (("2" (lemma "instantiate_step_mem2") (("2" (inst -1 "ac_results_" "sig2_" "Pci_") (("2" (assert) (("2" (skolem -1 "Pc_") (("2" (flatten) (("2" (hide 1 -11 -12) (("2" (expand "ac_results_" -1) (("2" (expand "V2_" -8) (("2" (hide -2 -3 -5 -6 -7 -8) (("2" (name-replace "t" "car(Pu)`1") (("2" (name-replace "s" "car(Pu)`2") (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (case "t_ = subs(rho)(t) AND s_ = subs(rho)(s) AND f = ac_sym(t)") (("1" (lemma "ren_input_solve_ac") (("1" (assert) (("1" (case "all_ac_prb?(Pu)") (("1" (assert) (("1" (reveal -7) (("1" (flatten) (("1" (replace -4) (("1" (replace -5) (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V, f)))") (("1" (inst -4 "FV" "Pc_" "Ps" "Ps_" "Pu" "Pu_" "V" "V_" "f" "lst_V" "lst_V_" "rho" "s" "sig" "sig_" "t") (("1" (assert) (("1" (case "list2set(lst_V) = V AND list2set(lst_V_) = V_ AND are_ac?(t, s, f)") (("1" (flatten) (("1" (assert) (("1" (skolem -7 "Pc") (("1" (flatten) (("1" (reveal -7) (("1" (replace -11 :dir rl) (("1" (replace -12 :dir rl) (("1" (replace -1 :dir rl) (("1" (replace -5) (("1" (case "nice_input?(append(cdr(Pu), append(Pc, Ps)), sig, V1) AND
       nice_input?(append(cdr(Pu_), append(Pc_, Ps_)), sig_, V1_)") (("1" (hide -1) (("1" (hide -22 -16 -17 -11 -12 -13 -14 -15 -24 -23 -19 -6 -5 -4 -3 -2 -1) (("1" (reveal -18 -19) (("1" (lemma "ren_input_inst_step_cor") (("1" (expand "renamed_inputs?" -6) (("1" (skolem -6 "rho1") (("1" (inst -1 "FV" "Pc" "Pc_" "Ps" "Ps_" "cdr(Pu)" "cdr(Pu_)" "V1" "V1_" "rho1" "sig" "sig_") (("1" (assert) (("1" (assert) (("1" (reveal -17) (("1" (flatten) (("1" (assert) (("1" (split -3) (("1" (name-replace "sig2" "instantiate_step(Pc, null, null)`2") (("1" (name-replace "Pci" "instantiate_step(Pc, null, null)`1") (("1" (case "Pc_ = apply_sub(rho1, Pc)") (("1" (replace -1) (("1" (hide -3 -4) (("1" (replace -4 :dir rl) (("1" (case "Pci_ = apply_sub(rho1, Pci)") (("1" (replace -1 :dir rl) (("1" (reveal -25 -26 -27) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -3 :dir rl) (("1" (inst 3 "apply_sub(sig2, cdr(Pu))" "append(Pci, apply_sub(sig2, Ps))" "append(sig2, sig)" "V1") (("1" (prop) (("1" (hide -1 -2 -3 -4 -5 -6 -7 -8 -11 -12-13 -14 -15) (("1" (expand "next_input?" 1) (("1" (reveal -23 -24 -20) (("1" (replace -3) (("1" (replace -2) (("1" (split 1) (("1" (flatten) (("1" (hide 1) (("1" (reveal 4 -48 -49 -18 -19) (("1" (reveal -7) (("1" (assert) (("1" (replace -4) (("1" (replace -5) (("1" (replace -2) (("1" (replace -3) (("1" (use "subs_equal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (reveal -21 -22 -17) (("2" (replace -3) (("2" (replace -2) (("2" (replace -4 :dir rl) (("2" (replace -1) (("2" (reveal -11 -12) (("2" (rewrite "input_apply_ac_step_mem2") (("2" (inst 1 "Pci" "sig2") (("2" (hide 2) (("2" (lemma "instantiate_step_mem3") (("2" (inst -1 "first_proj(solve_ac(t, s, lst_V, f))" "sig2" "Pci") (("2" (assert) (("2" (inst 1 "Pc") (("2" (assert) (("2" (reveal 6) (("2" (reveal -3 -7) (("2" (lemma "instantiate_step_ren3") (("2" (inst -1 "V1" "rho1" "Pc") (("2" (assert) (("2" (hide 2 3) (("2" (expand "renamed_inputs?" -2) (("2" (flatten) (("2" (assert) (("2" (split 1) (("1" (propax) nil nil) ("2" (reveal -11) (("2" (hide-all-but (-1 1)) (("2" (expand "nice_input?" -1) (("2" (flatten) (("2" (expand "subset?") (("2" (skeep) (("2" (inst -4 "x") (("2" (assert) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -6 "t1") (("2" (inst 1 "t1") (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "renamed_inputs?" 1) (("2" (inst 1 "rho1") nil nil)) nil) ("3" (rewrite "apply_sub_len") (("3" (replace -1) (("3" (rewrite "apply_sub_len" 1) (("3" (replace -1 :dir rl) (("3" (replace -15) (("3" (expand "apply_sub" 1) (("3" (rewrite "apply_sub_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7 4) (("2" (hide -2) (("2" (expand "Pci" 1) (("2" (lemma "instantiate_step_ren1") (("2" (inst -1 "rho1" "Pc") (("2" (assert) (("2" (reveal -3 -4) (("2" (hide-all-but (-1 -2 1)) (("2" (expand "renamed_inputs?" -1) (("2" (flatten) (("2" (skolem 1 "x") (("2" (inst -7 "x") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide-all-but (-7 -9 1)) (("2" (rewrite "nice_input_append") (("2" (rewrite "nice_input_append") (("2" (prop) (("2" (expand "nice_input?" -2) (("2" (flatten) (("2" (expand "subset?" -5) (("2" (inst -5 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 -9 -12 1)) (("2" (expand "renamed_inputs?" -1) (("2" (flatten) (("2" (hide -2 -3 -4 -5 -6 -7) (("2" (rewrite "apply_sub_append") (("2" (use "equal_append_implies_equal2[unif_pair]") (("2" (assert) (("2" (replace -4 -1) (("2" (expand "apply_sub" -1 1) (("2" (rewrite "apply_sub_len") (("2" (rewrite "apply_sub_len") (("2" (flatten) (("2" (rewrite "apply_sub_append" -2) (("2" (use "equal_append_implies_equal2[unif_pair]") (("2" (assert) (("2" (rewrite "apply_sub_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -11) (("2" (expand "apply_sub" 1) (("2" (rewrite "apply_sub_len") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide -9) (("2" (lemma "ren_input_solve_ac_TCC2") (("2" (inst -1 "FV" "Pc_" "Ps" "Ps_" "Pu" "Pu_" "V" "V_" "f" "lst_V" "lst_V_" "rho" "s" "sig" "sig_" "t" "V1_" "V1") (("2" (assert) (("2" (inst -1 "Pc") (("2" (assert) (("2" (lemma "ren_input_solve_ac_TCC4") (("2" (inst -1 "FV" "Pc_" "Ps" "Ps_" "Pu" "Pu_" "V" "V_" "f" "lst_V" "lst_V_" "rho" "s" "sig" "sig_" "t" "V1_" "V1") (("2" (assert) (("2" (inst -1 "Pc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4 -4) (("2" (prop) (("1" (reveal -9) (("1" (hide -2 -3 -4 -5 -6 -7 -10 -16 -17 -18 -11 -12 -13 -14) (("1" (rewrite "subset_antisymmetric") (("1" (expand "subset?" 1) (("1" (skeep) (("1" (rewrite "mem_list2set" :dir rl) (("1" (replace -3 -1 :dir rl) (("1" (rewrite "finset2list_mem") (("1" (expand "cur_V" -1) (("1" (expand "member" -1) (("1" (expand "union" -1 1) (("1" (expand "member" -1 2) (("1" (expand "union" -1) (("1" (assert) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (expand "subset?" -5) (("1" (inst -5 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb" 2) (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (inst 2 "t1") (("1" (flatten) (("1" (assert) (("1" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb" 2) (("2" (skolem -1 "t1") (("2" (inst 2 "t1") (("2" (flatten) (("2" (assert) (("2" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lst_V" 1) (("2" (expand "cur_V" 1) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "finset2list_mem") (("2" (expand ("member" "union") 1) (("2" (prop) (("2" (expand "member" 2 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -10) (("2" (hide-all-but (-1 1)) (("2" (expand "lst_V_" 1) (("2" (expand "cur_V_") (("2" (rewrite "subset_antisymmetric") (("1" (hide 2) (("1" (expand "subset?" 1) (("1" (skeep) (("1" (rewrite "mem_list2set" :dir rl) (("1" (rewrite "finset2list_mem") (("1" (expand ("member" "union") -1) (("1" (expand "nice_input?" -2) (("1" (flatten) (("1" (hide -2 -3 -4 -6 -7) (("1" (expand "subset?" -2) (("1" (inst -2 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "vars_unif_prb") (("1" (rewrite "vars_unif_prb") (("1" (skolem -1 "t1") (("1" (inst 2 "t1") (("1" (flatten) (("1" (assert) (("1" (rewrite "member_unif_prb_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1 1) (("2" (rewrite "vars_unif_prb") (("2" (rewrite "vars_unif_prb") (("2" (skolem -1 "t1") (("2" (inst 2 "t1") (("2" (prop) (("2" (rewrite "member_unif_prb_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?" 1) (("2" (skeep) (("2" (rewrite "mem_list2set" :dir rl) (("2" (rewrite "finset2list_mem") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 -4 -5 -6 1 3)) (("3" (expand "all_ac_prb?" -1) (("3" (inst -1 "car(Pu)") (("3" (expand "member" -1 1) (("3" (assert) (("3" (expand "ac_prb?" -1) (("3" (flatten) (("3" (expand ("t" "s")) (("3" (expand "are_ac?" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -10 1)) (("2" (replace -2 -1) (("2" (use "all_ac_prb_renaming") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -18 -19) (("2" (hide 4) (("2" (expand "f" 1 1) (("2" (case "t_ = subs(rho)(t)") (("1" (prop) (("1" (replace -11 -2) (("1" (expand "apply_sub" -2) (("1" (assert) (("1" (expand "apply_sub" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lemma "renaming_is_ac_sym") (("2" (inst -1 "f" "rho" "t") (("2" (expand "is_ac_sym?" -1) (("2" (assert) (("2" (expand "f" -1) (("2" (expand "all_ac_prb?" -10) (("2" (inst -10 "car(Pu_)") (("2" (assert) (("2" (expand "member" -10) (("2" (expand "ac_prb?" -10) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 :dir rl) (("2" (replace -10 1) (("2" (expand "apply_sub" 1) (("2" (expand "apply_sub" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -18 -19) (("3" (hide -11 4) (("3" (case "t_ = subs(rho)(t)") (("1" (prop) (("1" (expand "all_ac_prb?" -12) (("1" (inst -12 "car(Pu_)") (("1" (expand "member" -12) (("1" (expand "ac_prb?" -12) (("1" (flatten) (("1" (replace -3) (("1" (hide-all-but (-1 -12 1)) (("1" (replace -1) (("1" (lemma "renaming_ord2") (("1" (inst -1 "rho" "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 :dir rl) (("2" (replace -10) (("2" (expand "apply_sub" 1) (("2" (assert) (("2" (expand "apply_sub" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "null?(Pu_)") (("1" (assert) nil nil) ("2" (hide-all-but (-1 -8 1)) (("2" (expand "length" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (expand "renamed_inputs?" -1) (("2" (flatten) (("2" (hide -2 -3 -4 -5 -6 -7) (("2" (rewrite "apply_sub_append") (("2" (use "equal_append_implies_equal2[unif_pair]") (("2" (assert) (("2" (rewrite "apply_sub_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (next_input? const-decl "bool" apply_ac_step nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Pu skolem-const-decl "unif_prb" rename_input nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_append formula-decl nil list_theory nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (renamed_inputs? const-decl "bool" rename_input nil) (ren_equal formula-decl nil rename_input nil) (member def-decl "bool" unification nil) (member_unif_prb_append formula-decl nil unification nil) (nice_input? const-decl "bool" apply_ac_step nil) (nice_input type-eq-decl nil rename_input nil) (append def-decl "list[T]" list_props nil) (subs def-decl "term" substitution nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (apply_sub const-decl "unif_pair" unification nil) (all_ac_prb_renaming formula-decl nil unification nil) (finset2list def-decl "list[T]" list_theory nil) (every adt-def-decl "boolean" list_adt nil) (solve_ac const-decl "list[ac_sol]" aux_unification nil) (ac_sol type-eq-decl nil aux_unification nil) (string type-eq-decl nil strings nil) (first_proj def-decl "list[T1]" list_theory2 nil) (sec_proj def-decl "list[T2]" list_theory2 nil) (vars def-decl "finite_set[variable]" term_properties nil) (ac_results_subs_ skolem-const-decl "list[[unif_prb, sub]]" rename_input nil) (V2_ skolem-const-decl "finite_set[variable]" rename_input nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list2set def-decl "set[T]" list2set nil) (are_ac? const-decl "bool" term_properties nil) (ren_input_inst_step_cor formula-decl nil rename_input nil) (null adt-constructor-decl "(null?)" list_adt nil) (instantiate_step def-decl "[unif_prb, sub, bool]" aux_unification nil) (apply_sub_len formula-decl nil unification nil) (input_apply_ac_step_mem2 formula-decl nil apply_ac_step nil) (instantiate_step_ren3 formula-decl nil aux_unification nil) (subset? const-decl "bool" sets nil) (vars_unif_prb formula-decl nil unification nil) (instantiate_step_mem3 formula-decl nil aux_unification nil) (subs_equal? formula-decl nil substitution nil) (instantiate_step_ren1 formula-decl nil aux_unification nil) (nice_input_append formula-decl nil apply_ac_step nil) (Pci skolem-const-decl "unif_prb" rename_input nil) (equal_append_implies_equal2 formula-decl nil list_theory nil) (apply_sub_append formula-decl nil unification nil) (ren_input_solve_ac_TCC4 subtype-tcc nil rename_input nil) (ren_input_solve_ac_TCC2 subtype-tcc nil rename_input nil) (lst_V skolem-const-decl "list[variable]" rename_input nil) (mem_list2set formula-decl nil list_theory nil) (finset2list_mem formula-decl nil list_theory nil) (member const-decl "bool" sets nil) (cur_V skolem-const-decl "finite_set[variable]" rename_input nil) (subset_antisymmetric formula-decl nil sets_lemmas nil) (cur_V_ skolem-const-decl "finite_set[variable]" rename_input nil) (vars const-decl "finite_set[variable]" unification nil) (lst_V_ skolem-const-decl "list[variable]" rename_input nil) (member def-decl "bool" list_props nil) (ac_prb? const-decl "bool" unification nil) (s skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" rename_input nil) (t skolem-const-decl "term[constant, variable, f_symbol, ac_symbol]" rename_input nil) (all_ac_prb? const-decl "bool" unification nil) (ren_input_solve_ac formula-decl nil rename_input nil) (is_ac_sym? const-decl "bool" term_properties nil) (renaming_is_ac_sym formula-decl nil substitution nil) (f skolem-const-decl "ac_symbol" rename_input nil) (renaming_ord2 formula-decl nil substitution nil) (ac_results_ skolem-const-decl "list[unif_prb]" rename_input nil) (instantiate_step_mem2 formula-decl nil aux_unification nil) (input_apply_ac_step_mem formula-decl nil apply_ac_step nil) (instantiate_step def-decl "list[[unif_prb, sub]]" aux_unification nil) (ac_app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ac_sym adt-accessor-decl "[(ac_app?) -> ac_symbol]" term_adt nil) (union const-decl "set" sets nil) (vars def-decl "finite_set[variable]" unification nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (f_symbol type-eq-decl nil term_properties nil) (ac_symbol type-eq-decl nil term_properties nil) (term type-decl nil term_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (int nonempty-type-eq-decl nil integers nil) (constant type-eq-decl nil term_properties nil) (variable type-eq-decl nil term_properties nil) (unif_pair type-eq-decl nil unification nil) (list type-decl nil list_adt nil) (unif_prb type-eq-decl nil unification nil) (= const-decl "[T, T -> boolean]" equalities nil) (basic_sub type-eq-decl nil substitution nil) (sub type-eq-decl nil substitution nil) (apply_sub def-decl "unif_prb" unification nil) (renaming? const-decl "bool" substitution nil) (renaming type-eq-decl nil substitution nil) (renamed_inputs? const-decl "bool" rename_input nil)) nil) (ren_input_next_input-1 nil 3855338636 ("" (skeep) (("" (expand "renamed_inputs?" -3) (("" (skolem -3 "rho") (("" (case "Pu_ = apply_sub(rho, Pu)") (("1" (expand "next_input?" -5) (("1" (case "NOT null?(Pu)") (("1" (split -5) (("1" (flatten) (("1" (replace -3) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (inst 3 "cdr(Pu)" "Ps" "sig" "V") (("1" (prop) (("1" (expand "next_input?" 1 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide 2) (("2" (assert) (("2" (prop) (("1" (replace -7 -1) (("1" (lemma "all_ac_prb_renaming") (("1" (inst -1 "rho" "Pu") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "apply_sub" -7) (("2" (decompose-equality -7) (("2" (expand "apply_sub" -1) (("2" (decompose-equality -1) (("2" (replace -1) (("2" (replace -2) (("2" (lemma "ren_equal") (("2" (inst -1 "FV" "(append(Pu, Ps), sig, V)" "(append(Pu_, Ps_), sig_, V_)" "rho" "car(Pu)`2" "car(Pu)`1") (("2" (assert) (("2" (rewrite "member_unif_prb_append" 1) (("2" (rewrite "member_unif_prb_append" 1) (("2" (expand "member" 1 1) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (expand "renamed_inputs?") (("2" (inst 1 "rho") (("2" (expand "renamed_inputs?" 1) (("2" (flatten) (("2" (assert) (("2" (prop) (("2" (expand "apply_sub" -1 1) (("2" (rewrite "null_append") (("2" (assert) (("2" (reveal 2 3) (("2" (assert) (("2" (expand "append" -1) (("2" (decompose-equality -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -12) (("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name-replace "t_" "car(Pu_)`1") (("2" (name-replace "s_" "car(Pu_)`2") (("2" (name-replace "cur_V_" "union(vars(Pu_), union(V_, vars(Ps_)))") (("2" (name-replace "lst_V_" "finset2list[variable](cur_V_)") (("2" (name-replace "f" "ac_sym(t_)") (("2" (name-replace "ac_results_" "first_proj(solve_ac(t_, s_, lst_V_, f))") (("2" (name-replace "ac_results_subs_" "instantiate_step(ac_results_)") (("2" (name-replace "V2_" "vars(sec_proj(solve_ac(t_, s_, lst_V_, f)))") (("2" (use "input_apply_ac_step_mem") (("2" (assert) (("2" (skolem -1 ("Pci_" "sig2_")) (("2" (flatten) (("2" (hide -7) (("2" (expand "ac_results_subs_" -1) (("2" (lemma "instantiate_step_mem2") (("2" (inst -1 "ac_results_" "sig2_" "Pci_") (("2" (assert) (("2" (skolem -1 "Pc_") (("2" (flatten) (("2" (hide 1 -11 -12) (("2" (expand "ac_results_" -1) (("2" (expand "V2_" -8) (("2" (hide -2 -3 -5 -6 -7 -8) (("2" (name-replace "t" "car(Pu)`1") (("2" (name-replace "s" "car(Pu)`2") (("2" (name-replace "cur_V" "union(vars(Pu), union(V, vars(Ps)))") (("2" (name-replace "lst_V" "finset2list[variable](cur_V)") (("2" (case "t_ = subs(rho)(t) AND s_ = subs(rho)(s) AND f = ac_sym(t)") (("1" (lemma "ren_input_solve_ac") (("1" (assert) (("1" (case "all_ac_prb?(Pu)") (("1" (assert) (("1" (reveal -7) (("1" (flatten) (("1" (replace -4) (("1" (replace -5) (("1" (name-replace "V1" "vars(sec_proj(solve_ac(t, s, lst_V_, f)))") (("1" (inst -4 "FV" "Pc_" "Ps" "Ps_" "Pu" "Pu_" "V" "V_" "f" "lst_V" "lst_V_" "rho" "s" "sig" "sig_" "t") (("1" (assert) (("1" (prop) (("1" (hide 1 2 -18 -10 -11 -8 -9 -7 -6 -5 -4 -3) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -10 1)) (("2" (replace -2 -1) (("2" (use "all_ac_prb_renaming") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -18 -19) (("2" (hide 4) (("2" (expand "f" 1 1) (("2" (case "t_ = subs(rho)(t)") (("1" (prop) (("1" (replace -11 -2) (("1" (expand "apply_sub" -2) (("1" (assert) (("1" (expand "apply_sub" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lemma "renaming_is_ac_sym") (("2" (inst -1 "f" "rho" "t") (("2" (expand "is_ac_sym?" -1) (("2" (assert) (("2" (expand "f" -1) (("2" (expand "all_ac_prb?" -10) (("2" (inst -10 "car(Pu_)") (("2" (assert) (("2" (expand "member" -10) (("2" (expand "ac_prb?" -10) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 :dir rl) (("2" (replace -10 1) (("2" (expand "apply_sub" 1) (("2" (expand "apply_sub" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -18 -19) (("3" (hide -11 4) (("3" (case "t_ = subs(rho)(t)") (("1" (prop) (("1" (expand "all_ac_prb?" -12) (("1" (inst -12 "car(Pu_)") (("1" (expand "member" -12) (("1" (expand "ac_prb?" -12) (("1" (flatten) (("1" (replace -3) (("1" (hide-all-but (-1 -12 1)) (("1" (replace -1) (("1" (lemma "renaming_ord2") (("1" (inst -1 "rho" "t") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 :dir rl) (("2" (replace -10) (("2" (expand "apply_sub" 1) (("2" (assert) (("2" (expand "apply_sub" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "null?(Pu_)") (("1" (assert) nil nil) ("2" (hide-all-but (-1 -8 1)) (("2" (expand "length" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (expand "renamed_inputs?" -1) (("2" (flatten) (("2" (hide -2 -3 -4 -5 -6 -7) (("2" (rewrite "apply_sub_append") (("2" (use "equal_append_implies_equal2[unif_pair]") (("2" (assert) (("2" (rewrite "apply_sub_len") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("rename_input" rename_input ren_input_not_null_first_proj_TCC1 0 (ren_input_not_null_first_proj_TCC1-1 nil 3855600895 ("" (subtype-tcc) nil nil) nil nil (ren_input_not_null_first_proj subtype "rename_input.Pu" "(list_adt[unif_pair].cons?)")))